{
  "version": 3,
  "sources": ["../../lib/TraySearchList.jsx", "../../lib/hooks.js", "../../lib/utils.jsx"],
  "sourcesContent": ["import { useCallback, useEffect, useRef, useState } from \"preact/hooks\";\nimport { subscribeToVirtualKeyboard } from \"./hooks.js\";\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Translations} Translations\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @typedef {Object} TraySearchListProps\n * @property {string} id - Component ID for ARIA attributes\n * @property {boolean} isOpen - Whether the tray is open\n * @property {() => void} onClose - Callback to close the tray\n * @property {string} [trayLabel] - Label for the tray header\n * @property {string} theme - Theme ('light' | 'dark' | 'system')\n * @property {Translations} translations - Translation strings\n * @property {(value: string) => void} onInputChange - Handle input change\n * @property {import(\"preact\").ComponentChildren} children - The AutocompleteList component\n */\n\n/**\n * TraySearchList component - handles mobile tray with search input and options list\n * @param {TraySearchListProps} props\n */\nconst TraySearchList = ({\n  id,\n  isOpen,\n  onClose,\n  trayLabel,\n  theme,\n  translations,\n  onInputChange,\n  children,\n}) => {\n  // Tray-specific state\n  const [trayInputValue, setTrayInputValue] = useState(\"\");\n  const [virtualKeyboardHeight, setVirtualKeyboardHeight] = useState(0);\n  const trayInputRef = useRef(/** @type {HTMLInputElement | null} */ (null));\n  const trayModalRef = useRef(/** @type {HTMLDivElement | null} */ (null));\n  const originalOverflowRef = useRef(\"\");\n  const virtualKeyboardHeightAdjustSubscription = useRef(/** @type {function | null} */ (null));\n  const virtualKeyboardExplicitlyClosedRef = useRef(false);\n  const readonlyResetTimeoutRef = useRef(\n    /** @type {ReturnType<typeof setTimeout> | null} */ (null),\n  );\n\n  // Handle tray input change\n  const handleTrayInputChange = useCallback(\n    /**\n     * @param {import('preact/compat').ChangeEvent<HTMLInputElement>} e\n     */\n    (e) => {\n      const value = e.currentTarget.value;\n      setTrayInputValue(value);\n      onInputChange(value);\n    },\n    [onInputChange],\n  );\n\n  const preventKeyboardReopenOnOptionTap = useCallback(() => {\n    const input = trayInputRef.current;\n    if (!input) return;\n    const shouldTemporarilyDisableInput =\n      virtualKeyboardExplicitlyClosedRef.current === true && document.activeElement === input;\n    if (!shouldTemporarilyDisableInput) return;\n    input.setAttribute(\"readonly\", \"readonly\");\n    if (readonlyResetTimeoutRef.current) {\n      clearTimeout(readonlyResetTimeoutRef.current);\n    }\n    readonlyResetTimeoutRef.current = setTimeout(() => {\n      input.removeAttribute(\"readonly\");\n      readonlyResetTimeoutRef.current = null;\n    }, 10);\n  }, []);\n\n  // Handle tray close\n  const handleClose = useCallback(() => {\n    setTrayInputValue(\"\");\n    setVirtualKeyboardHeight(0);\n    virtualKeyboardExplicitlyClosedRef.current = false;\n    virtualKeyboardHeightAdjustSubscription.current?.();\n    virtualKeyboardHeightAdjustSubscription.current = null;\n    if (readonlyResetTimeoutRef.current) {\n      clearTimeout(readonlyResetTimeoutRef.current);\n      readonlyResetTimeoutRef.current = null;\n    }\n    trayInputRef.current?.removeAttribute(\"readonly\");\n\n    // Restore original overflow\n    const scrollingElement = /** @type {HTMLElement} */ (\n      document.scrollingElement || document.documentElement\n    );\n    scrollingElement.style.overflow = originalOverflowRef.current;\n\n    onClose();\n  }, [onClose]);\n\n  // Setup virtual keyboard subscription and overflow handling when tray opens\n  useEffect(() => {\n    if (isOpen) {\n      // Get the scrolling element (body or html)\n      const scrollingElement = /** @type {HTMLElement} */ (\n        document.scrollingElement || document.documentElement\n      );\n\n      // Save original overflow and apply hidden\n      originalOverflowRef.current = scrollingElement.style.overflow;\n      scrollingElement.style.overflow = \"hidden\";\n\n      // Subscribe to virtual keyboard for tray\n      if (!virtualKeyboardHeightAdjustSubscription.current) {\n        virtualKeyboardHeightAdjustSubscription.current = subscribeToVirtualKeyboard({\n          heightCallback(keyboardHeight, isVisible) {\n            setVirtualKeyboardHeight(isVisible ? keyboardHeight : 0);\n            virtualKeyboardExplicitlyClosedRef.current = !isVisible;\n          },\n        });\n      }\n\n      // Focus the input when tray opens\n      trayInputRef.current?.focus();\n    }\n  }, [isOpen]);\n\n  // Clean up when component unmounts or tray closes\n  useEffect(() => {\n    return () => {\n      if (virtualKeyboardHeightAdjustSubscription.current) {\n        virtualKeyboardHeightAdjustSubscription.current();\n        virtualKeyboardHeightAdjustSubscription.current = null;\n      }\n      if (readonlyResetTimeoutRef.current) {\n        clearTimeout(readonlyResetTimeoutRef.current);\n        readonlyResetTimeoutRef.current = null;\n      }\n      trayInputRef.current?.removeAttribute(\"readonly\");\n      virtualKeyboardExplicitlyClosedRef.current = false;\n    };\n  }, []);\n\n  // Children contains the SearchableList component\n\n  if (!isOpen) {\n    return null;\n  }\n\n  return (\n    // I couldn't use native <dialog> element because trying to focus input right\n    // after dialog.close() doesn't seem to work on Chrome (Android).\n    <div\n      ref={trayModalRef}\n      className={`PreactCombobox-modal ${`PreactCombobox--${theme}`}`}\n      style={{ display: isOpen ? null : \"none\" }}\n      onClick={(e) => {\n        // Close modal when clicking backdrop\n        if (e.target === trayModalRef.current) {\n          handleClose();\n        }\n      }}\n      onKeyDown={(e) => {\n        if (e.key === \"Escape\") {\n          handleClose();\n        }\n      }}\n      // biome-ignore lint/a11y/useSemanticElements: Custom modal implementation instead of dialog element\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby={trayLabel ? `${id}-tray-label` : undefined}\n      tabIndex={-1}\n    >\n      <div className={`PreactCombobox-tray ${`PreactCombobox--${theme}`}`}>\n        <div className=\"PreactCombobox-trayHeader\">\n          {trayLabel && (\n            <label\n              id={`${id}-tray-label`}\n              className=\"PreactCombobox-trayLabel\"\n              htmlFor={`${id}-tray-input`}\n            >\n              {trayLabel}\n            </label>\n          )}\n          <input\n            id={`${id}-tray-input`}\n            ref={trayInputRef}\n            type=\"text\"\n            value={trayInputValue}\n            placeholder={translations.searchPlaceholder}\n            onChange={handleTrayInputChange}\n            onKeyDown={(e) => {\n              if (e.key === \"Escape\") {\n                handleClose();\n              }\n            }}\n            className={`PreactCombobox-trayInput ${!trayLabel ? \"PreactCombobox-trayInput--noLabel\" : \"\"}`}\n            role=\"combobox\"\n            aria-expanded=\"true\"\n            aria-haspopup=\"listbox\"\n            aria-controls={`${id}-options-listbox`}\n            aria-label={trayLabel || translations.searchPlaceholder}\n            autoComplete=\"off\"\n          />\n        </div>\n        <div\n          onMouseDownCapture={preventKeyboardReopenOnOptionTap}\n          onTouchStartCapture={preventKeyboardReopenOnOptionTap}\n        >\n          {children}\n        </div>\n        {virtualKeyboardHeight > 0 && (\n          <div\n            className=\"PreactCombobox-virtualKeyboardSpacer\"\n            style={{ height: `${virtualKeyboardHeight}px` }}\n            aria-hidden=\"true\"\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TraySearchList;\n", "import { useCallback, useEffect, useMemo, useRef, useState } from \"preact/hooks\";\nimport { getMatchScore, sortValuesToTop } from \"./utils.jsx\";\n\n/**\n * Returns a ref that always holds the latest value.\n * Useful for accessing current values in effects without adding them to deps.\n * Similar to React's experimental useEffectEvent.\n * @template {any[] | ((...args: any[]) => any)} T\n * @param {T} value\n * @returns {T}\n */\n// function useEffectEvent(value) {\n//   const ref = useRef(value);\n//   ref.current = value;\n//   /** @type {{ current: T }} */\n//   // @ts-ignore\n//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n//   const stableRef = useMemo(() => {\n//     // @ts-ignore\n//     return typeof ref.current === 'function' ? { current: (...args) => ref.current(...args) } : ref;\n//   }, [typeof ref.current]);\n//   return stableRef.current;\n// }\n\n/**\n * @param {any} value1\n * @param {any} value2\n * @returns {boolean}\n */\nexport function isEqual(value1, value2) {\n  // Handle circular references using WeakMap\n  const seenA = new WeakMap();\n  const seenB = new WeakMap();\n\n  /**\n   * @param {any} a\n   * @param {any} b\n   * @returns {boolean}\n   */\n  function deepCompare(a, b) {\n    // Handle primitives\n    if (Object.is(a, b)) return true;\n    if (a === null || b === null || typeof a !== \"object\" || typeof b !== \"object\") {\n      return a === b;\n    }\n\n    // Handle React/JSX elements - direct reference comparison since they're immutable\n    // This prevents unnecessary deep comparisons\n    if (a.$$typeof === Symbol.for(\"react.element\") || b.$$typeof === Symbol.for(\"react.element\")) {\n      return a === b;\n    }\n\n    // Handle different types\n    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n      return false;\n    }\n\n    // Check for circular references\n    if (seenA.has(a)) return seenA.get(a) === b;\n    if (seenB.has(b)) return seenB.get(b) === a;\n    // detect cross object circular references\n    if (seenA.has(b) || seenB.has(a)) return false;\n    seenA.set(a, b);\n    seenB.set(b, a);\n\n    // Handle Arrays\n    if (Array.isArray(a)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      return a.every((item, index) => deepCompare(item, b[index]));\n    }\n\n    // Handle Dates\n    if (a instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n\n    // Handle RegExp\n    if (a instanceof RegExp) {\n      return a.toString() === b.toString();\n    }\n\n    // Handle Objects\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    return keysA.every((key) => keysB.includes(key) && deepCompare(a[key], b[key]));\n  }\n\n  return deepCompare(value1, value2);\n}\n\n/**\n * Both dependencies and state are compared using a deep equality function.\n * @template T\n * @param {T} newState\n * @returns {T}\n */\nexport function useDeepMemo(newState) {\n  const state = useRef(/** @type {T} */ (null));\n  if (!isEqual(newState, state.current)) {\n    state.current = newState;\n  }\n  return state.current;\n}\n\n/**\n * @template T\n * @param {T} initialValue\n * @returns {[() => T, (value: T) => void, boolean]}\n */\nexport function useLive(initialValue) {\n  const [refreshValue, forceRefresh] = useState(0);\n  const ref = useRef(initialValue);\n\n  // refreshValue is used to create a new getter so that any useEffect etc that depends on it will be re-run\n  // In addition, provide `hasValueChanged` to help detect in a multi-dependency useEffect whether this specific\n  // state has changed.\n  let hasValueChanged = false;\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explanation above\n  const getValue = useMemo(() => {\n    hasValueChanged = true;\n    return () => ref.current;\n  }, [refreshValue]);\n\n  // setter doesn't need to be created on every render\n  const setValue = useCallback(\n    /** @param {T} value */\n    (value) => {\n      if (value !== ref.current) {\n        ref.current = value;\n        forceRefresh((x) => x + 1);\n      }\n    },\n    [],\n  );\n\n  return [getValue, setValue, hasValueChanged];\n}\n\nconst isTouchDevice =\n  typeof window !== \"undefined\" && window.matchMedia?.(\"(pointer: coarse)\")?.matches;\n// Since page hasn't potentially fully loaded yet we get only an approximate height\nconst visualViewportInitialHeight = window.visualViewport?.height ?? 0;\n\n/**\n * Subscribe to virtual keyboard visibility changes (touch devices only)\n * @param {Object} params - Parameters for subscribing to virtual keyboard\n * @param {function(boolean): void} [params.visibleCallback] - Called with boolean when keyboard visibility changes\n * @param {function(number, boolean): void} [params.heightCallback] - Called with keyboard height when keyboard height changes\n * @returns {function | null} - Unsubscribe function\n */\nexport function subscribeToVirtualKeyboard({ visibleCallback, heightCallback }) {\n  if (!isTouchDevice || typeof window === \"undefined\" || !window.visualViewport) return null;\n\n  let isVisible = false;\n  const handleViewportResize = () => {\n    if (!window.visualViewport) return;\n    const heightDiff = visualViewportInitialHeight - window.visualViewport.height;\n    const isVisibleNow = heightDiff > 150;\n    if (isVisible !== isVisibleNow) {\n      isVisible = isVisibleNow;\n      visibleCallback?.(isVisible);\n    }\n    heightCallback?.(heightDiff, isVisible);\n  };\n  window.visualViewport.addEventListener(\"resize\", handleViewportResize, { passive: true });\n  return () => {\n    window.visualViewport?.removeEventListener(\"resize\", handleViewportResize);\n  };\n}\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n */\n\n/**\n * @typedef {Object} UseAsyncOptionsParams\n * @property {Option[] | ((queryOrValues: string[] | string, limit: number, currentSelections: string[], abortControllerSignal: AbortSignal) => Promise<Option[]>)} allowedOptions\n * @property {string[]} selectedValues - Currently selected values that need labels resolved\n * @property {string} searchText - Current search query\n * @property {boolean} isOpen - Whether the dropdown is open (triggers search fetching)\n * @property {string} language - Language code for matching\n * @property {number} maxNumberOfPresentedOptions - Max options to fetch/display\n */\n\n/**\n * @typedef {Object} UseAsyncOptionsResult\n * @property {OptionMatch[]} filteredOptions - Options to display (filtered/searched)\n * @property {{ [value: string]: Option }} resolvedOptionsLookup - Lookup for all resolved options (for labels)\n * @property {boolean} isLoading - Whether options are currently being fetched\n */\n\n// @ts-ignore\nconst isPlaywright = typeof navigator !== \"undefined\" && navigator.webdriver === true;\n\n/**\n * Hook that handles async option fetching, caching, and filtering.\n * - Resolves labels for selected values even when dropdown is closed\n * - Handles search/filtering when dropdown is open\n * - Supports both array-based (local filtering) and function-based (remote filtering)\n *\n * @param {UseAsyncOptionsParams} params\n * @returns {UseAsyncOptionsResult}\n */\nexport function useAsyncOptions({\n  allowedOptions: allowedOptionsOriginal,\n  selectedValues: selectedValuesOriginal,\n  searchText,\n  isOpen,\n  language,\n  maxNumberOfPresentedOptions,\n}) {\n  const [filteredOptions, setFilteredOptions] = useState(/** @type {OptionMatch[]} */ ([]));\n  const [isLoading, setIsLoading] = useState(false);\n  const [cacheVersion, setCacheVersion] = useState(0);\n  const cachedOptions = useRef(/** @type {{ [value: string]: Option }} */ ({}));\n  const abortControllerRef = useRef(/** @type {AbortController | null} */ (null));\n  const debounceTimerRef = useRef(/** @type {ReturnType<typeof setTimeout> | null} */ (null));\n  // Track if this is the first time isOpen became true (to skip debounce on first open)\n  const wasOpenRef = useRef(false);\n\n  const searchTextTrimmed = searchText.trim();\n  const isFunction = typeof allowedOptionsOriginal === \"function\";\n  // For functions: use the ref (stable); for arrays: deep-memoize\n  const allowedOptions = useDeepMemo(allowedOptionsOriginal);\n  // selectedValues is always an array, deep-memoize for stable reference\n  const selectedValues = useDeepMemo(selectedValuesOriginal);\n\n  const updateCachedOptions = useCallback(\n    /** @param {Option[]} update */\n    (update) => {\n      let hasChanged = false;\n      for (const item of update) {\n        if (\n          !cachedOptions.current[item.value] ||\n          !isEqual(cachedOptions.current[item.value], item)\n        ) {\n          hasChanged = true;\n          cachedOptions.current[item.value] = item;\n        }\n      }\n      if (hasChanged) {\n        setCacheVersion((v) => v + 1);\n      }\n    },\n    [],\n  );\n\n  // useExhaustiveDependencies rule: cacheVersion is reliable way to figure out of cache changed\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  const resolvedOptionsLookup = useMemo(() => {\n    if (Array.isArray(allowedOptions)) {\n      return allowedOptions.reduce(\n        (acc, o) => {\n          acc[o.value] = o;\n          return acc;\n        },\n        /** @type {{ [value: string]: Option }} */ ({}),\n      );\n    }\n    return { ...cachedOptions.current };\n  }, [allowedOptions, cacheVersion]);\n\n  // useExhaustiveDependencies rule: cacheVersion is reliable way to figure out of cache changed\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  const unresolvedValues = useMemo(\n    () => selectedValues.filter((v) => !resolvedOptionsLookup[v]),\n    [selectedValues, cacheVersion],\n  );\n\n  // useExhaustiveDependencies rule is wrong here. fetch() should only be called\n  // if there is a selected value with unknown label. Especially assume selected\n  // values shows up in the parent combobox's text field, and that's why we need\n  // to find the label for them.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  useEffect(() => {\n    if (!isFunction) return;\n    if (unresolvedValues.length === 0) return;\n\n    const fetchOptions = /**\n     * @type {(\n     *  queryOrValues: string[]\n     *  | string, limit: number, currentSelections: string[], signal: AbortSignal\n     * ) => Promise<Option[]>}\n     */ (allowedOptions);\n    const currentSelectedValues = selectedValues;\n    const abortController = new AbortController();\n\n    fetchOptions(\n      unresolvedValues,\n      unresolvedValues.length,\n      currentSelectedValues,\n      abortController.signal,\n    )\n      .then((results) => {\n        if (abortController.signal.aborted) return;\n        if (results?.length) {\n          updateCachedOptions(results);\n        }\n        const stillUnresolved = unresolvedValues.filter(\n          (v) => !results?.find((r) => r.value === v),\n        );\n        if (stillUnresolved.length > 0) {\n          updateCachedOptions(stillUnresolved.map((v) => ({ label: v, value: v })));\n        }\n      })\n      .catch((error) => {\n        if (abortController.signal.aborted) return;\n        console.error(\"Failed to resolve option labels:\", error);\n        updateCachedOptions(unresolvedValues.map((v) => ({ label: v, value: v })));\n      });\n\n    return () => abortController.abort();\n  }, [\n    // effect should only run when there is selected values with unknown labels\n    unresolvedValues.length > 0, // selectValues doesn't need to be a dependency\n    // this effect only applies to remote fetches, i.e. only when allowedOptions is a function.\n    isFunction ? allowedOptions : null,\n    updateCachedOptions,\n  ]);\n\n  // About useExhaustiveDependencies: selectedValues doesn't need to be dependency\n  // as explained in the useEffect above. Furthermore you don't want to be\n  // re-ordering the dropdown list when user is selecting things. Re-ordering can\n  // be done the next time user opens up the dropdown.\n  //\n  // resolvedOptionsLookup doesn't need to be dependency because when allowedOptions is:\n  // 1. array: then it is computed correctly and immediately. It's already tied\n  // to allowedOptions, which is already a dependency.\n  // 2. function: then resolvedOptionsLookup is not evn used and cachedOption.current\n  // is used instead.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  useEffect(() => {\n    abortControllerRef.current?.abort();\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = null;\n    }\n\n    if (!isOpen) {\n      setFilteredOptions([]);\n      setIsLoading(false);\n      wasOpenRef.current = false;\n      return;\n    }\n\n    // Track if this is the first time dropdown opened (to skip debounce)\n    const isFirstOpen = !wasOpenRef.current;\n    wasOpenRef.current = true;\n\n    if (isFunction) {\n      const fetchFn =\n        /** @type {(queryOrValues: string[] | string, limit: number, currentSelections: string[], signal: AbortSignal) => Promise<Option[]>} */ (\n          allowedOptions\n        );\n      const currentSelectedValues = selectedValues;\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      // Lower debounce time for playwright to speed up tests\n      let debounceTime = isPlaywright ? 5 : 250;\n      // Skip debounce on first open\n      if (isFirstOpen) debounceTime = 0;\n\n      setIsLoading(true);\n\n      const fetchOptions = async () => {\n        try {\n          const results = await fetchFn(\n            searchTextTrimmed,\n            maxNumberOfPresentedOptions,\n            currentSelectedValues,\n            abortController.signal,\n          );\n\n          if (abortController.signal.aborted) return;\n\n          if (results?.length) {\n            updateCachedOptions(results);\n          }\n\n          let updatedOptions = results || [];\n          if (!searchTextTrimmed) {\n            const unreturnedSelectedValues = currentSelectedValues\n              .filter((v) => !results?.find((r) => r.value === v))\n              .filter((v) => !cachedOptions.current[v])\n              .map((v) => ({ label: v, value: v }));\n            if (unreturnedSelectedValues.length > 0) {\n              updateCachedOptions(unreturnedSelectedValues);\n              updatedOptions = unreturnedSelectedValues.concat(results || []);\n            }\n          }\n\n          const options = searchTextTrimmed\n            ? updatedOptions\n            : sortValuesToTop(updatedOptions, currentSelectedValues);\n\n          setFilteredOptions(getMatchScore(searchTextTrimmed, options, language, false));\n          setIsLoading(false);\n        } catch (error) {\n          if (abortController.signal.aborted) return;\n          setIsLoading(false);\n          throw error;\n        }\n      };\n\n      if (debounceTime > 0) {\n        debounceTimerRef.current = setTimeout(fetchOptions, debounceTime);\n      } else {\n        fetchOptions();\n      }\n\n      return () => {\n        abortController.abort();\n        if (debounceTimerRef.current) {\n          clearTimeout(debounceTimerRef.current);\n        }\n      };\n      // biome-ignore lint/style/noUselessElse: I want it that way!\n    } else {\n      // Array-based options: filter locally\n      const arrayOptions = /** @type {Option[]} */ (allowedOptions);\n      const currentSelectedValues = selectedValues;\n      const mergedOptions = currentSelectedValues\n        .filter((v) => !resolvedOptionsLookup[v])\n        .map((v) => ({ label: v, value: v }))\n        .concat(arrayOptions);\n\n      const options = searchText\n        ? mergedOptions\n        : sortValuesToTop(mergedOptions, currentSelectedValues);\n\n      setFilteredOptions(getMatchScore(searchText, options, language, true));\n    }\n  }, [\n    isOpen,\n    searchTextTrimmed,\n    searchText,\n    language,\n    unresolvedValues.length > 0, // selectValues doesn't need to be a dependency as explained above\n    isFunction,\n    allowedOptions,\n    // resolvedOptionsLookup doesn't need to be dependency as explained above\n    maxNumberOfPresentedOptions,\n    updateCachedOptions,\n  ]);\n\n  return {\n    filteredOptions,\n    resolvedOptionsLookup,\n    isLoading,\n  };\n}\n", "/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/** @type {Record<string, LanguageCache>} */\nconst languageCache = {};\n\n/**\n * Converts any text into a valid HTML ID attribute value.\n * Returns empty string if text becomes empty after removing invalid characters.\n *\n * @param {string} text - The text to convert into an HTML ID\n * @returns {string} A valid HTML ID or empty string\n */\nexport function toHTMLId(text) {\n  // Remove any characters that are not letters, numbers, hyphens, underscores, colons, or periods\n  return text.replace(/[^a-zA-Z0-9\\-_:.]/g, \"\");\n}\n\n/**\n * @template {OptionMatch|Option} T\n * @param {T[]} options\n * @param {string[]} values\n * @returns {T[]}\n */\nexport function sortValuesToTop(options, values) {\n  const selectedSet = new Set(values);\n  return options.sort((a, b) => {\n    const aSelected = selectedSet.has(a.value);\n    const bSelected = selectedSet.has(b.value);\n    if (aSelected === bSelected) return 0;\n    return aSelected ? -1 : 1;\n  });\n}\n\n/**\n * @param {string} query\n * @param {Option} option\n * @param {string} language\n * @returns {OptionMatch|null}\n */\nfunction getExactMatchScore(query, option, language) {\n  const { label, value, ...rest } = option;\n  if (value === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (label === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  const { caseMatcher } = /** @type {LanguageCache} */ (languageCache[language]);\n  if (caseMatcher.compare(value, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (caseMatcher.compare(label, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  return null;\n}\n\n/**\n * Calculates the match score between a query text and a list of option labels.\n * It returns scores for each option sorted in descending order.\n *\n * It takes the `query` string, evaluates the following rules in order and assigns the one with highest score:\n * - Score 7: If whole query matches a label on an option (Case insensitive match)\n * - Score 5: Same as previous check but this time case and accent insensitive matching\n * - Score 3: Phrase matching (e.g. \"word1 partialWord2*\")\n * - Score 0-1: Number of words matched / total number of words in query (e.g. \"word1\")\n *\n * @param {string} query - The query text to match against options.\n * @param {Option[]} options\n * @param {string} [language='en'] Language to use for word splitting and matching\n * @param {boolean} [filterAndSort=true] Whether to filter and sort the results. If false, returns all options but with attempted matches.\n * @returns {Array<OptionMatch>}\n */\nexport function getMatchScore(query, options, language = \"en\", filterAndSort = true) {\n  // biome-ignore lint/style/noParameterAssign: ignore\n  query = query.trim();\n\n  if (!query) {\n    const matchSlices = /** @type {Array<[number, number]>} */ ([]);\n    return options.map((option) => ({\n      ...option,\n      label: option.label,\n      value: option.value,\n      score: 0,\n      matched: \"none\",\n      matchSlices,\n    }));\n  }\n\n  if (!languageCache[language]) {\n    languageCache[language] = {\n      baseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"base\",\n      }),\n      caseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"accent\",\n      }),\n      wordSegmenter: new Intl.Segmenter(language, {\n        granularity: \"word\",\n      }),\n    };\n  }\n  const { baseMatcher, caseMatcher, wordSegmenter } = languageCache[language];\n\n  const isCommaSeparated = query.includes(\",\");\n\n  let matches = options.map((option) => {\n    const { label, value, ...rest } = option;\n    if (isCommaSeparated) {\n      const querySegments = query.split(\",\");\n      const matches = querySegments\n        .map((querySegment) => getExactMatchScore(querySegment.trim(), option, language))\n        .filter((match) => match !== null)\n        .sort((a, b) => b.score - a.score);\n      return /** @type {OptionMatch} */ (\n        matches[0] || {\n          ...rest,\n          label,\n          value,\n          score: 0,\n          matched: \"none\",\n        }\n      );\n    }\n\n    // Rule 1: Exact match (case sensitive)\n    // Rule 2: Exact match (case insensitive)\n    const exactMatch = getExactMatchScore(query, option, language);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Rule 3: Exact match with accents normalized (case insensitive)\n    if (baseMatcher.compare(label, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'label'} */\n        matched: \"label\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, label.length]],\n      };\n    }\n    if (baseMatcher.compare(value, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, value.length]],\n      };\n    }\n\n    // Rule 4: Phrase match (imagine a wildcard query like \"word1 partialWord2*\")\n    // This match needs to be case and accent insensitive\n    const querySegments = Array.from(wordSegmenter.segment(query));\n    const labelWordSegments = Array.from(wordSegmenter.segment(label.trim()));\n    let len = 0;\n    let firstIndex = -1;\n    for (let i = 0; i < labelWordSegments.length; i++) {\n      const labelWordSegment = /** @type {Intl.SegmentData} */ (labelWordSegments[i]);\n      const querySegment = querySegments[len];\n      if (!querySegment) break;\n      if (len === querySegments.length - 1) {\n        // check for partial word match\n        // I can't use labelWordSegment.segment.startsWith(querySegment.segment) because it's case and accent sensitive\n        const lastQueryWord = querySegment.segment;\n        if (\n          baseMatcher.compare(\n            labelWordSegment.segment.slice(0, lastQueryWord.length),\n            lastQueryWord,\n          ) === 0\n        ) {\n          return {\n            ...rest,\n            label,\n            value,\n            score: 3,\n            /** @type {'label'} */\n            matched: \"label\",\n            /** @type {Array<[number, number]>} */\n            // @ts-ignore\n            matchSlices: [\n              [\n                firstIndex > -1 ? firstIndex : labelWordSegment.index,\n                labelWordSegment.index + lastQueryWord.length,\n              ],\n            ],\n          };\n        }\n      } else if (baseMatcher.compare(labelWordSegment.segment, querySegment.segment) === 0) {\n        len++;\n        if (len === 1) {\n          firstIndex = labelWordSegment.index;\n        }\n        continue;\n      }\n      len = 0;\n      firstIndex = -1;\n    }\n    // Also check for partial value match (this doesn't need accent check)\n    if (caseMatcher.compare(value.slice(0, query.length), query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 3,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, query.length]],\n      };\n    }\n\n    // Rule 5: Word matches\n    const queryWords = querySegments.filter((s) => s.isWordLike);\n    const labelWords = labelWordSegments.filter((s) => s.isWordLike);\n    /** @type {Array<[number, number]|undefined>} */\n    const slices = queryWords.map((word) => {\n      const match = labelWords.find(\n        (labelWord) => baseMatcher.compare(labelWord.segment, word.segment) === 0,\n      );\n      if (match) {\n        return [match.index, match.index + match.segment.length];\n      }\n    });\n    // TODO: Do we need a deep equal de-duplication here?\n    const matchSlices = slices.filter((s) => s !== undefined).sort((a, b) => a[0] - b[0]);\n    const wordScoring = matchSlices.length / queryWords.length;\n    return {\n      ...rest,\n      label,\n      value,\n      score: wordScoring,\n      /** @type {'label'|'none'} */\n      matched: wordScoring ? \"label\" : \"none\",\n      matchSlices,\n    };\n  });\n\n  if (filterAndSort) {\n    matches = matches.filter((match) => match.score > 0);\n    matches.sort((a, b) => {\n      if (a.score === b.score) {\n        const val = a.label.localeCompare(b.label, undefined, {\n          sensitivity: \"base\",\n        });\n        return val === 0 ? a.value.localeCompare(b.value, undefined, { sensitivity: \"base\" }) : val;\n      }\n      return b.score - a.score;\n    });\n  }\n  return matches;\n}\n\n/**\n * @param {OptionMatch['matchSlices']} matchSlices\n * @param {string} text\n * @returns {VNode[]}\n */\nexport function matchSlicesToNodes(matchSlices, text) {\n  const nodes = /** @type {VNode[]} */ ([]);\n  let index = 0;\n  matchSlices.map((slice) => {\n    const [start, end] = slice;\n    if (index < start) {\n      nodes.push(<span key={`${index}-${start}`}>{text.slice(index, start)}</span>);\n    }\n    nodes.push(<u key={`${start}-${end}`}>{text.slice(start, end)}</u>);\n    index = end;\n  });\n  if (index < text.length) {\n    nodes.push(<span key={`${index}-${text.length}`}>{text.slice(index)}</span>);\n  }\n  return nodes;\n}\n"],
  "mappings": ";AAAA,SAAS,eAAAA,cAAa,aAAAC,YAAW,UAAAC,SAAQ,YAAAC,iBAAgB;;;ACAzD,SAAS,aAAa,WAAW,SAAS,QAAQ,gBAAgB;;;ACmUjD;;;ADpLjB,IAAM,gBACJ,OAAO,WAAW,eAAe,OAAO,aAAa,mBAAmB,GAAG;AAE7E,IAAM,8BAA8B,OAAO,gBAAgB,UAAU;AAS9D,SAAS,2BAA2B,EAAE,iBAAiB,eAAe,GAAG;AAC9E,MAAI,CAAC,iBAAiB,OAAO,WAAW,eAAe,CAAC,OAAO,eAAgB,QAAO;AAEtF,MAAI,YAAY;AAChB,QAAM,uBAAuB,MAAM;AACjC,QAAI,CAAC,OAAO,eAAgB;AAC5B,UAAM,aAAa,8BAA8B,OAAO,eAAe;AACvE,UAAM,eAAe,aAAa;AAClC,QAAI,cAAc,cAAc;AAC9B,kBAAY;AACZ,wBAAkB,SAAS;AAAA,IAC7B;AACA,qBAAiB,YAAY,SAAS;AAAA,EACxC;AACA,SAAO,eAAe,iBAAiB,UAAU,sBAAsB,EAAE,SAAS,KAAK,CAAC;AACxF,SAAO,MAAM;AACX,WAAO,gBAAgB,oBAAoB,UAAU,oBAAoB;AAAA,EAC3E;AACF;AAyBA,IAAM,eAAe,OAAO,cAAc,eAAe,UAAU,cAAc;;;AD3BzE,SAEI,OAAAC,MAFJ;AAnJR,IAAM,iBAAiB,CAAC;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAEJ,QAAM,CAAC,gBAAgB,iBAAiB,IAAIC,UAAS,EAAE;AACvD,QAAM,CAAC,uBAAuB,wBAAwB,IAAIA,UAAS,CAAC;AACpE,QAAM,eAAeC;AAAA;AAAA,IAA+C;AAAA,EAAK;AACzE,QAAM,eAAeA;AAAA;AAAA,IAA6C;AAAA,EAAK;AACvE,QAAM,sBAAsBA,QAAO,EAAE;AACrC,QAAM,0CAA0CA;AAAA;AAAA,IAAuC;AAAA,EAAK;AAC5F,QAAM,qCAAqCA,QAAO,KAAK;AACvD,QAAM,0BAA0BA;AAAA;AAAA,IACuB;AAAA,EACvD;AAGA,QAAM,wBAAwBC;AAAA;AAAA;AAAA;AAAA,IAI5B,CAAC,MAAM;AACL,YAAM,QAAQ,EAAE,cAAc;AAC9B,wBAAkB,KAAK;AACvB,oBAAc,KAAK;AAAA,IACrB;AAAA,IACA,CAAC,aAAa;AAAA,EAChB;AAEA,QAAM,mCAAmCA,aAAY,MAAM;AACzD,UAAM,QAAQ,aAAa;AAC3B,QAAI,CAAC,MAAO;AACZ,UAAM,gCACJ,mCAAmC,YAAY,QAAQ,SAAS,kBAAkB;AACpF,QAAI,CAAC,8BAA+B;AACpC,UAAM,aAAa,YAAY,UAAU;AACzC,QAAI,wBAAwB,SAAS;AACnC,mBAAa,wBAAwB,OAAO;AAAA,IAC9C;AACA,4BAAwB,UAAU,WAAW,MAAM;AACjD,YAAM,gBAAgB,UAAU;AAChC,8BAAwB,UAAU;AAAA,IACpC,GAAG,EAAE;AAAA,EACP,GAAG,CAAC,CAAC;AAGL,QAAM,cAAcA,aAAY,MAAM;AACpC,sBAAkB,EAAE;AACpB,6BAAyB,CAAC;AAC1B,uCAAmC,UAAU;AAC7C,4CAAwC,UAAU;AAClD,4CAAwC,UAAU;AAClD,QAAI,wBAAwB,SAAS;AACnC,mBAAa,wBAAwB,OAAO;AAC5C,8BAAwB,UAAU;AAAA,IACpC;AACA,iBAAa,SAAS,gBAAgB,UAAU;AAGhD,UAAM;AAAA;AAAA,MACJ,SAAS,oBAAoB,SAAS;AAAA;AAExC,qBAAiB,MAAM,WAAW,oBAAoB;AAEtD,YAAQ;AAAA,EACV,GAAG,CAAC,OAAO,CAAC;AAGZ,EAAAC,WAAU,MAAM;AACd,QAAI,QAAQ;AAEV,YAAM;AAAA;AAAA,QACJ,SAAS,oBAAoB,SAAS;AAAA;AAIxC,0BAAoB,UAAU,iBAAiB,MAAM;AACrD,uBAAiB,MAAM,WAAW;AAGlC,UAAI,CAAC,wCAAwC,SAAS;AACpD,gDAAwC,UAAU,2BAA2B;AAAA,UAC3E,eAAe,gBAAgB,WAAW;AACxC,qCAAyB,YAAY,iBAAiB,CAAC;AACvD,+CAAmC,UAAU,CAAC;AAAA,UAChD;AAAA,QACF,CAAC;AAAA,MACH;AAGA,mBAAa,SAAS,MAAM;AAAA,IAC9B;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAGX,EAAAA,WAAU,MAAM;AACd,WAAO,MAAM;AACX,UAAI,wCAAwC,SAAS;AACnD,gDAAwC,QAAQ;AAChD,gDAAwC,UAAU;AAAA,MACpD;AACA,UAAI,wBAAwB,SAAS;AACnC,qBAAa,wBAAwB,OAAO;AAC5C,gCAAwB,UAAU;AAAA,MACpC;AACA,mBAAa,SAAS,gBAAgB,UAAU;AAChD,yCAAmC,UAAU;AAAA,IAC/C;AAAA,EACF,GAAG,CAAC,CAAC;AAIL,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAEA;AAAA;AAAA;AAAA,IAGE,gBAAAJ;AAAA,MAAC;AAAA;AAAA,QACC,KAAK;AAAA,QACL,WAAW,wBAAwB,mBAAmB,KAAK,EAAE;AAAA,QAC7D,OAAO,EAAE,SAAS,SAAS,OAAO,OAAO;AAAA,QACzC,SAAS,CAAC,MAAM;AAEd,cAAI,EAAE,WAAW,aAAa,SAAS;AACrC,wBAAY;AAAA,UACd;AAAA,QACF;AAAA,QACA,WAAW,CAAC,MAAM;AAChB,cAAI,EAAE,QAAQ,UAAU;AACtB,wBAAY;AAAA,UACd;AAAA,QACF;AAAA,QAEA,MAAK;AAAA,QACL,cAAW;AAAA,QACX,mBAAiB,YAAY,GAAG,EAAE,gBAAgB;AAAA,QAClD,UAAU;AAAA,QAEV,+BAAC,SAAI,WAAW,uBAAuB,mBAAmB,KAAK,EAAE,IAC/D;AAAA,+BAAC,SAAI,WAAU,6BACZ;AAAA,yBACC,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,IAAI,GAAG,EAAE;AAAA,gBACT,WAAU;AAAA,gBACV,SAAS,GAAG,EAAE;AAAA,gBAEb;AAAA;AAAA,YACH;AAAA,YAEF,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,IAAI,GAAG,EAAE;AAAA,gBACT,KAAK;AAAA,gBACL,MAAK;AAAA,gBACL,OAAO;AAAA,gBACP,aAAa,aAAa;AAAA,gBAC1B,UAAU;AAAA,gBACV,WAAW,CAAC,MAAM;AAChB,sBAAI,EAAE,QAAQ,UAAU;AACtB,gCAAY;AAAA,kBACd;AAAA,gBACF;AAAA,gBACA,WAAW,4BAA4B,CAAC,YAAY,sCAAsC,EAAE;AAAA,gBAC5F,MAAK;AAAA,gBACL,iBAAc;AAAA,gBACd,iBAAc;AAAA,gBACd,iBAAe,GAAG,EAAE;AAAA,gBACpB,cAAY,aAAa,aAAa;AAAA,gBACtC,cAAa;AAAA;AAAA,YACf;AAAA,aACF;AAAA,UACA,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,oBAAoB;AAAA,cACpB,qBAAqB;AAAA,cAEpB;AAAA;AAAA,UACH;AAAA,UACC,wBAAwB,KACvB,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,WAAU;AAAA,cACV,OAAO,EAAE,QAAQ,GAAG,qBAAqB,KAAK;AAAA,cAC9C,eAAY;AAAA;AAAA,UACd;AAAA,WAEJ;AAAA;AAAA,IACF;AAAA;AAEJ;AAEA,IAAO,yBAAQ;",
  "names": ["useCallback", "useEffect", "useRef", "useState", "jsx", "useState", "useRef", "useCallback", "useEffect"]
}
