{
  "version": 3,
  "sources": ["../../lib/utils.jsx"],
  "sourcesContent": ["/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/** @type {Record<string, LanguageCache>} */\nconst languageCache = {};\n\n/**\n * Converts any text into a valid HTML ID attribute value.\n * Returns empty string if text becomes empty after removing invalid characters.\n *\n * @param {string} text - The text to convert into an HTML ID\n * @returns {string} A valid HTML ID or empty string\n */\nexport function toHTMLId(text) {\n  // Remove any characters that are not letters, numbers, hyphens, underscores, colons, or periods\n  return text.replace(/[^a-zA-Z0-9\\-_:.]/g, \"\");\n}\n\n/**\n * @template {OptionMatch|Option} T\n * @param {T[]} options\n * @param {string[]} values\n * @returns {T[]}\n */\nexport function sortValuesToTop(options, values) {\n  const selectedSet = new Set(values);\n  return options.sort((a, b) => {\n    const aSelected = selectedSet.has(a.value);\n    const bSelected = selectedSet.has(b.value);\n    if (aSelected === bSelected) return 0;\n    return aSelected ? -1 : 1;\n  });\n}\n\n/**\n * @param {string} query\n * @param {Option} option\n * @param {string} language\n * @returns {OptionMatch|null}\n */\nfunction getExactMatchScore(query, option, language) {\n  const { label, value, ...rest } = option;\n  if (value === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (label === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  const { caseMatcher } = /** @type {LanguageCache} */ (languageCache[language]);\n  if (caseMatcher.compare(value, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (caseMatcher.compare(label, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  return null;\n}\n\n/**\n * Calculates the match score between a query text and a list of option labels.\n * It returns scores for each option sorted in descending order.\n *\n * It takes the `query` string, evaluates the following rules in order and assigns the one with highest score:\n * - Score 7: If whole query matches a label on an option (Case insensitive match)\n * - Score 5: Same as previous check but this time case and accent insensitive matching\n * - Score 3: Phrase matching (e.g. \"word1 partialWord2*\")\n * - Score 0-1: Number of words matched / total number of words in query (e.g. \"word1\")\n *\n * @param {string} query - The query text to match against options.\n * @param {Option[]} options\n * @param {string} [language='en'] Language to use for word splitting and matching\n * @param {boolean} [filterAndSort=true] Whether to filter and sort the results. If false, returns all options but with attempted matches.\n * @returns {Array<OptionMatch>}\n */\nexport function getMatchScore(query, options, language = \"en\", filterAndSort = true) {\n  // biome-ignore lint/style/noParameterAssign: ignore\n  query = query.trim();\n\n  if (!query) {\n    const matchSlices = /** @type {Array<[number, number]>} */ ([]);\n    return options.map((option) => ({\n      ...option,\n      label: option.label,\n      value: option.value,\n      score: 0,\n      matched: \"none\",\n      matchSlices,\n    }));\n  }\n\n  if (!languageCache[language]) {\n    languageCache[language] = {\n      baseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"base\",\n      }),\n      caseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"accent\",\n      }),\n      wordSegmenter: new Intl.Segmenter(language, {\n        granularity: \"word\",\n      }),\n    };\n  }\n  const { baseMatcher, caseMatcher, wordSegmenter } = languageCache[language];\n\n  const isCommaSeparated = query.includes(\",\");\n\n  let matches = options.map((option) => {\n    const { label, value, ...rest } = option;\n    if (isCommaSeparated) {\n      const querySegments = query.split(\",\");\n      const matches = querySegments\n        .map((querySegment) => getExactMatchScore(querySegment.trim(), option, language))\n        .filter((match) => match !== null)\n        .sort((a, b) => b.score - a.score);\n      return /** @type {OptionMatch} */ (\n        matches[0] || {\n          ...rest,\n          label,\n          value,\n          score: 0,\n          matched: \"none\",\n        }\n      );\n    }\n\n    // Rule 1: Exact match (case sensitive)\n    // Rule 2: Exact match (case insensitive)\n    const exactMatch = getExactMatchScore(query, option, language);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Rule 3: Exact match with accents normalized (case insensitive)\n    if (baseMatcher.compare(label, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'label'} */\n        matched: \"label\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, label.length]],\n      };\n    }\n    if (baseMatcher.compare(value, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, value.length]],\n      };\n    }\n\n    // Rule 4: Phrase match (imagine a wildcard query like \"word1 partialWord2*\")\n    // This match needs to be case and accent insensitive\n    const querySegments = Array.from(wordSegmenter.segment(query));\n    const labelWordSegments = Array.from(wordSegmenter.segment(label.trim()));\n    let len = 0;\n    let firstIndex = -1;\n    for (let i = 0; i < labelWordSegments.length; i++) {\n      const labelWordSegment = /** @type {Intl.SegmentData} */ (labelWordSegments[i]);\n      const querySegment = querySegments[len];\n      if (!querySegment) break;\n      if (len === querySegments.length - 1) {\n        // check for partial word match\n        // I can't use labelWordSegment.segment.startsWith(querySegment.segment) because it's case and accent sensitive\n        const lastQueryWord = querySegment.segment;\n        if (\n          baseMatcher.compare(\n            labelWordSegment.segment.slice(0, lastQueryWord.length),\n            lastQueryWord,\n          ) === 0\n        ) {\n          return {\n            ...rest,\n            label,\n            value,\n            score: 3,\n            /** @type {'label'} */\n            matched: \"label\",\n            /** @type {Array<[number, number]>} */\n            // @ts-ignore\n            matchSlices: [\n              [\n                firstIndex > -1 ? firstIndex : labelWordSegment.index,\n                labelWordSegment.index + lastQueryWord.length,\n              ],\n            ],\n          };\n        }\n      } else if (baseMatcher.compare(labelWordSegment.segment, querySegment.segment) === 0) {\n        len++;\n        if (len === 1) {\n          firstIndex = labelWordSegment.index;\n        }\n        continue;\n      }\n      len = 0;\n      firstIndex = -1;\n    }\n    // Also check for partial value match (this doesn't need accent check)\n    if (caseMatcher.compare(value.slice(0, query.length), query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 3,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, query.length]],\n      };\n    }\n\n    // Rule 5: Word matches\n    const queryWords = querySegments.filter((s) => s.isWordLike);\n    const labelWords = labelWordSegments.filter((s) => s.isWordLike);\n    /** @type {Array<[number, number]|undefined>} */\n    const slices = queryWords.map((word) => {\n      const match = labelWords.find(\n        (labelWord) => baseMatcher.compare(labelWord.segment, word.segment) === 0,\n      );\n      if (match) {\n        return [match.index, match.index + match.segment.length];\n      }\n    });\n    // TODO: Do we need a deep equal de-duplication here?\n    const matchSlices = slices.filter((s) => s !== undefined).sort((a, b) => a[0] - b[0]);\n    const wordScoring = matchSlices.length / queryWords.length;\n    return {\n      ...rest,\n      label,\n      value,\n      score: wordScoring,\n      /** @type {'label'|'none'} */\n      matched: wordScoring ? \"label\" : \"none\",\n      matchSlices,\n    };\n  });\n\n  if (filterAndSort) {\n    matches = matches.filter((match) => match.score > 0);\n    matches.sort((a, b) => {\n      if (a.score === b.score) {\n        const val = a.label.localeCompare(b.label, undefined, {\n          sensitivity: \"base\",\n        });\n        return val === 0 ? a.value.localeCompare(b.value, undefined, { sensitivity: \"base\" }) : val;\n      }\n      return b.score - a.score;\n    });\n  }\n  return matches;\n}\n\n/**\n * @param {OptionMatch['matchSlices']} matchSlices\n * @param {string} text\n * @returns {VNode[]}\n */\nexport function matchSlicesToNodes(matchSlices, text) {\n  const nodes = /** @type {VNode[]} */ ([]);\n  let index = 0;\n  matchSlices.map((slice) => {\n    const [start, end] = slice;\n    if (index < start) {\n      nodes.push(<span key={`${index}-${start}`}>{text.slice(index, start)}</span>);\n    }\n    nodes.push(<u key={`${start}-${end}`}>{text.slice(start, end)}</u>);\n    index = end;\n  });\n  if (index < text.length) {\n    nodes.push(<span key={`${index}-${text.length}`}>{text.slice(index)}</span>);\n  }\n  return nodes;\n}\n"],
  "mappings": "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",
  "names": ["querySegments", "matches"]
}
