{
  "version": 3,
  "sources": ["../../lib/PreactCombobox.jsx", "../../lib/OptionsListbox.jsx", "../../lib/utils.jsx", "../../lib/TraySearchList.jsx", "../../lib/hooks.js"],
  "sourcesContent": ["import { createPopper } from \"@popperjs/core\";\nimport { createPortal } from \"preact/compat\";\nimport {\n  useCallback,\n  useEffect,\n  useId,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"preact/hooks\";\nimport OptionsListbox from \"./OptionsListbox.jsx\";\nimport TraySearchList from \"./TraySearchList.jsx\";\nimport { subscribeToVirtualKeyboard, useAsyncOptions, useDeepMemo, useLive } from \"./hooks.js\";\nimport { matchSlicesToNodes, toHTMLId } from \"./utils.jsx\";\nimport \"./PreactCombobox.css\";\n\n// --- types ---\n/**\n * @typedef {Object} Option\n * @property {string} label - The display text for the option\n * @property {string} value - The value of the option\n * @property {VNode | string} [icon] - Optional icon element or URL to display before the label\n * @property {boolean} [disabled] - Whether the option is disabled and cannot be selected\n * @property {boolean} [divider] - Whether to show a divider line below this option (only when search is empty)\n */\n\n/**\n * @typedef {Object} OptionMatch\n * @property {string} label - The display text for the option\n * @property {string} value - The value of the option\n * @property {VNode|string} [icon] - Optional icon element or URL to display before the label\n * @property {boolean} [disabled] - Whether the option is disabled and cannot be selected\n * @property {boolean} [divider] - Whether to show a divider line below this option (only when search is empty)\n * @property {number} score - The match score\n * @property {'value' | 'label' | 'none'} matched - The match type\n * @property {Array<[number, number]>} matchSlices - The match slices\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/**\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @callback OptionTransformFunction\n * @param {Object} params\n * @param {OptionMatch} params.option\n * @param {string} params.language\n * @param {boolean} params.isSelected\n * @param {boolean} params.isInvalid\n * @param {boolean} params.isActive Active does not mean selected. Active means the option is being hovered over / keyboard focused over.\n * @param {boolean} params.showValue\n * @param {VNode} [params.warningIcon]\n * @param {VNode} [params.tickIcon]\n * @param {(option: Option, isInput?: boolean) => VNode|null} [params.optionIconRenderer] Read PreactComboboxProps\n * `optionIconRenderer` for more details.\n * @returns {VNode}\n */\n\n/**\n * @typedef {Object} Translations\n * @property {string} searchPlaceholder - Placeholder text for search input\n * @property {string} noOptionsFound - Text shown when no options match the search\n * @property {string} loadingOptions - Text shown when options are loading\n * @property {string} loadingOptionsAnnouncement - Announcement when options are loading (screen reader)\n * @property {string} optionsLoadedAnnouncement - Announcement when options finish loading (screen reader)\n * @property {string} noOptionsFoundAnnouncement - Announcement when no options found (screen reader)\n * @property {string} addOption - Text for adding a new option (includes {value} placeholder)\n * @property {string} typeToLoadMore - Text shown when more options can be loaded\n * @property {string} clearValue - Aria label for clear button\n * @property {string} selectedOption - Screen reader text for selected options\n * @property {string} invalidOption - Screen reader text for invalid options\n * @property {string} invalidValues - Header text for invalid values tooltip\n * @property {string} fieldContainsInvalidValues - Announcement for invalid values (screen reader)\n * @property {string} noOptionsSelected - Announcement when no options are selected\n * @property {string} selectionAdded - Announcement prefix when selection is added\n * @property {string} selectionRemoved - Announcement prefix when selection is removed\n * @property {string} selectionsCurrent - Announcement prefix for current selections\n * @property {string} selectionsMore - Text for additional options (singular)\n * @property {string} selectionsMorePlural - Text for additional options (plural)\n * @property {(count: number, language: string) => string} selectedCountFormatter - Function to format the count in the badge\n */\n\n/**\n * @typedef {Object} PreactComboboxProps\n * @property {string} id The id of the component\n * @property {boolean} [multiple=true] Multi-select or single-select mode\n * @property {Option[]\n * | ((\n *   queryOrValues: string[] | string,\n *   limit: number,\n *   currentSelections: string[],\n *   abortControllerSignal: AbortSignal\n * ) => Promise<Option[]>)} allowedOptions Array of allowed options or function to fetch allowed options\n * @property {boolean} [allowFreeText=false] Allow free text input\n * @property {(options: string[] | string) => void} onChange Callback when selection changes\n * @property {string[] | string} value Currently selected options (array for multi-select, string for single-select)\n * @property {string} [language='en'] BCP 47 language code for word splitting and matching. The language can be any language tag\n * recognized by Intl.Segmenter and Intl.Collator\n * @property {boolean} [showValue=false] experimental feature.\n * @property {boolean} [disabled=false] Disable the component\n * @property {boolean} [required=false] Is required for form submission\n * @property {boolean} [showClearButton=true] Show the clear button for single-select mode\n * @property {string} [name] name to be set on hidden select element\n * @property {string} [className] Additional class names for the component\n * @property {string} [placeholder] Input placeholder text shown when no selections are made\n * @property {'light' | 'dark' | 'system'} [theme='system'] Theme to use - 'light', 'dark', or 'system' (follows data-theme attribute)\n * @property {boolean | 'auto'} [tray=false] Enable mobile tray mode - true/false or 'auto' for media query detection\n * @property {string} [trayBreakpoint='768px'] CSS breakpoint for auto tray mode (e.g., '768px', '50rem')\n * @property {string} [trayLabel] Label text for the tray header (auto-detects from associated label if not provided)\n * @property {Translations} [translations] Custom translation strings\n *\n * @property {Record<string, any>} [rootElementProps] Root element props\n * @property {Record<string, any>} [inputProps] Input element props\n * @property {boolean} [formSubmitCompatible=false] Render a hidden select for progressive enhanced compatible form submission\n * @property {boolean} [isServer] Whether the component is rendered on the server (auto-detected if not provided).\n * This prop is only relevant if formSubmitCompatible is true.\n * @property {Record<string, any>} [selectElementProps] Props for the hidden select element. This is useful for forms\n *\n * @property {HTMLElement} [portal=document.body] The element to render the Dropdown <ul> element\n * @property {OptionTransformFunction} [optionRenderer=identity] Transform the label text\n * @property {(option: Option, isInput?: boolean) => VNode|null} [optionIconRenderer] Custom icon renderer for options.\n * isInput is `true` when rendering the icon besides the input element in single-select mode.\n * It's `undefined` or `false` when rendering the icon besides each option.\n * This function is also passed into `optionRenderer` as an argument instead of being used directly for option rendering.\n * @property {VNode} [warningIcon] Custom warning icon element or component\n * @property {VNode} [tickIcon] Custom tick icon element or component for selected options\n * @property {VNode} [chevronIcon] Custom chevron icon element or component\n * @property {(text: string) => VNode|string} [loadingRenderer] Custom loading indicator element or text\n *\n * @property {number} [maxNumberOfPresentedOptions=100] - [private property - do not use] Maximum number of options to present\n */\n\n// --- end of types ---\n\n/** @type {Translations} */\nconst defaultEnglishTranslations = {\n  searchPlaceholder: \"Search...\",\n  noOptionsFound: \"No options found\",\n  loadingOptions: \"Loading...\",\n  loadingOptionsAnnouncement: \"Loading options, please wait...\",\n  optionsLoadedAnnouncement: \"Options loaded.\",\n  noOptionsFoundAnnouncement: \"No options found.\",\n  addOption: 'Add \"{value}\"',\n  typeToLoadMore: \"...type to load more options\",\n  clearValue: \"Clear value\",\n  selectedOption: \"Selected option.\",\n  invalidOption: \"Invalid option.\",\n  invalidValues: \"Invalid values:\",\n  fieldContainsInvalidValues: \"Field contains invalid values\",\n  noOptionsSelected: \"No options selected\",\n  selectionAdded: \"added selection\",\n  selectionRemoved: \"removed selection\",\n  selectionsCurrent: \"currently selected\",\n  selectionsMore: \"and {count} more option\",\n  selectionsMorePlural: \"and {count} more options\",\n  // Function to format the count in badge, receives count and language as parameters\n  selectedCountFormatter: (count, lang) => new Intl.NumberFormat(lang).format(count),\n};\n\n// Auto-detect server-side rendering\nconst isServerDefault = typeof self === \"undefined\";\n\n/**\n * @param {string[]} arr Array to remove duplicates from\n */\nfunction unique(arr) {\n  return Array.from(new Set(arr));\n}\n\n/**\n * @param {Object} props - Props for the PopperContent component\n * @param {HTMLElement} [props.parent=document.body] The parent element to render the PopperContent component\n * @param {VNode} props.children The children to render\n * @param {React.RefObject<HTMLElement>} [props.rootElementRef] Reference to the source element to get direction context\n */\nconst Portal = ({ parent = document.body, children, rootElementRef }) => {\n  const [dir, setDir] = useState(/** @type {string|null} */ (null));\n\n  useEffect(() => {\n    if (rootElementRef?.current) {\n      const rootDir = window.getComputedStyle(rootElementRef.current).direction;\n      const parentDir = window.getComputedStyle(parent).direction;\n      if (rootDir !== parentDir) {\n        setDir(rootDir);\n      } else {\n        setDir(null);\n      }\n    }\n  }, [rootElementRef, parent]);\n\n  const wrappedChildren = dir ? (\n    <div dir={/** @type {\"auto\" | \"rtl\" | \"ltr\"} */ (dir)} style={{ direction: dir }}>\n      {children}\n    </div>\n  ) : (\n    children\n  );\n\n  return createPortal(wrappedChildren, parent);\n};\n\n// Popper.js helper\nconst dropdownPopperModifiers = [\n  {\n    name: \"flip\",\n    enabled: true,\n  },\n  {\n    // make the popper width same as root element\n    name: \"referenceElementWidth\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    requires: [\"computeStyles\"],\n    // @ts-ignore\n    fn: ({ state }) => {\n      state.styles.popper.minWidth = `${state.rects.reference.width}px`;\n    },\n    // @ts-ignore\n    effect: ({ state }) => {\n      state.elements.popper.style.minWidth = `${state.elements.reference.offsetWidth}px`;\n    },\n  },\n  {\n    name: \"eventListeners\",\n    enabled: true,\n    options: {\n      scroll: true,\n      resize: true,\n    },\n  },\n];\n\nconst tooltipPopperModifiers = [\n  {\n    name: \"offset\",\n    options: {\n      offset: [0, 2],\n    },\n  },\n  {\n    name: \"eventListeners\",\n    enabled: true,\n    options: {\n      scroll: true,\n      resize: true,\n    },\n  },\n];\n\n// Default icons\nconst defaultWarningIcon = (\n  <svg\n    className=\"PreactCombobox-warningIcon\"\n    viewBox=\"0 0 24 24\"\n    width=\"24\"\n    height=\"24\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z\" />\n  </svg>\n);\n\nconst defaultTickIcon = (\n  <svg\n    className=\"PreactCombobox-tickIcon\"\n    viewBox=\"0 0 24 24\"\n    width=\"14\"\n    height=\"14\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\" fill=\"currentColor\" />\n  </svg>\n);\n\nconst defaultChevronIcon = (\n  <svg\n    className=\"PreactCombobox-chevron\"\n    viewBox=\"0 0 24 24\"\n    width=\"24\"\n    height=\"24\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M7 10l5 5 5-5z\" />\n  </svg>\n);\n\n/** @type {NonNullable<PreactComboboxProps['loadingRenderer']>} */\nconst defaultLoadingRenderer = (loadingText) => loadingText;\n\n/** @type {OptionTransformFunction} */\nexport function defaultOptionRenderer({\n  option,\n  isSelected,\n  isInvalid,\n  showValue,\n  warningIcon,\n  tickIcon,\n  optionIconRenderer,\n}) {\n  const isLabelSameAsValue = option.value === option.label;\n  /**\n   * @param {(VNode|string)[]} labelNodes\n   * @param {(VNode|string)[]} valueNodes\n   * @returns {VNode}\n   */\n  const getLabel = (labelNodes, valueNodes) => (\n    <>\n      {optionIconRenderer?.(option, false)}\n      <span className=\"PreactCombobox-optionLabelFlex\">\n        <span>{labelNodes}</span>\n        {isLabelSameAsValue || !showValue ? null : (\n          <span className=\"PreactCombobox-optionValue\" aria-hidden=\"true\">\n            ({valueNodes})\n          </span>\n        )}\n      </span>\n    </>\n  );\n\n  const { label, value, matched, matchSlices } = option;\n  let labelElement;\n  if (matched === \"label\" || (matched === \"value\" && value === label)) {\n    const labelNodes = matchSlicesToNodes(matchSlices, label);\n    labelElement = getLabel(labelNodes, [value]);\n  } else if (matched === \"value\") {\n    const valueNodes = matchSlicesToNodes(matchSlices, value);\n    labelElement = getLabel([label], valueNodes);\n  } else {\n    // if matched === \"none\"\n    labelElement = getLabel([label], [value]);\n  }\n\n  return (\n    <>\n      <span\n        className={`PreactCombobox-optionCheckbox ${\n          isSelected ? \"PreactCombobox-optionCheckbox--selected\" : \"\"\n        }`}\n      >\n        {isSelected && tickIcon}\n      </span>\n      {labelElement}\n      {isInvalid && warningIcon}\n    </>\n  );\n}\n\n/** @type {NonNullable<PreactComboboxProps['optionIconRenderer']>} */\nfunction defaultOptionIconRenderer(option) {\n  return option.icon ? (\n    <span className=\"PreactCombobox-optionIcon\" aria-hidden=\"true\" role=\"img\">\n      {option.icon}\n    </span>\n  ) : null;\n}\n\n/** @type {string[]} */\nconst defaultArrayValue = [];\n\n/**\n * Creates a human-readable announcement of selected items\n * @param {string[]} selectedValues - Array of selected values\n * @param {\"added\"|\"removed\"|null|undefined} diff - Lookup object containing option labels\n * @param {string} language - Language code\n * @param {Record<string, Option>} optionsLookup - Lookup object containing option labels\n * @param {Translations} translations - Translations object\n * @returns {string} - Human-readable announcement of selections\n */\nfunction formatSelectionAnnouncement(selectedValues, diff, optionsLookup, language, translations) {\n  if (!selectedValues || selectedValues.length === 0) {\n    return translations.noOptionsSelected;\n  }\n\n  const labels = selectedValues.map((value) => optionsLookup[value]?.label || value);\n\n  const prefix = diff\n    ? diff === \"added\"\n      ? translations.selectionAdded\n      : translations.selectionRemoved\n    : translations.selectionsCurrent;\n\n  if (selectedValues.length <= 3) {\n    return `${prefix} ${new Intl.ListFormat(language, { style: \"long\", type: \"conjunction\" }).format(labels)}`;\n  }\n\n  const firstThree = labels.slice(0, 3);\n  const remaining = selectedValues.length - 3;\n  const moreText =\n    remaining === 1\n      ? translations.selectionsMore.replace(\"{count}\", remaining.toString())\n      : translations.selectionsMorePlural.replace(\"{count}\", remaining.toString());\n\n  return `${prefix} ${firstThree.join(\", \")} ${moreText}`;\n}\n\n/**\n * PreactCombobox component\n * @param {PreactComboboxProps} props - Component props\n */\nconst PreactCombobox = ({\n  id: idProp,\n  multiple = true,\n  allowedOptions,\n  allowFreeText = false,\n  onChange,\n  value = multiple ? defaultArrayValue : \"\",\n  language = \"en\",\n  placeholder = \"\",\n  disabled,\n  required,\n  name,\n  portal = document.body,\n  className = \"\",\n  rootElementProps,\n  inputProps: { tooltipContent = null, ...inputProps } = {},\n  formSubmitCompatible = false,\n  isServer = isServerDefault,\n  selectElementProps,\n  showValue = true,\n  showClearButton = true,\n  optionRenderer = defaultOptionRenderer,\n  optionIconRenderer = defaultOptionIconRenderer,\n  warningIcon = defaultWarningIcon,\n  tickIcon = defaultTickIcon,\n  chevronIcon = defaultChevronIcon,\n  loadingRenderer = defaultLoadingRenderer,\n  theme = \"system\",\n  tray = \"auto\",\n  trayBreakpoint = \"768px\",\n  trayLabel: trayLabelProp,\n  translations = defaultEnglishTranslations,\n  // private option for now\n  maxNumberOfPresentedOptions = 100,\n}) => {\n  // Merge default translations with provided translations\n  const mergedTranslations = useDeepMemo(\n    translations === defaultEnglishTranslations\n      ? translations\n      : { ...defaultEnglishTranslations, ...translations },\n  );\n  const values = multiple ? /** @type {string[]} */ (value) : null;\n  const singleSelectValue = multiple ? null : /** @type {string} */ (value);\n\n  /** @type {string[]} */\n  let tempArrayValue;\n  if (Array.isArray(value)) {\n    tempArrayValue = /** @type {string[]} */ (value);\n  } else {\n    tempArrayValue = value ? [/** @type {string} */ (value)] : [];\n  }\n  const arrayValues = useDeepMemo(tempArrayValue);\n  const arrayValuesLookup = useMemo(() => new Set(arrayValues), [arrayValues]);\n\n  const autoId = useId();\n  const id = idProp || autoId;\n  const [inputValue, setInputValue] = useState(\"\");\n  const [getIsDropdownOpen, setIsDropdownOpen] = useLive(false);\n  const [getIsFocused, setIsFocused] = useLive(false);\n  // For screen reader announcement\n  const [lastSelectionAnnouncement, setLastSelectionAnnouncement] = useState(\"\");\n  // For loading status announcements\n  const [loadingAnnouncement, setLoadingAnnouncement] = useState(\"\");\n  // Ref for OptionsListbox component to call navigation methods\n  const optionsListboxRef = useRef(\n    /** @type {import(\"./OptionsListbox.jsx\").OptionsListboxRef | null} */ (null),\n  );\n  // Track active descendant for aria-activedescendant on input (synced from AutocompleteList)\n  const [activeDescendantValue, setActiveDescendantValue] = useState(\"\");\n  const [warningIconHovered, setWarningIconHovered] = useState(false);\n  const inputRef = useRef(/** @type {HTMLInputElement | null} */ (null));\n  const blurTimeoutRef = useRef(/** @type {number | undefined} */ (undefined));\n  const rootElementRef = useRef(/** @type {HTMLDivElement | null} */ (null));\n  const dropdownPopperRef = useRef(/** @type {HTMLUListElement | null} */ (null));\n  const dropdownClosedExplicitlyRef = useRef(false);\n  const warningIconRef = useRef(null);\n  const tooltipPopperRef = useRef(null);\n  const undoStack = useRef(/** @type {string[][]} */ ([]));\n  const redoStack = useRef(/** @type {string[][]} */ ([]));\n  const [getTrayLabel, setTrayLabel] = useLive(trayLabelProp);\n\n  // Tray-related state\n  const [getIsTrayOpen, setIsTrayOpen] = useLive(false);\n  const trayClosedExplicitlyRef = useRef(false);\n  const [isMobileScreen, setIsMobileScreen] = useState(false);\n  const [trayActiveInputValue, setTrayActiveInputValue] = useState(\"\");\n\n  // Media query detection for auto tray mode\n  useEffect(() => {\n    if (tray === \"auto\") {\n      const mediaQuery = window.matchMedia(`(max-width: ${trayBreakpoint})`);\n      setIsMobileScreen(mediaQuery.matches);\n      const handleChange = (/** @type {MediaQueryListEvent} */ e) => setIsMobileScreen(e.matches);\n      mediaQuery.addEventListener(\"change\", handleChange);\n      return () => mediaQuery.removeEventListener(\"change\", handleChange);\n    }\n  }, [tray, trayBreakpoint]);\n\n  // Determine if tray should be used\n  const shouldUseTray = tray === true || (tray === \"auto\" && isMobileScreen);\n\n  // Use appropriate input value based on mode\n  const activeInputValue = getIsTrayOpen() ? trayActiveInputValue : inputValue;\n  const inputTrimmed = activeInputValue.trim();\n\n  /**\n   * Get the effective tray label\n   * If needed, automatically detect the label associated with the input field\n   * Following W3C accessible name computation priority order:\n   * 1. aria-labelledby (highest priority)\n   * 2. aria-label\n   * 3. Native HTML label element (label with 'for' attribute or wrapping label)\n   * 4. title attribute (fallback)\n   * @returns {string} The final computed tray label\n   */\n  const computeEffectiveTrayLabel = useCallback(() => {\n    if (trayLabelProp) return trayLabelProp;\n    if (typeof self === \"undefined\" || isServer || !inputRef.current) return \"\";\n\n    const inputElement = inputRef.current;\n    const inputId = inputElement.id;\n\n    // Priority 1: aria-labelledby (highest priority)\n    const ariaLabelledBy = inputElement.getAttribute(\"aria-labelledby\");\n    if (ariaLabelledBy) {\n      const labelElement = document.getElementById(ariaLabelledBy);\n      if (labelElement) {\n        return labelElement.textContent?.trim() || \"\";\n      }\n    }\n\n    // Priority 2: aria-label\n    const ariaLabel = inputElement.getAttribute(\"aria-label\");\n    if (ariaLabel) {\n      return ariaLabel.trim();\n    }\n\n    // Priority 3: Native HTML label element\n    // Method 3a: Look for label with 'for' attribute matching the input id\n    if (inputId) {\n      const labelElement = document.querySelector(`label[for=\"${inputId}\"]`);\n      if (labelElement) {\n        return labelElement.textContent?.trim() || \"\";\n      }\n    }\n\n    // Method 3b: Look for label that wraps the input element (using closest for efficiency)\n    const wrappingLabel = inputElement.closest(\"label\");\n    if (wrappingLabel) {\n      return wrappingLabel.textContent?.trim() || \"\";\n    }\n\n    // Priority 4: title attribute (fallback - lowest priority)\n    const title = inputElement.getAttribute(\"title\");\n    if (title) {\n      return title.trim();\n    }\n\n    return \"\";\n  }, [trayLabelProp, isServer]);\n  useLayoutEffect(() => {\n    setTrayLabel(computeEffectiveTrayLabel());\n  }, [setTrayLabel, computeEffectiveTrayLabel]);\n\n  // Determine if options should be fetched/filtered (dropdown or tray is open)\n  const isListOpen = shouldUseTray ? getIsTrayOpen() : getIsDropdownOpen();\n\n  // Use the async options hook for fetching, caching, and filtering\n  const { filteredOptions, resolvedOptionsLookup, isLoading } = useAsyncOptions({\n    allowedOptions,\n    selectedValues: arrayValues,\n    searchText: activeInputValue,\n    isOpen: isListOpen,\n    language,\n    maxNumberOfPresentedOptions,\n  });\n\n  // Alias for backward compatibility with existing code\n  const allOptionsLookup = resolvedOptionsLookup;\n\n  const invalidValues = useMemo(() => {\n    if (allowFreeText) return [];\n    return arrayValues?.filter((v) => !allOptionsLookup[v]) || [];\n  }, [allowFreeText, arrayValues, allOptionsLookup]);\n\n  const updateSelectionAnnouncement = useCallback(\n    /**\n     * @param {string[]} selectedValues\n     * @param {\"added\"|\"removed\"|null} [diff]\n     */\n    (selectedValues, diff) => {\n      const announcement = formatSelectionAnnouncement(\n        selectedValues,\n        diff,\n        allOptionsLookup,\n        language,\n        mergedTranslations,\n      );\n      setLastSelectionAnnouncement(announcement);\n    },\n    [allOptionsLookup, mergedTranslations, language],\n  );\n\n  /**\n   * Callback for when OptionsListbox's active descendant changes\n   * @param {string} value - The new active descendant value\n   */\n  const handleActiveDescendantChange = useCallback(\n    /** @param {string} value */\n    (value) => {\n      setActiveDescendantValue(value);\n    },\n    [],\n  );\n\n  const closeDropdown = useCallback(\n    (closedExplicitly = false) => {\n      setIsDropdownOpen(false);\n      // Don't wait till next render cycle (which destroys the popper) to hide the popper\n      if (dropdownPopperRef.current) {\n        // @ts-ignore\n        dropdownPopperRef.current.style.display = \"none\";\n      }\n      if (closedExplicitly) {\n        dropdownClosedExplicitlyRef.current = true;\n      }\n\n      // Announce current selections when dropdown is closed\n      updateSelectionAnnouncement(arrayValues);\n\n      // Clear active descendant via ref (will also trigger state update via callback)\n      optionsListboxRef.current?.clearActiveDescendant();\n    },\n    [setIsDropdownOpen, updateSelectionAnnouncement, arrayValues],\n  );\n\n  // Setup popper when dropdown is opened\n  useEffect(() => {\n    if (\n      getIsDropdownOpen() &&\n      !shouldUseTray &&\n      rootElementRef.current &&\n      dropdownPopperRef.current\n    ) {\n      // Get computed direction to handle RTL layout\n      const computedDir = window.getComputedStyle(rootElementRef.current).direction;\n      const placement = computedDir === \"rtl\" ? \"bottom-end\" : \"bottom-start\";\n\n      const popperInstance = createPopper(rootElementRef.current, dropdownPopperRef.current, {\n        placement: placement,\n        // @ts-ignore\n        modifiers: dropdownPopperModifiers,\n      });\n      dropdownPopperRef.current.style.display = \"block\";\n      // Clean up function\n      return () => {\n        popperInstance.destroy();\n      };\n    }\n    if (shouldUseTray && dropdownPopperRef.current) {\n      dropdownPopperRef.current.style.display = \"none\";\n    }\n  }, [getIsDropdownOpen, shouldUseTray]);\n\n  // Note: filtering state moved to AutocompleteList component\n  // Note: All filtering and fetching logic moved to AutocompleteList component\n\n  // Note: addNewOptionVisible now handled in AutocompleteList component\n\n  // Note: activeDescendant state now lives in AutocompleteList, synced via onActiveDescendantChange callback\n\n  // Setup warning tooltip popper when hovering over warning icon\n  useEffect(() => {\n    if (\n      invalidValues.length > 0 &&\n      warningIconHovered &&\n      warningIconRef.current &&\n      tooltipPopperRef.current &&\n      rootElementRef.current\n    ) {\n      // Get computed direction to handle RTL layout\n      const computedDir = window.getComputedStyle(rootElementRef.current).direction;\n      const placement = computedDir === \"rtl\" ? \"bottom-end\" : \"bottom-start\";\n\n      const popperInstance = createPopper(warningIconRef.current, tooltipPopperRef.current, {\n        placement: placement,\n        // @ts-ignore\n        modifiers: tooltipPopperModifiers,\n      });\n      // @ts-ignore\n      tooltipPopperRef.current.style.display = \"block\";\n\n      // Clean up function\n      return () => {\n        popperInstance.destroy();\n      };\n    }\n  }, [warningIconHovered, invalidValues.length]);\n\n  /**\n   * Handle option selection\n   * @param {string} selectedValue The selected option value\n   */\n  const handleOptionSelect = useCallback(\n    /**\n     * @param {string} selectedValue\n     * @param {{ toggleSelected?: boolean }} [options]\n     */\n    (selectedValue, { toggleSelected = false } = {}) => {\n      // Check if the option is disabled\n      const option = allOptionsLookup[selectedValue];\n      if (option?.disabled) {\n        return;\n      }\n      if (values) {\n        const isExistingOption = values.includes(selectedValue);\n        let newValues;\n        if (!isExistingOption || (toggleSelected && isExistingOption)) {\n          if (toggleSelected && isExistingOption) {\n            newValues = values.filter((v) => v !== selectedValue);\n          } else {\n            newValues = [...values, selectedValue];\n          }\n          onChange(newValues);\n          updateSelectionAnnouncement(\n            [selectedValue],\n            newValues.length < values.length ? \"removed\" : \"added\",\n          );\n          undoStack.current.push(values);\n          redoStack.current = [];\n        }\n      } else {\n        if (\n          singleSelectValue !== selectedValue ||\n          (toggleSelected && singleSelectValue === selectedValue)\n        ) {\n          let newValue;\n          if (toggleSelected && singleSelectValue === selectedValue) {\n            newValue = \"\";\n          } else {\n            newValue = selectedValue;\n          }\n          onChange(newValue);\n          updateSelectionAnnouncement([selectedValue], newValue ? \"removed\" : \"added\");\n          undoStack.current.push([newValue]);\n          redoStack.current = [];\n          closeDropdown();\n        }\n        setInputValue(\"\");\n      }\n    },\n    [\n      onChange,\n      singleSelectValue,\n      values,\n      updateSelectionAnnouncement,\n      closeDropdown,\n      allOptionsLookup,\n    ],\n  );\n\n  const focusInputWithVirtualKeyboardGuard = useCallback(\n    /**\n     * @param {Object} params\n     * @param {HTMLInputElement | null} params.input\n     * @param {boolean} [params.shouldPreventKeyboardReopen]\n     * @param {boolean} [params.forceOpenKeyboard]\n     * @param {{ current: ReturnType<typeof setTimeout> | null } | null} [params.readonlyResetTimeoutRef]\n     */\n    (params) => {\n      const {\n        input,\n        shouldPreventKeyboardReopen = false,\n        forceOpenKeyboard = false,\n        readonlyResetTimeoutRef = null,\n      } = params;\n      if (!input) return;\n      // If user explicitly closed the keyboard, we need to temporarily disable the input\n      // to prevent the keyboard from being reopened.\n      const shouldTemporarilyDisableInput = shouldPreventKeyboardReopen && !forceOpenKeyboard;\n      if (shouldTemporarilyDisableInput) {\n        input.setAttribute(\"readonly\", \"readonly\");\n      }\n      // Does it make sense to focus the input if it's already focused?\n      // Yes, because it's possible that the next event in the event loop\n      // is the one that will trigger the a 'blur' event. To cancel the blur,\n      // we need to focus the input again.\n      input.focus();\n      if (shouldTemporarilyDisableInput) {\n        if (readonlyResetTimeoutRef?.current) {\n          clearTimeout(readonlyResetTimeoutRef.current);\n        }\n        const removeReadonly = () => {\n          input.removeAttribute(\"readonly\");\n          if (readonlyResetTimeoutRef) {\n            readonlyResetTimeoutRef.current = null;\n          }\n        };\n        if (readonlyResetTimeoutRef) {\n          readonlyResetTimeoutRef.current = setTimeout(removeReadonly, 10);\n        } else {\n          setTimeout(removeReadonly, 10);\n        }\n      }\n    },\n    [],\n  );\n\n  const focusInput = useCallback(\n    (forceOpenKeyboard = false) => {\n      focusInputWithVirtualKeyboardGuard({\n        input: inputRef.current,\n        shouldPreventKeyboardReopen:\n          getIsFocused() && virtualKeyboardExplicitlyClosedRef.current === true,\n        forceOpenKeyboard,\n      });\n    },\n    [getIsFocused, focusInputWithVirtualKeyboardGuard],\n  );\n\n  const openTray = useCallback(() => {\n    if (!shouldUseTray) return;\n    setIsTrayOpen(true);\n    setIsDropdownOpen(false);\n    trayClosedExplicitlyRef.current = false;\n  }, [shouldUseTray, setIsDropdownOpen, setIsTrayOpen]);\n\n  const closeTray = useCallback(() => {\n    setIsTrayOpen(false);\n    setTrayActiveInputValue(\"\");\n    trayClosedExplicitlyRef.current = true;\n    focusInput(true);\n  }, [setIsTrayOpen, focusInput]);\n\n  const handleInputChange = useCallback(\n    /**\n     * Handle input change\n     * @param {import('preact/compat').ChangeEvent<HTMLInputElement>} e - Input change event\n     */\n    (e) => {\n      if (shouldUseTray) {\n        e.preventDefault();\n        openTray();\n        return;\n      }\n      setInputValue(e.currentTarget.value);\n      if (!dropdownClosedExplicitlyRef.current) {\n        setIsDropdownOpen(true);\n      }\n    },\n    [setIsDropdownOpen, shouldUseTray, openTray],\n  );\n\n  const handleTrayInputChange = useCallback(\n    /**\n     * Handle tray input change\n     * @param {string} value - Input value\n     */\n    (value) => {\n      setTrayActiveInputValue(value);\n    },\n    [],\n  );\n\n  /**\n   * Tristate - null means virtual keyboard is not actively being detected.\n   * True means virtual keyboard was explicitly closed.\n   * False means virtual keyboard was not explicitly closed.\n   * @type {import('preact').RefObject<boolean|null>}\n   */\n  const virtualKeyboardExplicitlyClosedRef = useRef(null);\n  const virtualKeyboardDismissSubscription = useRef(/** @type {function | null} */ (null));\n\n  const handleInputFocus = useCallback(() => {\n    setIsFocused(true);\n    clearTimeout(blurTimeoutRef.current);\n    blurTimeoutRef.current = undefined;\n    if (shouldUseTray) {\n      if (!trayClosedExplicitlyRef.current) {\n        openTray();\n      }\n      trayClosedExplicitlyRef.current = false;\n    } else {\n      setIsDropdownOpen(true);\n      dropdownClosedExplicitlyRef.current = false;\n      if (!virtualKeyboardDismissSubscription.current) {\n        virtualKeyboardDismissSubscription.current = subscribeToVirtualKeyboard({\n          visibleCallback(isVisible) {\n            virtualKeyboardExplicitlyClosedRef.current = !isVisible;\n          },\n        });\n      }\n    }\n    updateSelectionAnnouncement(arrayValues);\n  }, [\n    setIsFocused,\n    setIsDropdownOpen,\n    openTray,\n    arrayValues,\n    updateSelectionAnnouncement,\n    shouldUseTray,\n  ]);\n\n  // Delay blur to allow option selection\n  const handleInputBlur = useCallback(() => {\n    setIsFocused(false);\n    clearTimeout(blurTimeoutRef.current);\n    blurTimeoutRef.current = undefined;\n    closeDropdown();\n    dropdownClosedExplicitlyRef.current = false;\n    // Auto-select matching option if single-select\n    if (!multiple) {\n      if (inputTrimmed && (allowFreeText || allOptionsLookup[inputTrimmed])) {\n        handleOptionSelect(inputTrimmed);\n      }\n    }\n    setInputValue(\"\");\n    setLastSelectionAnnouncement(\"\");\n    if (!shouldUseTray) {\n      virtualKeyboardDismissSubscription.current?.();\n      virtualKeyboardDismissSubscription.current = null;\n      virtualKeyboardExplicitlyClosedRef.current = null;\n    }\n  }, [\n    setIsFocused,\n    allOptionsLookup,\n    allowFreeText,\n    handleOptionSelect,\n    multiple,\n    inputTrimmed,\n    closeDropdown,\n    shouldUseTray,\n  ]);\n\n  const handleAddNewOption = useCallback(\n    /**\n     * @param {string} newValue\n     */\n    (newValue) => {\n      handleOptionSelect(newValue);\n      // Set active descendant via ref\n      optionsListboxRef.current?.setActiveDescendant(newValue);\n    },\n    [handleOptionSelect],\n  );\n\n  /**\n   * Handle keydown events on the input\n   */\n  const handleKeyDown = useCallback(\n    /**\n     * @param {import('preact/compat').KeyboardEvent<HTMLInputElement>} e - Keyboard event\n     */\n    (e) => {\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        // Try to select the active option first\n        const selected = optionsListboxRef.current?.selectActive();\n        // If nothing was selected and free text is allowed, add new option\n        if (!selected && allowFreeText && inputTrimmed !== \"\") {\n          handleAddNewOption(inputTrimmed);\n        }\n      } else if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n        // Navigate to next option\n        optionsListboxRef.current?.navigateDown();\n      } else if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n        // Navigate to previous option\n        optionsListboxRef.current?.navigateUp();\n      } else if (e.key === \"Escape\") {\n        closeDropdown(true);\n      } else if (e.key === \"Home\" && (e.ctrlKey || !inputValue) && getIsDropdownOpen()) {\n        e.preventDefault();\n        optionsListboxRef.current?.navigateToFirst();\n      } else if (e.key === \"End\" && (e.ctrlKey || !inputValue) && getIsDropdownOpen()) {\n        e.preventDefault();\n        optionsListboxRef.current?.navigateToLast();\n      } else if (e.key === \"PageDown\") {\n        e.preventDefault();\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n        optionsListboxRef.current?.navigatePageDown();\n      } else if (e.key === \"PageUp\") {\n        e.preventDefault();\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n        optionsListboxRef.current?.navigatePageUp();\n        // Undo action\n      } else if (inputValue === \"\" && (e.ctrlKey || e.metaKey) && e.key === \"z\") {\n        e.preventDefault();\n        const prevValues = undoStack.current.pop();\n        if (prevValues) {\n          onChange(prevValues);\n          updateSelectionAnnouncement(prevValues);\n          redoStack.current.push(Array.isArray(value) ? value : [value]);\n        }\n        // Redo action\n      } else if (inputValue === \"\" && (e.ctrlKey || e.metaKey) && e.key === \"y\") {\n        e.preventDefault();\n        const nextValues = redoStack.current.pop();\n        if (nextValues) {\n          onChange(nextValues);\n          updateSelectionAnnouncement(nextValues);\n          undoStack.current.push(Array.isArray(value) ? value : [value]);\n        }\n      }\n    },\n    [\n      allowFreeText,\n      handleAddNewOption,\n      inputValue,\n      inputTrimmed,\n      onChange,\n      getIsDropdownOpen,\n      setIsDropdownOpen,\n      value,\n      closeDropdown,\n      updateSelectionAnnouncement,\n    ],\n  );\n  /**\n   * Handle paste event\n   */\n  const handlePaste = useCallback(\n    /**\n     * @param {import('preact/compat').ClipboardEvent<HTMLInputElement>} e - Clipboard event\n     */\n    (e) => {\n      // only handle paste in multi-select mode\n      if (!values) return;\n\n      // e.preventDefault();\n      // Get options array from lookup\n      const allOptions = Object.values(allOptionsLookup);\n      // Case 1 : Exact matches\n      const valuesLookup = {\n        ...Object.fromEntries(values.map((v) => [v, v])),\n        ...Object.fromEntries(allOptions.map((o) => [o.value, o.value])),\n      };\n      // Case 2 : Case insensitive matches\n      const valuesLowerCaseLookup = {\n        ...Object.fromEntries(values.map((v) => [v.toLowerCase(), v])),\n        ...Object.fromEntries(allOptions.map((o) => [o.value.toLowerCase(), o.value])),\n      };\n      // Case 3 : Case insensitive matches against label\n      const optionsLabelLookup = Object.fromEntries(\n        allOptions.map((o) => [o.label.toLowerCase(), o.value]),\n      );\n      const pastedText = e.clipboardData?.getData(\"text\") || \"\";\n      if (!pastedText) return;\n      const pastedOptions = pastedText\n        .split(\",\")\n        .map((x) => x.trim())\n        .filter((x) => x !== \"\")\n        .map(\n          (x) =>\n            valuesLookup[x] ||\n            valuesLowerCaseLookup[x.toLowerCase()] ||\n            optionsLabelLookup[x.toLocaleLowerCase()] ||\n            x,\n        );\n\n      const newValues = unique([...values, ...pastedOptions]);\n      onChange(newValues);\n      updateSelectionAnnouncement(newValues, \"added\");\n      undoStack.current.push(values);\n      redoStack.current = [];\n      // Note: Option re-rendering handled by AutocompleteList component\n    },\n    [allOptionsLookup, onChange, values, updateSelectionAnnouncement],\n  );\n\n  const handleClearValue = useCallback(() => {\n    setInputValue(\"\");\n    onChange(multiple ? [] : \"\");\n    updateSelectionAnnouncement(arrayValues, \"removed\");\n    undoStack.current.push(arrayValues);\n    redoStack.current = [];\n    // If current input is focused, we need to prevent a blur event from being triggered\n    // by focusing the input again. Else don't focus the input.\n    if (getIsFocused()) {\n      focusInput();\n    }\n  }, [onChange, multiple, arrayValues, updateSelectionAnnouncement, getIsFocused, focusInput]);\n\n  const handleRootElementClick = useCallback(() => {\n    if (!disabled) {\n      if (shouldUseTray) {\n        openTray();\n      } else {\n        if (inputRef.current && document.activeElement !== inputRef.current) {\n          // We regard an explicit click on the root element as an attempt to open the keyboard.\n          focusInput(true);\n        }\n        // This set is not redundant as input may already be focused\n        // and handleInputFocus may not be called\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n      }\n    }\n  }, [disabled, shouldUseTray, openTray, focusInput, setIsDropdownOpen]);\n\n  // Memoize whatever JSX that can be memoized\n  const selectChildren = useMemo(\n    () =>\n      formSubmitCompatible\n        ? arrayValues\n            .map((val) => (\n              <option key={val} value={val} disabled={allOptionsLookup[val]?.disabled}>\n                {allOptionsLookup[val]?.label || val}\n              </option>\n            ))\n            .concat(\n              typeof allowedOptions !== \"function\"\n                ? allowedOptions\n                    .filter((o) => !arrayValuesLookup.has(o.value))\n                    .slice(0, maxNumberOfPresentedOptions - arrayValues.length)\n                    .map((o) => (\n                      <option key={o.value} value={o.value} disabled={o.disabled}>\n                        {o.label}\n                      </option>\n                    ))\n                : [],\n            )\n        : null,\n    [\n      arrayValues,\n      allOptionsLookup,\n      formSubmitCompatible,\n      allowedOptions,\n      arrayValuesLookup,\n      maxNumberOfPresentedOptions,\n    ],\n  );\n\n  // Update loading announcement when isLoading changes\n  useEffect(() => {\n    // Only announce loading if the list is open\n    if (isLoading && isListOpen) {\n      setLoadingAnnouncement(mergedTranslations.loadingOptionsAnnouncement);\n    } else if (loadingAnnouncement && !isLoading && isListOpen) {\n      // Only announce completion if we previously announced loading\n      // and the list is still open\n      setLoadingAnnouncement(\n        filteredOptions.length\n          ? mergedTranslations.optionsLoadedAnnouncement\n          : mergedTranslations.noOptionsFoundAnnouncement,\n      );\n      // Clear the announcement after a delay\n      const timer = setTimeout(() => {\n        setLoadingAnnouncement(\"\");\n      }, 1000);\n      return () => clearTimeout(timer);\n    } else if (loadingAnnouncement && !isListOpen) {\n      // Clear any loading announcements when list closes\n      setLoadingAnnouncement(\"\");\n    }\n  }, [\n    isLoading,\n    loadingAnnouncement,\n    isListOpen,\n    filteredOptions.length,\n    mergedTranslations.loadingOptionsAnnouncement,\n    mergedTranslations.optionsLoadedAnnouncement,\n    mergedTranslations.noOptionsFoundAnnouncement,\n  ]);\n\n  // Determine if we should render interactive elements\n  const isServerSideForm = isServer && formSubmitCompatible;\n\n  // Callback to set dropdown ref for popper positioning\n  const setDropdownRef = useCallback(\n    /** @param {HTMLUListElement | null} el */\n    (el) => {\n      dropdownPopperRef.current = el;\n    },\n    [],\n  );\n\n  const optionsListbox = !isServer ? (\n    <OptionsListbox\n      ref={optionsListboxRef}\n      id={id}\n      searchText={activeInputValue}\n      filteredOptions={filteredOptions}\n      isLoading={isLoading}\n      arrayValues={arrayValues}\n      invalidValues={invalidValues}\n      multiple={multiple}\n      allowFreeText={allowFreeText}\n      onOptionSelect={handleOptionSelect}\n      onActiveDescendantChange={handleActiveDescendantChange}\n      onClose={shouldUseTray ? closeTray : closeDropdown}\n      optionRenderer={optionRenderer}\n      warningIcon={warningIcon}\n      tickIcon={tickIcon}\n      optionIconRenderer={optionIconRenderer}\n      showValue={showValue}\n      language={language}\n      loadingRenderer={loadingRenderer}\n      translations={mergedTranslations}\n      theme={theme}\n      isOpen={isListOpen}\n      shouldUseTray={shouldUseTray}\n      setDropdownRef={setDropdownRef}\n    />\n  ) : null;\n\n  return (\n    <div\n      className={[\n        className,\n        \"PreactCombobox\",\n        disabled ? \"PreactCombobox--disabled\" : \"\",\n        `PreactCombobox--${theme}`,\n        tray === \"auto\" ? \"PreactCombobox--trayAuto\" : \"\",\n      ]\n        .filter(Boolean)\n        .join(\" \")}\n      aria-disabled={disabled}\n      onClick={handleRootElementClick}\n      id={`${id}-root`}\n      ref={rootElementRef}\n      {...rootElementProps}\n    >\n      {/* Live region for announcing selections to screen readers */}\n      <div className=\"PreactCombobox-srOnly\" aria-live=\"polite\" aria-atomic=\"true\">\n        {getIsFocused() ? lastSelectionAnnouncement : \"\"}\n      </div>\n\n      {/* Live region for announcing loading status to screen readers */}\n      <div className=\"PreactCombobox-srOnly\" aria-live=\"polite\" aria-atomic=\"true\">\n        {getIsFocused() ? loadingAnnouncement : \"\"}\n      </div>\n\n      {/* Live region for announcing loading status to screen readers */}\n      <div className=\"PreactCombobox-srOnly\" aria-live=\"polite\" aria-atomic=\"true\">\n        {invalidValues.length > 0 && getIsFocused()\n          ? mergedTranslations.fieldContainsInvalidValues\n          : \"\"}\n      </div>\n\n      <div className={`PreactCombobox-field ${disabled ? \"PreactCombobox-field--disabled\" : \"\"}`}>\n        {!isServerSideForm && (\n          <>\n            {/* Show icon for single select mode */}\n            {!multiple &&\n              singleSelectValue &&\n              allOptionsLookup[singleSelectValue] &&\n              optionIconRenderer?.(allOptionsLookup[singleSelectValue], true)}\n            <input\n              id={id}\n              ref={inputRef}\n              type=\"text\"\n              value={inputValue}\n              placeholder={\n                !shouldUseTray && getIsDropdownOpen()\n                  ? mergedTranslations.searchPlaceholder\n                  : arrayValues.length > 0\n                    ? arrayValues.map((value) => allOptionsLookup[value]?.label || value).join(\", \")\n                    : placeholder\n              }\n              onChange={handleInputChange}\n              onKeyDown={handleKeyDown}\n              onFocus={handleInputFocus}\n              onBlur={() => {\n                // @ts-ignore\n                blurTimeoutRef.current = setTimeout(handleInputBlur, 200);\n              }}\n              onPaste={handlePaste}\n              className={`PreactCombobox-input ${\n                multiple ? \"PreactCombobox-input--multiple\" : \"\"\n              } ${disabled ? \"PreactCombobox-input--disabled\" : \"\"}`}\n              role=\"combobox\"\n              aria-expanded={getIsDropdownOpen()}\n              aria-haspopup=\"listbox\"\n              aria-controls={`${id}-options-listbox`}\n              aria-activedescendant={\n                activeDescendantValue\n                  ? `${id}-option-${toHTMLId(activeDescendantValue)}`\n                  : undefined\n              }\n              disabled={disabled}\n              required={required && arrayValues.length === 0}\n              {...inputProps}\n            />\n            {!disabled && showClearButton && arrayValues.length > 0 ? (\n              <button\n                type=\"button\"\n                className=\"PreactCombobox-clearButton\"\n                aria-label={mergedTranslations.clearValue}\n                onClick={handleClearValue}\n              >\n                <span aria-hidden=\"true\">&#x2715;</span>\n              </button>\n            ) : null}\n            {invalidValues.length > 0 && (\n              <span\n                ref={warningIconRef}\n                className=\"PreactCombobox-warningIconWrapper\"\n                onMouseEnter={() => setWarningIconHovered(true)}\n                onMouseLeave={() => setWarningIconHovered(false)}\n              >\n                {warningIcon}\n              </span>\n            )}\n            {multiple && arrayValues.length > 1 && (\n              <span className=\"PreactCombobox-badge\">\n                {mergedTranslations.selectedCountFormatter(arrayValues.length, language)}\n              </span>\n            )}\n            {chevronIcon}\n          </>\n        )}\n\n        {/* This is a hidden select element to allow for form submission */}\n        {formSubmitCompatible ? (\n          <select\n            {...selectElementProps}\n            multiple={multiple}\n            hidden={!isServerSideForm}\n            tabIndex={isServerSideForm ? 0 : -1}\n            readOnly={!isServerSideForm}\n            // @ts-expect-error this is a valid react attribute\n            value={value}\n            name={name}\n            size={1}\n            className={isServerSideForm ? \"PreactCombobox-formSelect\" : \"\"}\n          >\n            {selectChildren}\n          </select>\n        ) : null}\n      </div>\n\n      {optionsListbox ? (\n        <Portal parent={portal} rootElementRef={rootElementRef}>\n          {shouldUseTray ? (\n            <TraySearchList\n              id={id}\n              isOpen={getIsTrayOpen()}\n              onClose={closeTray}\n              trayLabel={getTrayLabel() || \"\"}\n              theme={theme}\n              translations={mergedTranslations}\n              onInputChange={handleTrayInputChange}\n            >\n              {optionsListbox}\n            </TraySearchList>\n          ) : (\n            optionsListbox\n          )}\n        </Portal>\n      ) : null}\n      {invalidValues.length > 0 && warningIconHovered && !isServer && (\n        <Portal parent={portal} rootElementRef={rootElementRef}>\n          <div\n            className={`PreactCombobox-valueTooltip ${`PreactCombobox--${theme}`}`}\n            role=\"tooltip\"\n            ref={tooltipPopperRef}\n          >\n            {mergedTranslations.invalidValues}\n            {invalidValues.map((value) => (\n              <div key={value} className=\"PreactCombobox-tooltipValue\">\n                {value}\n              </div>\n            ))}\n          </div>\n        </Portal>\n      )}\n    </div>\n  );\n};\n\nexport default PreactCombobox;\n", "import { forwardRef } from \"preact/compat\";\nimport { useCallback, useEffect, useImperativeHandle, useRef, useState } from \"preact/hooks\";\nimport { toHTMLId } from \"./utils.jsx\";\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"./PreactCombobox.jsx\").Translations} Translations\n * @typedef {import(\"./PreactCombobox.jsx\").OptionTransformFunction} OptionTransformFunction\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @typedef {Object} OptionsListboxProps\n * @property {string} id - Component ID for ARIA attributes\n * @property {string} searchText - Current search/input text\n * @property {OptionMatch[]} filteredOptions - Pre-filtered options to display\n * @property {boolean} isLoading - Whether options are currently loading\n * @property {string[]} arrayValues - Currently selected values\n * @property {string[]} invalidValues - Invalid selected values\n * @property {boolean} multiple - Whether multi-select is enabled\n * @property {boolean} allowFreeText - Allow adding custom options\n * @property {(selectedValue: string, options?: {toggleSelected?: boolean}) => void} onOptionSelect - Handle option selection\n * @property {(value: string) => void} [onActiveDescendantChange] - Callback when active descendant changes (for aria-activedescendant)\n * @property {() => void} [onClose] - Handle close (for single-select)\n * @property {OptionTransformFunction} optionRenderer - Function to render options\n * @property {VNode} warningIcon - Warning icon element\n * @property {VNode} tickIcon - Tick icon element\n * @property {(option: Option, isInput?: boolean) => VNode|null} optionIconRenderer - Option icon renderer\n * @property {boolean} showValue - Whether to show option values\n * @property {string} language - Language code for rendering\n * @property {(text: string) => VNode|string} loadingRenderer - Loading renderer\n * @property {Translations} translations - Translation strings\n * @property {string} theme - Theme for styling\n * @property {boolean} isOpen - Whether the list should be visible\n * @property {boolean} shouldUseTray - Whether this is used in tray mode\n * @property {(ref: HTMLUListElement | null) => void} [setDropdownRef] - Callback to set dropdown ref for popper\n */\n\n/**\n * @typedef {Object} OptionsListboxRef\n * @property {() => void} navigateUp - Navigate to previous option\n * @property {() => void} navigateDown - Navigate to next option\n * @property {() => void} navigateToFirst - Navigate to first option\n * @property {() => void} navigateToLast - Navigate to last option\n * @property {() => void} navigatePageDown - Navigate down by one visible page of options\n * @property {() => void} navigatePageUp - Navigate up by one visible page of options\n * @property {() => boolean} selectActive - Select the currently active option, returns true if selection was made\n * @property {() => string} getActiveDescendant - Get the currently active descendant value\n * @property {(value: string) => void} setActiveDescendant - Set the active descendant value\n * @property {() => void} clearActiveDescendant - Clear the active descendant\n */\n\n/**\n * OptionsListbox component - renders a listbox with keyboard navigation and selection\n * Receives pre-filtered options and handles navigation/selection\n * @type {import(\"preact/compat\").ForwardRefExoticComponent<OptionsListboxProps & import(\"preact/compat\").RefAttributes<OptionsListboxRef>>}\n */\nconst OptionsListbox = forwardRef(\n  (\n    /** @type {OptionsListboxProps} */\n    {\n      id,\n      searchText,\n      filteredOptions,\n      isLoading,\n      arrayValues,\n      invalidValues,\n      multiple,\n      allowFreeText,\n      onOptionSelect,\n      onActiveDescendantChange,\n      onClose,\n      optionRenderer,\n      warningIcon,\n      tickIcon,\n      optionIconRenderer,\n      showValue,\n      language,\n      loadingRenderer,\n      translations,\n      theme,\n      isOpen,\n      shouldUseTray,\n      setDropdownRef,\n    },\n    ref,\n  ) => {\n    const [activeDescendant, setActiveDescendant] = useState(\"\");\n    const listRef = useRef(/** @type {HTMLUListElement | null} */ (null));\n\n    const searchTextTrimmed = searchText.trim();\n\n    const addNewOptionVisible =\n      !isLoading &&\n      allowFreeText &&\n      searchTextTrimmed &&\n      !arrayValues.includes(searchTextTrimmed) &&\n      !filteredOptions.find((/** @type {OptionMatch} */ o) => o.value === searchTextTrimmed);\n\n    const scrollOptionIntoView = useCallback(\n      /** @param {string} optionValue */\n      (optionValue) => {\n        if (!listRef.current || !optionValue) return;\n        const elementId = `${id}-option-${toHTMLId(optionValue)}`;\n        const element = listRef.current.querySelector(`#${CSS.escape(elementId)}`);\n        if (element) {\n          const listRect = listRef.current.getBoundingClientRect();\n          const itemRect = element.getBoundingClientRect();\n          // do not user scrollIntoView, because that would scroll the page\n          // as well and that's annoying.\n          if (itemRect.bottom > listRect.bottom) {\n            listRef.current.scrollTop += itemRect.bottom - listRect.bottom;\n          } else if (itemRect.top < listRect.top) {\n            listRef.current.scrollTop += itemRect.top - listRect.top;\n          }\n        }\n      },\n      [id],\n    );\n\n    const getNavigableOptions = useCallback(() => {\n      const options = filteredOptions\n        .filter((/** @type {OptionMatch} */ o) => !o.disabled)\n        .map((/** @type {OptionMatch} */ o) => o.value);\n      if (addNewOptionVisible) {\n        return [searchTextTrimmed, ...options];\n      }\n      return options;\n    }, [filteredOptions, addNewOptionVisible, searchTextTrimmed]);\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        navigateDown: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : -1;\n          const nextIndex = currentIndex === options.length - 1 ? 0 : currentIndex + 1;\n          const nextValue = options[nextIndex];\n          if (nextValue !== undefined) {\n            setActiveDescendant(nextValue);\n            scrollOptionIntoView(nextValue);\n          }\n        },\n        navigateUp: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : 0;\n          const prevIndex = currentIndex <= 0 ? options.length - 1 : currentIndex - 1;\n          const prevValue = options[prevIndex];\n          if (prevValue !== undefined) {\n            setActiveDescendant(prevValue);\n            scrollOptionIntoView(prevValue);\n          }\n        },\n        navigateToFirst: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const firstValue = options[0];\n          if (firstValue !== undefined) {\n            setActiveDescendant(firstValue);\n            scrollOptionIntoView(firstValue);\n          }\n        },\n        navigateToLast: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const lastValue = options[options.length - 1];\n          if (lastValue !== undefined) {\n            setActiveDescendant(lastValue);\n            scrollOptionIntoView(lastValue);\n          }\n        },\n        navigatePageDown: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const firstOptionEl = listRef.current?.querySelector(\".PreactCombobox-option\");\n          const pageSize =\n            listRef.current && firstOptionEl\n              ? Math.max(\n                  1,\n                  Math.floor(\n                    listRef.current.clientHeight / firstOptionEl.getBoundingClientRect().height,\n                  ),\n                )\n              : 10;\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : -1;\n          const targetIndex = Math.min(currentIndex + pageSize, options.length - 1);\n          const targetValue = options[targetIndex];\n          if (targetValue !== undefined) {\n            setActiveDescendant(targetValue);\n            scrollOptionIntoView(targetValue);\n          }\n        },\n        navigatePageUp: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const firstOptionEl = listRef.current?.querySelector(\".PreactCombobox-option\");\n          const pageSize =\n            listRef.current && firstOptionEl\n              ? Math.max(\n                  1,\n                  Math.floor(\n                    listRef.current.clientHeight / firstOptionEl.getBoundingClientRect().height,\n                  ),\n                )\n              : 10;\n          const currentIndex = activeDescendant\n            ? options.indexOf(activeDescendant)\n            : options.length;\n          const targetIndex = Math.max(currentIndex - pageSize, 0);\n          const targetValue = options[targetIndex];\n          if (targetValue !== undefined) {\n            setActiveDescendant(targetValue);\n            scrollOptionIntoView(targetValue);\n          }\n        },\n        selectActive: () => {\n          if (!activeDescendant) return false;\n\n          if (addNewOptionVisible && activeDescendant === searchTextTrimmed) {\n            onOptionSelect(searchTextTrimmed);\n            if (!multiple && onClose) {\n              onClose();\n            }\n            return true;\n          }\n\n          const option = filteredOptions.find(\n            (/** @type {OptionMatch} */ o) => o.value === activeDescendant,\n          );\n          if (option && !option.disabled) {\n            onOptionSelect(option.value, { toggleSelected: true });\n            if (!multiple && onClose) {\n              onClose();\n            }\n            return true;\n          }\n\n          return false;\n        },\n        getActiveDescendant: () => activeDescendant,\n        setActiveDescendant: (value) => {\n          setActiveDescendant(value);\n          scrollOptionIntoView(value);\n        },\n        clearActiveDescendant: () => setActiveDescendant(\"\"),\n      }),\n      [\n        activeDescendant,\n        getNavigableOptions,\n        scrollOptionIntoView,\n        addNewOptionVisible,\n        searchTextTrimmed,\n        filteredOptions,\n        onOptionSelect,\n        multiple,\n        onClose,\n      ],\n    );\n\n    useEffect(() => {\n      if (!isOpen) {\n        setActiveDescendant(\"\");\n      }\n    }, [isOpen]);\n\n    useEffect(() => {\n      onActiveDescendantChange?.(activeDescendant);\n    }, [activeDescendant, onActiveDescendantChange]);\n\n    const handleListRef = useCallback(\n      /** @param {HTMLUListElement | null} el */\n      (el) => {\n        listRef.current = el;\n        if (setDropdownRef && !shouldUseTray) {\n          setDropdownRef(el);\n        }\n      },\n      [setDropdownRef, shouldUseTray],\n    );\n\n    if (!isOpen) {\n      return null;\n    }\n\n    return (\n      // biome-ignore lint/a11y/useFocusableInteractive: <explanation>\n      <ul\n        className={[\n          \"PreactCombobox-options\",\n          `PreactCombobox--${theme}`,\n          shouldUseTray ? \"PreactCombobox-options--tray\" : \"\",\n        ]\n          .filter(Boolean)\n          .join(\" \")}\n        // biome-ignore lint/a11y/useSemanticElements: it is correct by examples I've found for comboboxes\n        role=\"listbox\"\n        id={`${id}-options-listbox`}\n        aria-multiselectable={multiple ? \"true\" : undefined}\n        hidden={!isOpen}\n        ref={handleListRef}\n      >\n        {isLoading ? (\n          <li className=\"PreactCombobox-option\" aria-disabled>\n            {loadingRenderer(translations.loadingOptions)}\n          </li>\n        ) : (\n          <>\n            {addNewOptionVisible && (\n              <li\n                key={searchTextTrimmed}\n                id={`${id}-option-${toHTMLId(searchTextTrimmed)}`}\n                className={`PreactCombobox-option ${activeDescendant === searchTextTrimmed ? \"PreactCombobox-option--active\" : \"\"}`}\n                // biome-ignore lint/a11y/useSemanticElements: parent is <ul> so want to keep equivalent semantics\n                role=\"option\"\n                tabIndex={-1}\n                aria-selected={false}\n                onMouseEnter={() => setActiveDescendant(searchTextTrimmed)}\n                onMouseDown={(e) => {\n                  e.preventDefault();\n                  e.stopPropagation();\n                  onOptionSelect(searchTextTrimmed);\n                  if (!multiple && onClose) {\n                    onClose();\n                  }\n                }}\n              >\n                {translations.addOption.replace(\"{value}\", searchTextTrimmed)}\n              </li>\n            )}\n            {filteredOptions.map((/** @type {OptionMatch} */ option) => {\n              const isActive = activeDescendant === option.value;\n              const isSelected = arrayValues.includes(option.value);\n              const isInvalid = invalidValues.includes(option.value);\n              const isDisabled = option.disabled;\n              const hasDivider = option.divider && !searchTextTrimmed;\n              const optionClasses = [\n                \"PreactCombobox-option\",\n                isActive ? \"PreactCombobox-option--active\" : \"\",\n                isSelected ? \"PreactCombobox-option--selected\" : \"\",\n                isInvalid ? \"PreactCombobox-option--invalid\" : \"\",\n                isDisabled ? \"PreactCombobox-option--disabled\" : \"\",\n                hasDivider ? \"PreactCombobox-option--divider\" : \"\",\n              ]\n                .filter(Boolean)\n                .join(\" \");\n              return (\n                <li\n                  key={option.value}\n                  id={`${id}-option-${toHTMLId(option.value)}`}\n                  className={optionClasses}\n                  // biome-ignore lint/a11y/useSemanticElements: <explanation>\n                  role=\"option\"\n                  tabIndex={-1}\n                  aria-selected={isSelected}\n                  aria-disabled={isDisabled}\n                  onMouseEnter={() => !isDisabled && setActiveDescendant(option.value)}\n                  onMouseDown={(e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onOptionSelect(option.value, { toggleSelected: true });\n                    if (!multiple && onClose) {\n                      onClose();\n                    }\n                  }}\n                >\n                  {optionRenderer({\n                    option,\n                    language,\n                    isActive,\n                    isSelected,\n                    isInvalid,\n                    showValue,\n                    warningIcon,\n                    tickIcon,\n                    optionIconRenderer,\n                  })}\n                  {isSelected ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"selected\"\n                      aria-hidden={!isActive}\n                    >\n                      {translations.selectedOption}\n                    </span>\n                  ) : null}\n                  {isInvalid ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"invalid\"\n                      aria-hidden={!isActive}\n                    >\n                      {translations.invalidOption}\n                    </span>\n                  ) : null}\n                </li>\n              );\n            })}\n            {filteredOptions.length === 0 &&\n              !isLoading &&\n              (!allowFreeText || !searchText || arrayValues.includes(searchText)) && (\n                <li className=\"PreactCombobox-option\">{translations.noOptionsFound}</li>\n              )}\n          </>\n        )}\n      </ul>\n    );\n  },\n);\n\nexport default OptionsListbox;\n", "/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/** @type {Record<string, LanguageCache>} */\nconst languageCache = {};\n\n/**\n * Converts any text into a valid HTML ID attribute value.\n * Returns empty string if text becomes empty after removing invalid characters.\n *\n * @param {string} text - The text to convert into an HTML ID\n * @returns {string} A valid HTML ID or empty string\n */\nexport function toHTMLId(text) {\n  // Remove any characters that are not letters, numbers, hyphens, underscores, colons, or periods\n  return text.replace(/[^a-zA-Z0-9\\-_:.]/g, \"\");\n}\n\n/**\n * @template {OptionMatch|Option} T\n * @param {T[]} options\n * @param {string[]} values\n * @returns {T[]}\n */\nexport function sortValuesToTop(options, values) {\n  const selectedSet = new Set(values);\n  return options.sort((a, b) => {\n    const aSelected = selectedSet.has(a.value);\n    const bSelected = selectedSet.has(b.value);\n    if (aSelected === bSelected) return 0;\n    return aSelected ? -1 : 1;\n  });\n}\n\n/**\n * @param {string} query\n * @param {Option} option\n * @param {string} language\n * @returns {OptionMatch|null}\n */\nfunction getExactMatchScore(query, option, language) {\n  const { label, value, ...rest } = option;\n  if (value === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (label === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  const { caseMatcher } = /** @type {LanguageCache} */ (languageCache[language]);\n  if (caseMatcher.compare(value, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (caseMatcher.compare(label, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  return null;\n}\n\n/**\n * Calculates the match score between a query text and a list of option labels.\n * It returns scores for each option sorted in descending order.\n *\n * It takes the `query` string, evaluates the following rules in order and assigns the one with highest score:\n * - Score 7: If whole query matches a label on an option (Case insensitive match)\n * - Score 5: Same as previous check but this time case and accent insensitive matching\n * - Score 3: Phrase matching (e.g. \"word1 partialWord2*\")\n * - Score 0-1: Number of words matched / total number of words in query (e.g. \"word1\")\n *\n * @param {string} query - The query text to match against options.\n * @param {Option[]} options\n * @param {string} [language='en'] Language to use for word splitting and matching\n * @param {boolean} [filterAndSort=true] Whether to filter and sort the results. If false, returns all options but with attempted matches.\n * @returns {Array<OptionMatch>}\n */\nexport function getMatchScore(query, options, language = \"en\", filterAndSort = true) {\n  // biome-ignore lint/style/noParameterAssign: ignore\n  query = query.trim();\n\n  if (!query) {\n    const matchSlices = /** @type {Array<[number, number]>} */ ([]);\n    return options.map((option) => ({\n      ...option,\n      label: option.label,\n      value: option.value,\n      score: 0,\n      matched: \"none\",\n      matchSlices,\n    }));\n  }\n\n  if (!languageCache[language]) {\n    languageCache[language] = {\n      baseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"base\",\n      }),\n      caseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"accent\",\n      }),\n      wordSegmenter: new Intl.Segmenter(language, {\n        granularity: \"word\",\n      }),\n    };\n  }\n  const { baseMatcher, caseMatcher, wordSegmenter } = languageCache[language];\n\n  const isCommaSeparated = query.includes(\",\");\n\n  let matches = options.map((option) => {\n    const { label, value, ...rest } = option;\n    if (isCommaSeparated) {\n      const querySegments = query.split(\",\");\n      const matches = querySegments\n        .map((querySegment) => getExactMatchScore(querySegment.trim(), option, language))\n        .filter((match) => match !== null)\n        .sort((a, b) => b.score - a.score);\n      return /** @type {OptionMatch} */ (\n        matches[0] || {\n          ...rest,\n          label,\n          value,\n          score: 0,\n          matched: \"none\",\n        }\n      );\n    }\n\n    // Rule 1: Exact match (case sensitive)\n    // Rule 2: Exact match (case insensitive)\n    const exactMatch = getExactMatchScore(query, option, language);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Rule 3: Exact match with accents normalized (case insensitive)\n    if (baseMatcher.compare(label, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'label'} */\n        matched: \"label\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, label.length]],\n      };\n    }\n    if (baseMatcher.compare(value, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, value.length]],\n      };\n    }\n\n    // Rule 4: Phrase match (imagine a wildcard query like \"word1 partialWord2*\")\n    // This match needs to be case and accent insensitive\n    const querySegments = Array.from(wordSegmenter.segment(query));\n    const labelWordSegments = Array.from(wordSegmenter.segment(label.trim()));\n    let len = 0;\n    let firstIndex = -1;\n    for (let i = 0; i < labelWordSegments.length; i++) {\n      const labelWordSegment = /** @type {Intl.SegmentData} */ (labelWordSegments[i]);\n      const querySegment = querySegments[len];\n      if (!querySegment) break;\n      if (len === querySegments.length - 1) {\n        // check for partial word match\n        // I can't use labelWordSegment.segment.startsWith(querySegment.segment) because it's case and accent sensitive\n        const lastQueryWord = querySegment.segment;\n        if (\n          baseMatcher.compare(\n            labelWordSegment.segment.slice(0, lastQueryWord.length),\n            lastQueryWord,\n          ) === 0\n        ) {\n          return {\n            ...rest,\n            label,\n            value,\n            score: 3,\n            /** @type {'label'} */\n            matched: \"label\",\n            /** @type {Array<[number, number]>} */\n            // @ts-ignore\n            matchSlices: [\n              [\n                firstIndex > -1 ? firstIndex : labelWordSegment.index,\n                labelWordSegment.index + lastQueryWord.length,\n              ],\n            ],\n          };\n        }\n      } else if (baseMatcher.compare(labelWordSegment.segment, querySegment.segment) === 0) {\n        len++;\n        if (len === 1) {\n          firstIndex = labelWordSegment.index;\n        }\n        continue;\n      }\n      len = 0;\n      firstIndex = -1;\n    }\n    // Also check for partial value match (this doesn't need accent check)\n    if (caseMatcher.compare(value.slice(0, query.length), query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 3,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, query.length]],\n      };\n    }\n\n    // Rule 5: Word matches\n    const queryWords = querySegments.filter((s) => s.isWordLike);\n    const labelWords = labelWordSegments.filter((s) => s.isWordLike);\n    /** @type {Array<[number, number]|undefined>} */\n    const slices = queryWords.map((word) => {\n      const match = labelWords.find(\n        (labelWord) => baseMatcher.compare(labelWord.segment, word.segment) === 0,\n      );\n      if (match) {\n        return [match.index, match.index + match.segment.length];\n      }\n    });\n    // TODO: Do we need a deep equal de-duplication here?\n    const matchSlices = slices.filter((s) => s !== undefined).sort((a, b) => a[0] - b[0]);\n    const wordScoring = matchSlices.length / queryWords.length;\n    return {\n      ...rest,\n      label,\n      value,\n      score: wordScoring,\n      /** @type {'label'|'none'} */\n      matched: wordScoring ? \"label\" : \"none\",\n      matchSlices,\n    };\n  });\n\n  if (filterAndSort) {\n    matches = matches.filter((match) => match.score > 0);\n    matches.sort((a, b) => {\n      if (a.score === b.score) {\n        const val = a.label.localeCompare(b.label, undefined, {\n          sensitivity: \"base\",\n        });\n        return val === 0 ? a.value.localeCompare(b.value, undefined, { sensitivity: \"base\" }) : val;\n      }\n      return b.score - a.score;\n    });\n  }\n  return matches;\n}\n\n/**\n * @param {OptionMatch['matchSlices']} matchSlices\n * @param {string} text\n * @returns {VNode[]}\n */\nexport function matchSlicesToNodes(matchSlices, text) {\n  const nodes = /** @type {VNode[]} */ ([]);\n  let index = 0;\n  matchSlices.map((slice) => {\n    const [start, end] = slice;\n    if (index < start) {\n      nodes.push(<span key={`${index}-${start}`}>{text.slice(index, start)}</span>);\n    }\n    nodes.push(<u key={`${start}-${end}`}>{text.slice(start, end)}</u>);\n    index = end;\n  });\n  if (index < text.length) {\n    nodes.push(<span key={`${index}-${text.length}`}>{text.slice(index)}</span>);\n  }\n  return nodes;\n}\n", "import { useCallback, useEffect, useRef, useState } from \"preact/hooks\";\nimport { subscribeToVirtualKeyboard } from \"./hooks.js\";\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Translations} Translations\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @typedef {Object} TraySearchListProps\n * @property {string} id - Component ID for ARIA attributes\n * @property {boolean} isOpen - Whether the tray is open\n * @property {() => void} onClose - Callback to close the tray\n * @property {string} [trayLabel] - Label for the tray header\n * @property {string} theme - Theme ('light' | 'dark' | 'system')\n * @property {Translations} translations - Translation strings\n * @property {(value: string) => void} onInputChange - Handle input change\n * @property {import(\"preact\").ComponentChildren} children - The AutocompleteList component\n */\n\n/**\n * TraySearchList component - handles mobile tray with search input and options list\n * @param {TraySearchListProps} props\n */\nconst TraySearchList = ({\n  id,\n  isOpen,\n  onClose,\n  trayLabel,\n  theme,\n  translations,\n  onInputChange,\n  children,\n}) => {\n  // Tray-specific state\n  const [trayInputValue, setTrayInputValue] = useState(\"\");\n  const [virtualKeyboardHeight, setVirtualKeyboardHeight] = useState(0);\n  const trayInputRef = useRef(/** @type {HTMLInputElement | null} */ (null));\n  const trayModalRef = useRef(/** @type {HTMLDivElement | null} */ (null));\n  const originalOverflowRef = useRef(\"\");\n  const virtualKeyboardHeightAdjustSubscription = useRef(/** @type {function | null} */ (null));\n  const virtualKeyboardExplicitlyClosedRef = useRef(false);\n  const readonlyResetTimeoutRef = useRef(\n    /** @type {ReturnType<typeof setTimeout> | null} */ (null),\n  );\n\n  // Handle tray input change\n  const handleTrayInputChange = useCallback(\n    /**\n     * @param {import('preact/compat').ChangeEvent<HTMLInputElement>} e\n     */\n    (e) => {\n      const value = e.currentTarget.value;\n      setTrayInputValue(value);\n      onInputChange(value);\n    },\n    [onInputChange],\n  );\n\n  const preventKeyboardReopenOnOptionTap = useCallback(() => {\n    const input = trayInputRef.current;\n    if (!input) return;\n    const shouldTemporarilyDisableInput =\n      virtualKeyboardExplicitlyClosedRef.current === true && document.activeElement === input;\n    if (!shouldTemporarilyDisableInput) return;\n    input.setAttribute(\"readonly\", \"readonly\");\n    if (readonlyResetTimeoutRef.current) {\n      clearTimeout(readonlyResetTimeoutRef.current);\n    }\n    readonlyResetTimeoutRef.current = setTimeout(() => {\n      input.removeAttribute(\"readonly\");\n      readonlyResetTimeoutRef.current = null;\n    }, 10);\n  }, []);\n\n  // Handle tray close\n  const handleClose = useCallback(() => {\n    setTrayInputValue(\"\");\n    setVirtualKeyboardHeight(0);\n    virtualKeyboardExplicitlyClosedRef.current = false;\n    virtualKeyboardHeightAdjustSubscription.current?.();\n    virtualKeyboardHeightAdjustSubscription.current = null;\n    if (readonlyResetTimeoutRef.current) {\n      clearTimeout(readonlyResetTimeoutRef.current);\n      readonlyResetTimeoutRef.current = null;\n    }\n    trayInputRef.current?.removeAttribute(\"readonly\");\n\n    // Restore original overflow\n    const scrollingElement = /** @type {HTMLElement} */ (\n      document.scrollingElement || document.documentElement\n    );\n    scrollingElement.style.overflow = originalOverflowRef.current;\n\n    onClose();\n  }, [onClose]);\n\n  // Setup virtual keyboard subscription and overflow handling when tray opens\n  useEffect(() => {\n    if (isOpen) {\n      // Get the scrolling element (body or html)\n      const scrollingElement = /** @type {HTMLElement} */ (\n        document.scrollingElement || document.documentElement\n      );\n\n      // Save original overflow and apply hidden\n      originalOverflowRef.current = scrollingElement.style.overflow;\n      scrollingElement.style.overflow = \"hidden\";\n\n      // Subscribe to virtual keyboard for tray\n      if (!virtualKeyboardHeightAdjustSubscription.current) {\n        virtualKeyboardHeightAdjustSubscription.current = subscribeToVirtualKeyboard({\n          heightCallback(keyboardHeight, isVisible) {\n            setVirtualKeyboardHeight(isVisible ? keyboardHeight : 0);\n            virtualKeyboardExplicitlyClosedRef.current = !isVisible;\n          },\n        });\n      }\n\n      // Focus the input when tray opens\n      trayInputRef.current?.focus();\n    }\n  }, [isOpen]);\n\n  // Clean up when component unmounts or tray closes\n  useEffect(() => {\n    return () => {\n      if (virtualKeyboardHeightAdjustSubscription.current) {\n        virtualKeyboardHeightAdjustSubscription.current();\n        virtualKeyboardHeightAdjustSubscription.current = null;\n      }\n      if (readonlyResetTimeoutRef.current) {\n        clearTimeout(readonlyResetTimeoutRef.current);\n        readonlyResetTimeoutRef.current = null;\n      }\n      trayInputRef.current?.removeAttribute(\"readonly\");\n      virtualKeyboardExplicitlyClosedRef.current = false;\n    };\n  }, []);\n\n  // Children contains the SearchableList component\n\n  if (!isOpen) {\n    return null;\n  }\n\n  return (\n    // I couldn't use native <dialog> element because trying to focus input right\n    // after dialog.close() doesn't seem to work on Chrome (Android).\n    <div\n      ref={trayModalRef}\n      className={`PreactCombobox-modal ${`PreactCombobox--${theme}`}`}\n      style={{ display: isOpen ? null : \"none\" }}\n      onClick={(e) => {\n        // Close modal when clicking backdrop\n        if (e.target === trayModalRef.current) {\n          handleClose();\n        }\n      }}\n      onKeyDown={(e) => {\n        if (e.key === \"Escape\") {\n          handleClose();\n        }\n      }}\n      // biome-ignore lint/a11y/useSemanticElements: Custom modal implementation instead of dialog element\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby={trayLabel ? `${id}-tray-label` : undefined}\n      tabIndex={-1}\n    >\n      <div className={`PreactCombobox-tray ${`PreactCombobox--${theme}`}`}>\n        <div className=\"PreactCombobox-trayHeader\">\n          {trayLabel && (\n            <label\n              id={`${id}-tray-label`}\n              className=\"PreactCombobox-trayLabel\"\n              htmlFor={`${id}-tray-input`}\n            >\n              {trayLabel}\n            </label>\n          )}\n          <input\n            id={`${id}-tray-input`}\n            ref={trayInputRef}\n            type=\"text\"\n            value={trayInputValue}\n            placeholder={translations.searchPlaceholder}\n            onChange={handleTrayInputChange}\n            onKeyDown={(e) => {\n              if (e.key === \"Escape\") {\n                handleClose();\n              }\n            }}\n            className={`PreactCombobox-trayInput ${!trayLabel ? \"PreactCombobox-trayInput--noLabel\" : \"\"}`}\n            role=\"combobox\"\n            aria-expanded=\"true\"\n            aria-haspopup=\"listbox\"\n            aria-controls={`${id}-options-listbox`}\n            aria-label={trayLabel || translations.searchPlaceholder}\n            autoComplete=\"off\"\n          />\n        </div>\n        <div\n          onMouseDownCapture={preventKeyboardReopenOnOptionTap}\n          onTouchStartCapture={preventKeyboardReopenOnOptionTap}\n        >\n          {children}\n        </div>\n        {virtualKeyboardHeight > 0 && (\n          <div\n            className=\"PreactCombobox-virtualKeyboardSpacer\"\n            style={{ height: `${virtualKeyboardHeight}px` }}\n            aria-hidden=\"true\"\n          />\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TraySearchList;\n", "import { useCallback, useEffect, useMemo, useRef, useState } from \"preact/hooks\";\nimport { getMatchScore, sortValuesToTop } from \"./utils.jsx\";\n\n/**\n * Returns a ref that always holds the latest value.\n * Useful for accessing current values in effects without adding them to deps.\n * Similar to React's experimental useEffectEvent.\n * @template {any[] | ((...args: any[]) => any)} T\n * @param {T} value\n * @returns {T}\n */\n// function useEffectEvent(value) {\n//   const ref = useRef(value);\n//   ref.current = value;\n//   /** @type {{ current: T }} */\n//   // @ts-ignore\n//   // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n//   const stableRef = useMemo(() => {\n//     // @ts-ignore\n//     return typeof ref.current === 'function' ? { current: (...args) => ref.current(...args) } : ref;\n//   }, [typeof ref.current]);\n//   return stableRef.current;\n// }\n\n/**\n * @param {any} value1\n * @param {any} value2\n * @returns {boolean}\n */\nexport function isEqual(value1, value2) {\n  // Handle circular references using WeakMap\n  const seenA = new WeakMap();\n  const seenB = new WeakMap();\n\n  /**\n   * @param {any} a\n   * @param {any} b\n   * @returns {boolean}\n   */\n  function deepCompare(a, b) {\n    // Handle primitives\n    if (Object.is(a, b)) return true;\n    if (a === null || b === null || typeof a !== \"object\" || typeof b !== \"object\") {\n      return a === b;\n    }\n\n    // Handle React/JSX elements - direct reference comparison since they're immutable\n    // This prevents unnecessary deep comparisons\n    if (a.$$typeof === Symbol.for(\"react.element\") || b.$$typeof === Symbol.for(\"react.element\")) {\n      return a === b;\n    }\n\n    // Handle different types\n    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n      return false;\n    }\n\n    // Check for circular references\n    if (seenA.has(a)) return seenA.get(a) === b;\n    if (seenB.has(b)) return seenB.get(b) === a;\n    // detect cross object circular references\n    if (seenA.has(b) || seenB.has(a)) return false;\n    seenA.set(a, b);\n    seenB.set(b, a);\n\n    // Handle Arrays\n    if (Array.isArray(a)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      return a.every((item, index) => deepCompare(item, b[index]));\n    }\n\n    // Handle Dates\n    if (a instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n\n    // Handle RegExp\n    if (a instanceof RegExp) {\n      return a.toString() === b.toString();\n    }\n\n    // Handle Objects\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    return keysA.every((key) => keysB.includes(key) && deepCompare(a[key], b[key]));\n  }\n\n  return deepCompare(value1, value2);\n}\n\n/**\n * Both dependencies and state are compared using a deep equality function.\n * @template T\n * @param {T} newState\n * @returns {T}\n */\nexport function useDeepMemo(newState) {\n  const state = useRef(/** @type {T} */ (null));\n  if (!isEqual(newState, state.current)) {\n    state.current = newState;\n  }\n  return state.current;\n}\n\n/**\n * @template T\n * @param {T} initialValue\n * @returns {[() => T, (value: T) => void, boolean]}\n */\nexport function useLive(initialValue) {\n  const [refreshValue, forceRefresh] = useState(0);\n  const ref = useRef(initialValue);\n\n  // refreshValue is used to create a new getter so that any useEffect etc that depends on it will be re-run\n  // In addition, provide `hasValueChanged` to help detect in a multi-dependency useEffect whether this specific\n  // state has changed.\n  let hasValueChanged = false;\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explanation above\n  const getValue = useMemo(() => {\n    hasValueChanged = true;\n    return () => ref.current;\n  }, [refreshValue]);\n\n  // setter doesn't need to be created on every render\n  const setValue = useCallback(\n    /** @param {T} value */\n    (value) => {\n      if (value !== ref.current) {\n        ref.current = value;\n        forceRefresh((x) => x + 1);\n      }\n    },\n    [],\n  );\n\n  return [getValue, setValue, hasValueChanged];\n}\n\nconst isTouchDevice =\n  typeof window !== \"undefined\" && window.matchMedia?.(\"(pointer: coarse)\")?.matches;\n// Since page hasn't potentially fully loaded yet we get only an approximate height\nconst visualViewportInitialHeight = window.visualViewport?.height ?? 0;\n\n/**\n * Subscribe to virtual keyboard visibility changes (touch devices only)\n * @param {Object} params - Parameters for subscribing to virtual keyboard\n * @param {function(boolean): void} [params.visibleCallback] - Called with boolean when keyboard visibility changes\n * @param {function(number, boolean): void} [params.heightCallback] - Called with keyboard height when keyboard height changes\n * @returns {function | null} - Unsubscribe function\n */\nexport function subscribeToVirtualKeyboard({ visibleCallback, heightCallback }) {\n  if (!isTouchDevice || typeof window === \"undefined\" || !window.visualViewport) return null;\n\n  let isVisible = false;\n  const handleViewportResize = () => {\n    if (!window.visualViewport) return;\n    const heightDiff = visualViewportInitialHeight - window.visualViewport.height;\n    const isVisibleNow = heightDiff > 150;\n    if (isVisible !== isVisibleNow) {\n      isVisible = isVisibleNow;\n      visibleCallback?.(isVisible);\n    }\n    heightCallback?.(heightDiff, isVisible);\n  };\n  window.visualViewport.addEventListener(\"resize\", handleViewportResize, { passive: true });\n  return () => {\n    window.visualViewport?.removeEventListener(\"resize\", handleViewportResize);\n  };\n}\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n */\n\n/**\n * @typedef {Object} UseAsyncOptionsParams\n * @property {Option[] | ((queryOrValues: string[] | string, limit: number, currentSelections: string[], abortControllerSignal: AbortSignal) => Promise<Option[]>)} allowedOptions\n * @property {string[]} selectedValues - Currently selected values that need labels resolved\n * @property {string} searchText - Current search query\n * @property {boolean} isOpen - Whether the dropdown is open (triggers search fetching)\n * @property {string} language - Language code for matching\n * @property {number} maxNumberOfPresentedOptions - Max options to fetch/display\n */\n\n/**\n * @typedef {Object} UseAsyncOptionsResult\n * @property {OptionMatch[]} filteredOptions - Options to display (filtered/searched)\n * @property {{ [value: string]: Option }} resolvedOptionsLookup - Lookup for all resolved options (for labels)\n * @property {boolean} isLoading - Whether options are currently being fetched\n */\n\n// @ts-ignore\nconst isPlaywright = typeof navigator !== \"undefined\" && navigator.webdriver === true;\n\n/**\n * Hook that handles async option fetching, caching, and filtering.\n * - Resolves labels for selected values even when dropdown is closed\n * - Handles search/filtering when dropdown is open\n * - Supports both array-based (local filtering) and function-based (remote filtering)\n *\n * @param {UseAsyncOptionsParams} params\n * @returns {UseAsyncOptionsResult}\n */\nexport function useAsyncOptions({\n  allowedOptions: allowedOptionsOriginal,\n  selectedValues: selectedValuesOriginal,\n  searchText,\n  isOpen,\n  language,\n  maxNumberOfPresentedOptions,\n}) {\n  const [filteredOptions, setFilteredOptions] = useState(/** @type {OptionMatch[]} */ ([]));\n  const [isLoading, setIsLoading] = useState(false);\n  const [cacheVersion, setCacheVersion] = useState(0);\n  const cachedOptions = useRef(/** @type {{ [value: string]: Option }} */ ({}));\n  const abortControllerRef = useRef(/** @type {AbortController | null} */ (null));\n  const debounceTimerRef = useRef(/** @type {ReturnType<typeof setTimeout> | null} */ (null));\n  // Track if this is the first time isOpen became true (to skip debounce on first open)\n  const wasOpenRef = useRef(false);\n\n  const searchTextTrimmed = searchText.trim();\n  const isFunction = typeof allowedOptionsOriginal === \"function\";\n  // For functions: use the ref (stable); for arrays: deep-memoize\n  const allowedOptions = useDeepMemo(allowedOptionsOriginal);\n  // selectedValues is always an array, deep-memoize for stable reference\n  const selectedValues = useDeepMemo(selectedValuesOriginal);\n\n  const updateCachedOptions = useCallback(\n    /** @param {Option[]} update */\n    (update) => {\n      let hasChanged = false;\n      for (const item of update) {\n        if (\n          !cachedOptions.current[item.value] ||\n          !isEqual(cachedOptions.current[item.value], item)\n        ) {\n          hasChanged = true;\n          cachedOptions.current[item.value] = item;\n        }\n      }\n      if (hasChanged) {\n        setCacheVersion((v) => v + 1);\n      }\n    },\n    [],\n  );\n\n  // useExhaustiveDependencies rule: cacheVersion is reliable way to figure out of cache changed\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  const resolvedOptionsLookup = useMemo(() => {\n    if (Array.isArray(allowedOptions)) {\n      return allowedOptions.reduce(\n        (acc, o) => {\n          acc[o.value] = o;\n          return acc;\n        },\n        /** @type {{ [value: string]: Option }} */ ({}),\n      );\n    }\n    return { ...cachedOptions.current };\n  }, [allowedOptions, cacheVersion]);\n\n  // useExhaustiveDependencies rule: cacheVersion is reliable way to figure out of cache changed\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  const unresolvedValues = useMemo(\n    () => selectedValues.filter((v) => !resolvedOptionsLookup[v]),\n    [selectedValues, cacheVersion],\n  );\n\n  // useExhaustiveDependencies rule is wrong here. fetch() should only be called\n  // if there is a selected value with unknown label. Especially assume selected\n  // values shows up in the parent combobox's text field, and that's why we need\n  // to find the label for them.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  useEffect(() => {\n    if (!isFunction) return;\n    if (unresolvedValues.length === 0) return;\n\n    const fetchOptions = /**\n     * @type {(\n     *  queryOrValues: string[]\n     *  | string, limit: number, currentSelections: string[], signal: AbortSignal\n     * ) => Promise<Option[]>}\n     */ (allowedOptions);\n    const currentSelectedValues = selectedValues;\n    const abortController = new AbortController();\n\n    fetchOptions(\n      unresolvedValues,\n      unresolvedValues.length,\n      currentSelectedValues,\n      abortController.signal,\n    )\n      .then((results) => {\n        if (abortController.signal.aborted) return;\n        if (results?.length) {\n          updateCachedOptions(results);\n        }\n        const stillUnresolved = unresolvedValues.filter(\n          (v) => !results?.find((r) => r.value === v),\n        );\n        if (stillUnresolved.length > 0) {\n          updateCachedOptions(stillUnresolved.map((v) => ({ label: v, value: v })));\n        }\n      })\n      .catch((error) => {\n        if (abortController.signal.aborted) return;\n        console.error(\"Failed to resolve option labels:\", error);\n        updateCachedOptions(unresolvedValues.map((v) => ({ label: v, value: v })));\n      });\n\n    return () => abortController.abort();\n  }, [\n    // effect should only run when there is selected values with unknown labels\n    unresolvedValues.length > 0, // selectValues doesn't need to be a dependency\n    // this effect only applies to remote fetches, i.e. only when allowedOptions is a function.\n    isFunction ? allowedOptions : null,\n    updateCachedOptions,\n  ]);\n\n  // About useExhaustiveDependencies: selectedValues doesn't need to be dependency\n  // as explained in the useEffect above. Furthermore you don't want to be\n  // re-ordering the dropdown list when user is selecting things. Re-ordering can\n  // be done the next time user opens up the dropdown.\n  //\n  // resolvedOptionsLookup doesn't need to be dependency because when allowedOptions is:\n  // 1. array: then it is computed correctly and immediately. It's already tied\n  // to allowedOptions, which is already a dependency.\n  // 2. function: then resolvedOptionsLookup is not evn used and cachedOption.current\n  // is used instead.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explained above\n  useEffect(() => {\n    abortControllerRef.current?.abort();\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current);\n      debounceTimerRef.current = null;\n    }\n\n    if (!isOpen) {\n      setFilteredOptions([]);\n      setIsLoading(false);\n      wasOpenRef.current = false;\n      return;\n    }\n\n    // Track if this is the first time dropdown opened (to skip debounce)\n    const isFirstOpen = !wasOpenRef.current;\n    wasOpenRef.current = true;\n\n    if (isFunction) {\n      const fetchFn =\n        /** @type {(queryOrValues: string[] | string, limit: number, currentSelections: string[], signal: AbortSignal) => Promise<Option[]>} */ (\n          allowedOptions\n        );\n      const currentSelectedValues = selectedValues;\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n\n      // Lower debounce time for playwright to speed up tests\n      let debounceTime = isPlaywright ? 5 : 250;\n      // Skip debounce on first open\n      if (isFirstOpen) debounceTime = 0;\n\n      setIsLoading(true);\n\n      const fetchOptions = async () => {\n        try {\n          const results = await fetchFn(\n            searchTextTrimmed,\n            maxNumberOfPresentedOptions,\n            currentSelectedValues,\n            abortController.signal,\n          );\n\n          if (abortController.signal.aborted) return;\n\n          if (results?.length) {\n            updateCachedOptions(results);\n          }\n\n          let updatedOptions = results || [];\n          if (!searchTextTrimmed) {\n            const unreturnedSelectedValues = currentSelectedValues\n              .filter((v) => !results?.find((r) => r.value === v))\n              .filter((v) => !cachedOptions.current[v])\n              .map((v) => ({ label: v, value: v }));\n            if (unreturnedSelectedValues.length > 0) {\n              updateCachedOptions(unreturnedSelectedValues);\n              updatedOptions = unreturnedSelectedValues.concat(results || []);\n            }\n          }\n\n          const options = searchTextTrimmed\n            ? updatedOptions\n            : sortValuesToTop(updatedOptions, currentSelectedValues);\n\n          setFilteredOptions(getMatchScore(searchTextTrimmed, options, language, false));\n          setIsLoading(false);\n        } catch (error) {\n          if (abortController.signal.aborted) return;\n          setIsLoading(false);\n          throw error;\n        }\n      };\n\n      if (debounceTime > 0) {\n        debounceTimerRef.current = setTimeout(fetchOptions, debounceTime);\n      } else {\n        fetchOptions();\n      }\n\n      return () => {\n        abortController.abort();\n        if (debounceTimerRef.current) {\n          clearTimeout(debounceTimerRef.current);\n        }\n      };\n      // biome-ignore lint/style/noUselessElse: I want it that way!\n    } else {\n      // Array-based options: filter locally\n      const arrayOptions = /** @type {Option[]} */ (allowedOptions);\n      const currentSelectedValues = selectedValues;\n      const mergedOptions = currentSelectedValues\n        .filter((v) => !resolvedOptionsLookup[v])\n        .map((v) => ({ label: v, value: v }))\n        .concat(arrayOptions);\n\n      const options = searchText\n        ? mergedOptions\n        : sortValuesToTop(mergedOptions, currentSelectedValues);\n\n      setFilteredOptions(getMatchScore(searchText, options, language, true));\n    }\n  }, [\n    isOpen,\n    searchTextTrimmed,\n    searchText,\n    language,\n    unresolvedValues.length > 0, // selectValues doesn't need to be a dependency as explained above\n    isFunction,\n    allowedOptions,\n    // resolvedOptionsLookup doesn't need to be dependency as explained above\n    maxNumberOfPresentedOptions,\n    updateCachedOptions,\n  ]);\n\n  return {\n    filteredOptions,\n    resolvedOptionsLookup,\n    isLoading,\n  };\n}\n"],
  "mappings": ";AAAA,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B;AAAA,EACE,eAAAA;AAAA,EACA,aAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAAC;AAAA,EACA,UAAAC;AAAA,EACA,YAAAC;AAAA,OACK;;;ACVP,SAAS,kBAAkB;AAC3B,SAAS,aAAa,WAAW,qBAAqB,QAAQ,gBAAgB;;;ACkU7D;AApTjB,IAAM,gBAAgB,CAAC;AAShB,SAAS,SAAS,MAAM;AAE7B,SAAO,KAAK,QAAQ,sBAAsB,EAAE;AAC9C;AAQO,SAAS,gBAAgB,SAAS,QAAQ;AAC/C,QAAM,cAAc,IAAI,IAAI,MAAM;AAClC,SAAO,QAAQ,KAAK,CAAC,GAAG,MAAM;AAC5B,UAAM,YAAY,YAAY,IAAI,EAAE,KAAK;AACzC,UAAM,YAAY,YAAY,IAAI,EAAE,KAAK;AACzC,QAAI,cAAc,UAAW,QAAO;AACpC,WAAO,YAAY,KAAK;AAAA,EAC1B,CAAC;AACH;AAQA,SAAS,mBAAmB,OAAO,QAAQ,UAAU;AACnD,QAAM,EAAE,OAAO,OAAO,GAAG,KAAK,IAAI;AAClC,MAAI,UAAU,OAAO;AACnB,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,MACA;AAAA,MACA,OAAO;AAAA;AAAA,MAEP,SAAS;AAAA;AAAA,MAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,IACjC;AAAA,EACF;AACA,MAAI,UAAU,OAAO;AACnB,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,MACA;AAAA,MACA,OAAO;AAAA;AAAA,MAEP,SAAS;AAAA;AAAA,MAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,IACjC;AAAA,EACF;AAEA,QAAM,EAAE,YAAY;AAAA;AAAA,IAAkC,cAAc,QAAQ;AAAA;AAC5E,MAAI,YAAY,QAAQ,OAAO,KAAK,MAAM,GAAG;AAC3C,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,MACA;AAAA,MACA,OAAO;AAAA;AAAA,MAEP,SAAS;AAAA;AAAA,MAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,IACjC;AAAA,EACF;AACA,MAAI,YAAY,QAAQ,OAAO,KAAK,MAAM,GAAG;AAC3C,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,MACA;AAAA,MACA,OAAO;AAAA;AAAA,MAEP,SAAS;AAAA;AAAA,MAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,IACjC;AAAA,EACF;AAEA,SAAO;AACT;AAkBO,SAAS,cAAc,OAAO,SAAS,WAAW,MAAM,gBAAgB,MAAM;AAEnF,UAAQ,MAAM,KAAK;AAEnB,MAAI,CAAC,OAAO;AACV,UAAM;AAAA;AAAA,MAAsD,CAAC;AAAA;AAC7D,WAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,MAC9B,GAAG;AAAA,MACH,OAAO,OAAO;AAAA,MACd,OAAO,OAAO;AAAA,MACd,OAAO;AAAA,MACP,SAAS;AAAA,MACT;AAAA,IACF,EAAE;AAAA,EACJ;AAEA,MAAI,CAAC,cAAc,QAAQ,GAAG;AAC5B,kBAAc,QAAQ,IAAI;AAAA,MACxB,aAAa,IAAI,KAAK,SAAS,UAAU;AAAA,QACvC,OAAO;AAAA,QACP,aAAa;AAAA,MACf,CAAC;AAAA,MACD,aAAa,IAAI,KAAK,SAAS,UAAU;AAAA,QACvC,OAAO;AAAA,QACP,aAAa;AAAA,MACf,CAAC;AAAA,MACD,eAAe,IAAI,KAAK,UAAU,UAAU;AAAA,QAC1C,aAAa;AAAA,MACf,CAAC;AAAA,IACH;AAAA,EACF;AACA,QAAM,EAAE,aAAa,aAAa,cAAc,IAAI,cAAc,QAAQ;AAE1E,QAAM,mBAAmB,MAAM,SAAS,GAAG;AAE3C,MAAI,UAAU,QAAQ,IAAI,CAAC,WAAW;AACpC,UAAM,EAAE,OAAO,OAAO,GAAG,KAAK,IAAI;AAClC,QAAI,kBAAkB;AACpB,YAAMC,iBAAgB,MAAM,MAAM,GAAG;AACrC,YAAMC,WAAUD,eACb,IAAI,CAAC,iBAAiB,mBAAmB,aAAa,KAAK,GAAG,QAAQ,QAAQ,CAAC,EAC/E,OAAO,CAAC,UAAU,UAAU,IAAI,EAChC,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AACnC;AAAA;AAAA,QACEC,SAAQ,CAAC,KAAK;AAAA,UACZ,GAAG;AAAA,UACH;AAAA,UACA;AAAA,UACA,OAAO;AAAA,UACP,SAAS;AAAA,QACX;AAAA;AAAA,IAEJ;AAIA,UAAM,aAAa,mBAAmB,OAAO,QAAQ,QAAQ;AAC7D,QAAI,YAAY;AACd,aAAO;AAAA,IACT;AAGA,QAAI,YAAY,QAAQ,OAAO,KAAK,MAAM,GAAG;AAC3C,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QACA,OAAO;AAAA;AAAA,QAEP,SAAS;AAAA;AAAA,QAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,MACjC;AAAA,IACF;AACA,QAAI,YAAY,QAAQ,OAAO,KAAK,MAAM,GAAG;AAC3C,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QACA,OAAO;AAAA;AAAA,QAEP,SAAS;AAAA;AAAA,QAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,MACjC;AAAA,IACF;AAIA,UAAM,gBAAgB,MAAM,KAAK,cAAc,QAAQ,KAAK,CAAC;AAC7D,UAAM,oBAAoB,MAAM,KAAK,cAAc,QAAQ,MAAM,KAAK,CAAC,CAAC;AACxE,QAAI,MAAM;AACV,QAAI,aAAa;AACjB,aAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AACjD,YAAM;AAAA;AAAA,QAAoD,kBAAkB,CAAC;AAAA;AAC7E,YAAM,eAAe,cAAc,GAAG;AACtC,UAAI,CAAC,aAAc;AACnB,UAAI,QAAQ,cAAc,SAAS,GAAG;AAGpC,cAAM,gBAAgB,aAAa;AACnC,YACE,YAAY;AAAA,UACV,iBAAiB,QAAQ,MAAM,GAAG,cAAc,MAAM;AAAA,UACtD;AAAA,QACF,MAAM,GACN;AACA,iBAAO;AAAA,YACL,GAAG;AAAA,YACH;AAAA,YACA;AAAA,YACA,OAAO;AAAA;AAAA,YAEP,SAAS;AAAA;AAAA;AAAA,YAGT,aAAa;AAAA,cACX;AAAA,gBACE,aAAa,KAAK,aAAa,iBAAiB;AAAA,gBAChD,iBAAiB,QAAQ,cAAc;AAAA,cACzC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF,WAAW,YAAY,QAAQ,iBAAiB,SAAS,aAAa,OAAO,MAAM,GAAG;AACpF;AACA,YAAI,QAAQ,GAAG;AACb,uBAAa,iBAAiB;AAAA,QAChC;AACA;AAAA,MACF;AACA,YAAM;AACN,mBAAa;AAAA,IACf;AAEA,QAAI,YAAY,QAAQ,MAAM,MAAM,GAAG,MAAM,MAAM,GAAG,KAAK,MAAM,GAAG;AAClE,aAAO;AAAA,QACL,GAAG;AAAA,QACH;AAAA,QACA;AAAA,QACA,OAAO;AAAA;AAAA,QAEP,SAAS;AAAA;AAAA,QAET,aAAa,CAAC,CAAC,GAAG,MAAM,MAAM,CAAC;AAAA,MACjC;AAAA,IACF;AAGA,UAAM,aAAa,cAAc,OAAO,CAAC,MAAM,EAAE,UAAU;AAC3D,UAAM,aAAa,kBAAkB,OAAO,CAAC,MAAM,EAAE,UAAU;AAE/D,UAAM,SAAS,WAAW,IAAI,CAAC,SAAS;AACtC,YAAM,QAAQ,WAAW;AAAA,QACvB,CAAC,cAAc,YAAY,QAAQ,UAAU,SAAS,KAAK,OAAO,MAAM;AAAA,MAC1E;AACA,UAAI,OAAO;AACT,eAAO,CAAC,MAAM,OAAO,MAAM,QAAQ,MAAM,QAAQ,MAAM;AAAA,MACzD;AAAA,IACF,CAAC;AAED,UAAM,cAAc,OAAO,OAAO,CAAC,MAAM,MAAM,MAAS,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AACpF,UAAM,cAAc,YAAY,SAAS,WAAW;AACpD,WAAO;AAAA,MACL,GAAG;AAAA,MACH;AAAA,MACA;AAAA,MACA,OAAO;AAAA;AAAA,MAEP,SAAS,cAAc,UAAU;AAAA,MACjC;AAAA,IACF;AAAA,EACF,CAAC;AAED,MAAI,eAAe;AACjB,cAAU,QAAQ,OAAO,CAAC,UAAU,MAAM,QAAQ,CAAC;AACnD,YAAQ,KAAK,CAAC,GAAG,MAAM;AACrB,UAAI,EAAE,UAAU,EAAE,OAAO;AACvB,cAAM,MAAM,EAAE,MAAM,cAAc,EAAE,OAAO,QAAW;AAAA,UACpD,aAAa;AAAA,QACf,CAAC;AACD,eAAO,QAAQ,IAAI,EAAE,MAAM,cAAc,EAAE,OAAO,QAAW,EAAE,aAAa,OAAO,CAAC,IAAI;AAAA,MAC1F;AACA,aAAO,EAAE,QAAQ,EAAE;AAAA,IACrB,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAOO,SAAS,mBAAmB,aAAa,MAAM;AACpD,QAAM;AAAA;AAAA,IAAgC,CAAC;AAAA;AACvC,MAAI,QAAQ;AACZ,cAAY,IAAI,CAAC,UAAU;AACzB,UAAM,CAAC,OAAO,GAAG,IAAI;AACrB,QAAI,QAAQ,OAAO;AACjB,YAAM,KAAK,oBAAC,UAAgC,eAAK,MAAM,OAAO,KAAK,KAA7C,GAAG,KAAK,IAAI,KAAK,EAA8B,CAAO;AAAA,IAC9E;AACA,UAAM,KAAK,oBAAC,OAA2B,eAAK,MAAM,OAAO,GAAG,KAAzC,GAAG,KAAK,IAAI,GAAG,EAA4B,CAAI;AAClE,YAAQ;AAAA,EACV,CAAC;AACD,MAAI,QAAQ,KAAK,QAAQ;AACvB,UAAM,KAAK,oBAAC,UAAsC,eAAK,MAAM,KAAK,KAA5C,GAAG,KAAK,IAAI,KAAK,MAAM,EAAuB,CAAO;AAAA,EAC7E;AACA,SAAO;AACT;;;ADzBU,SAIA,UAJA,OAAAC,MA4CM,YA5CN;AAzPV,IAAM,iBAAiB;AAAA,EACrB,CAEE;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GACA,QACG;AACH,UAAM,CAAC,kBAAkB,mBAAmB,IAAI,SAAS,EAAE;AAC3D,UAAM,UAAU;AAAA;AAAA,MAA+C;AAAA,IAAK;AAEpE,UAAM,oBAAoB,WAAW,KAAK;AAE1C,UAAM,sBACJ,CAAC,aACD,iBACA,qBACA,CAAC,YAAY,SAAS,iBAAiB,KACvC,CAAC,gBAAgB,KAAK,CAA4B,MAAM,EAAE,UAAU,iBAAiB;AAEvF,UAAM,uBAAuB;AAAA;AAAA,MAE3B,CAAC,gBAAgB;AACf,YAAI,CAAC,QAAQ,WAAW,CAAC,YAAa;AACtC,cAAM,YAAY,GAAG,EAAE,WAAW,SAAS,WAAW,CAAC;AACvD,cAAM,UAAU,QAAQ,QAAQ,cAAc,IAAI,IAAI,OAAO,SAAS,CAAC,EAAE;AACzE,YAAI,SAAS;AACX,gBAAM,WAAW,QAAQ,QAAQ,sBAAsB;AACvD,gBAAM,WAAW,QAAQ,sBAAsB;AAG/C,cAAI,SAAS,SAAS,SAAS,QAAQ;AACrC,oBAAQ,QAAQ,aAAa,SAAS,SAAS,SAAS;AAAA,UAC1D,WAAW,SAAS,MAAM,SAAS,KAAK;AACtC,oBAAQ,QAAQ,aAAa,SAAS,MAAM,SAAS;AAAA,UACvD;AAAA,QACF;AAAA,MACF;AAAA,MACA,CAAC,EAAE;AAAA,IACL;AAEA,UAAM,sBAAsB,YAAY,MAAM;AAC5C,YAAM,UAAU,gBACb,OAAO,CAA4B,MAAM,CAAC,EAAE,QAAQ,EACpD,IAAI,CAA4B,MAAM,EAAE,KAAK;AAChD,UAAI,qBAAqB;AACvB,eAAO,CAAC,mBAAmB,GAAG,OAAO;AAAA,MACvC;AACA,aAAO;AAAA,IACT,GAAG,CAAC,iBAAiB,qBAAqB,iBAAiB,CAAC;AAE5D;AAAA,MACE;AAAA,MACA,OAAO;AAAA,QACL,cAAc,MAAM;AAClB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAE1B,gBAAM,eAAe,mBAAmB,QAAQ,QAAQ,gBAAgB,IAAI;AAC5E,gBAAM,YAAY,iBAAiB,QAAQ,SAAS,IAAI,IAAI,eAAe;AAC3E,gBAAM,YAAY,QAAQ,SAAS;AACnC,cAAI,cAAc,QAAW;AAC3B,gCAAoB,SAAS;AAC7B,iCAAqB,SAAS;AAAA,UAChC;AAAA,QACF;AAAA,QACA,YAAY,MAAM;AAChB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAE1B,gBAAM,eAAe,mBAAmB,QAAQ,QAAQ,gBAAgB,IAAI;AAC5E,gBAAM,YAAY,gBAAgB,IAAI,QAAQ,SAAS,IAAI,eAAe;AAC1E,gBAAM,YAAY,QAAQ,SAAS;AACnC,cAAI,cAAc,QAAW;AAC3B,gCAAoB,SAAS;AAC7B,iCAAqB,SAAS;AAAA,UAChC;AAAA,QACF;AAAA,QACA,iBAAiB,MAAM;AACrB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAC1B,gBAAM,aAAa,QAAQ,CAAC;AAC5B,cAAI,eAAe,QAAW;AAC5B,gCAAoB,UAAU;AAC9B,iCAAqB,UAAU;AAAA,UACjC;AAAA,QACF;AAAA,QACA,gBAAgB,MAAM;AACpB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAC1B,gBAAM,YAAY,QAAQ,QAAQ,SAAS,CAAC;AAC5C,cAAI,cAAc,QAAW;AAC3B,gCAAoB,SAAS;AAC7B,iCAAqB,SAAS;AAAA,UAChC;AAAA,QACF;AAAA,QACA,kBAAkB,MAAM;AACtB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAC1B,gBAAM,gBAAgB,QAAQ,SAAS,cAAc,wBAAwB;AAC7E,gBAAM,WACJ,QAAQ,WAAW,gBACf,KAAK;AAAA,YACH;AAAA,YACA,KAAK;AAAA,cACH,QAAQ,QAAQ,eAAe,cAAc,sBAAsB,EAAE;AAAA,YACvE;AAAA,UACF,IACA;AACN,gBAAM,eAAe,mBAAmB,QAAQ,QAAQ,gBAAgB,IAAI;AAC5E,gBAAM,cAAc,KAAK,IAAI,eAAe,UAAU,QAAQ,SAAS,CAAC;AACxE,gBAAM,cAAc,QAAQ,WAAW;AACvC,cAAI,gBAAgB,QAAW;AAC7B,gCAAoB,WAAW;AAC/B,iCAAqB,WAAW;AAAA,UAClC;AAAA,QACF;AAAA,QACA,gBAAgB,MAAM;AACpB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAC1B,gBAAM,gBAAgB,QAAQ,SAAS,cAAc,wBAAwB;AAC7E,gBAAM,WACJ,QAAQ,WAAW,gBACf,KAAK;AAAA,YACH;AAAA,YACA,KAAK;AAAA,cACH,QAAQ,QAAQ,eAAe,cAAc,sBAAsB,EAAE;AAAA,YACvE;AAAA,UACF,IACA;AACN,gBAAM,eAAe,mBACjB,QAAQ,QAAQ,gBAAgB,IAChC,QAAQ;AACZ,gBAAM,cAAc,KAAK,IAAI,eAAe,UAAU,CAAC;AACvD,gBAAM,cAAc,QAAQ,WAAW;AACvC,cAAI,gBAAgB,QAAW;AAC7B,gCAAoB,WAAW;AAC/B,iCAAqB,WAAW;AAAA,UAClC;AAAA,QACF;AAAA,QACA,cAAc,MAAM;AAClB,cAAI,CAAC,iBAAkB,QAAO;AAE9B,cAAI,uBAAuB,qBAAqB,mBAAmB;AACjE,2BAAe,iBAAiB;AAChC,gBAAI,CAAC,YAAY,SAAS;AACxB,sBAAQ;AAAA,YACV;AACA,mBAAO;AAAA,UACT;AAEA,gBAAM,SAAS,gBAAgB;AAAA,YAC7B,CAA4B,MAAM,EAAE,UAAU;AAAA,UAChD;AACA,cAAI,UAAU,CAAC,OAAO,UAAU;AAC9B,2BAAe,OAAO,OAAO,EAAE,gBAAgB,KAAK,CAAC;AACrD,gBAAI,CAAC,YAAY,SAAS;AACxB,sBAAQ;AAAA,YACV;AACA,mBAAO;AAAA,UACT;AAEA,iBAAO;AAAA,QACT;AAAA,QACA,qBAAqB,MAAM;AAAA,QAC3B,qBAAqB,CAAC,UAAU;AAC9B,8BAAoB,KAAK;AACzB,+BAAqB,KAAK;AAAA,QAC5B;AAAA,QACA,uBAAuB,MAAM,oBAAoB,EAAE;AAAA,MACrD;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,cAAU,MAAM;AACd,UAAI,CAAC,QAAQ;AACX,4BAAoB,EAAE;AAAA,MACxB;AAAA,IACF,GAAG,CAAC,MAAM,CAAC;AAEX,cAAU,MAAM;AACd,iCAA2B,gBAAgB;AAAA,IAC7C,GAAG,CAAC,kBAAkB,wBAAwB,CAAC;AAE/C,UAAM,gBAAgB;AAAA;AAAA,MAEpB,CAAC,OAAO;AACN,gBAAQ,UAAU;AAClB,YAAI,kBAAkB,CAAC,eAAe;AACpC,yBAAe,EAAE;AAAA,QACnB;AAAA,MACF;AAAA,MACA,CAAC,gBAAgB,aAAa;AAAA,IAChC;AAEA,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AAEA;AAAA;AAAA,MAEE,gBAAAA;AAAA,QAAC;AAAA;AAAA,UACC,WAAW;AAAA,YACT;AAAA,YACA,mBAAmB,KAAK;AAAA,YACxB,gBAAgB,iCAAiC;AAAA,UACnD,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AAAA,UAEX,MAAK;AAAA,UACL,IAAI,GAAG,EAAE;AAAA,UACT,wBAAsB,WAAW,SAAS;AAAA,UAC1C,QAAQ,CAAC;AAAA,UACT,KAAK;AAAA,UAEJ,sBACC,gBAAAA,KAAC,QAAG,WAAU,yBAAwB,iBAAa,MAChD,0BAAgB,aAAa,cAAc,GAC9C,IAEA,iCACG;AAAA,mCACC,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBAEC,IAAI,GAAG,EAAE,WAAW,SAAS,iBAAiB,CAAC;AAAA,gBAC/C,WAAW,yBAAyB,qBAAqB,oBAAoB,kCAAkC,EAAE;AAAA,gBAEjH,MAAK;AAAA,gBACL,UAAU;AAAA,gBACV,iBAAe;AAAA,gBACf,cAAc,MAAM,oBAAoB,iBAAiB;AAAA,gBACzD,aAAa,CAAC,MAAM;AAClB,oBAAE,eAAe;AACjB,oBAAE,gBAAgB;AAClB,iCAAe,iBAAiB;AAChC,sBAAI,CAAC,YAAY,SAAS;AACxB,4BAAQ;AAAA,kBACV;AAAA,gBACF;AAAA,gBAEC,uBAAa,UAAU,QAAQ,WAAW,iBAAiB;AAAA;AAAA,cAjBvD;AAAA,YAkBP;AAAA,YAED,gBAAgB,IAAI,CAA4B,WAAW;AAC1D,oBAAM,WAAW,qBAAqB,OAAO;AAC7C,oBAAM,aAAa,YAAY,SAAS,OAAO,KAAK;AACpD,oBAAM,YAAY,cAAc,SAAS,OAAO,KAAK;AACrD,oBAAM,aAAa,OAAO;AAC1B,oBAAM,aAAa,OAAO,WAAW,CAAC;AACtC,oBAAM,gBAAgB;AAAA,gBACpB;AAAA,gBACA,WAAW,kCAAkC;AAAA,gBAC7C,aAAa,oCAAoC;AAAA,gBACjD,YAAY,mCAAmC;AAAA,gBAC/C,aAAa,oCAAoC;AAAA,gBACjD,aAAa,mCAAmC;AAAA,cAClD,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AACX,qBACE;AAAA,gBAAC;AAAA;AAAA,kBAEC,IAAI,GAAG,EAAE,WAAW,SAAS,OAAO,KAAK,CAAC;AAAA,kBAC1C,WAAW;AAAA,kBAEX,MAAK;AAAA,kBACL,UAAU;AAAA,kBACV,iBAAe;AAAA,kBACf,iBAAe;AAAA,kBACf,cAAc,MAAM,CAAC,cAAc,oBAAoB,OAAO,KAAK;AAAA,kBACnE,aAAa,CAAC,MAAM;AAClB,sBAAE,eAAe;AACjB,sBAAE,gBAAgB;AAClB,mCAAe,OAAO,OAAO,EAAE,gBAAgB,KAAK,CAAC;AACrD,wBAAI,CAAC,YAAY,SAAS;AACxB,8BAAQ;AAAA,oBACV;AAAA,kBACF;AAAA,kBAEC;AAAA,mCAAe;AAAA,sBACd;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,oBACF,CAAC;AAAA,oBACA,aACC,gBAAAA;AAAA,sBAAC;AAAA;AAAA,wBACC,WAAU;AAAA,wBACV,eAAY;AAAA,wBACZ,eAAY;AAAA,wBACZ,eAAa,CAAC;AAAA,wBAEb,uBAAa;AAAA;AAAA,oBAChB,IACE;AAAA,oBACH,YACC,gBAAAA;AAAA,sBAAC;AAAA;AAAA,wBACC,WAAU;AAAA,wBACV,eAAY;AAAA,wBACZ,eAAY;AAAA,wBACZ,eAAa,CAAC;AAAA,wBAEb,uBAAa;AAAA;AAAA,oBAChB,IACE;AAAA;AAAA;AAAA,gBAhDC,OAAO;AAAA,cAiDd;AAAA,YAEJ,CAAC;AAAA,YACA,gBAAgB,WAAW,KAC1B,CAAC,cACA,CAAC,iBAAiB,CAAC,cAAc,YAAY,SAAS,UAAU,MAC/D,gBAAAA,KAAC,QAAG,WAAU,yBAAyB,uBAAa,gBAAe;AAAA,aAEzE;AAAA;AAAA,MAEJ;AAAA;AAAA,EAEJ;AACF;AAEA,IAAO,yBAAQ;;;AEhaf,SAAS,eAAAC,cAAa,aAAAC,YAAW,UAAAC,SAAQ,YAAAC,iBAAgB;;;ACAzD,SAAS,eAAAC,cAAa,aAAAC,YAAW,SAAS,UAAAC,SAAQ,YAAAC,iBAAgB;AA6B3D,SAAS,QAAQ,QAAQ,QAAQ;AAEtC,QAAM,QAAQ,oBAAI,QAAQ;AAC1B,QAAM,QAAQ,oBAAI,QAAQ;AAO1B,WAAS,YAAY,GAAG,GAAG;AAEzB,QAAI,OAAO,GAAG,GAAG,CAAC,EAAG,QAAO;AAC5B,QAAI,MAAM,QAAQ,MAAM,QAAQ,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;AAC9E,aAAO,MAAM;AAAA,IACf;AAIA,QAAI,EAAE,aAAa,OAAO,IAAI,eAAe,KAAK,EAAE,aAAa,OAAO,IAAI,eAAe,GAAG;AAC5F,aAAO,MAAM;AAAA,IACf;AAGA,QAAI,OAAO,eAAe,CAAC,MAAM,OAAO,eAAe,CAAC,GAAG;AACzD,aAAO;AAAA,IACT;AAGA,QAAI,MAAM,IAAI,CAAC,EAAG,QAAO,MAAM,IAAI,CAAC,MAAM;AAC1C,QAAI,MAAM,IAAI,CAAC,EAAG,QAAO,MAAM,IAAI,CAAC,MAAM;AAE1C,QAAI,MAAM,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,EAAG,QAAO;AACzC,UAAM,IAAI,GAAG,CAAC;AACd,UAAM,IAAI,GAAG,CAAC;AAGd,QAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,UAAI,EAAE,WAAW,EAAE,QAAQ;AACzB,eAAO;AAAA,MACT;AACA,aAAO,EAAE,MAAM,CAAC,MAAM,UAAU,YAAY,MAAM,EAAE,KAAK,CAAC,CAAC;AAAA,IAC7D;AAGA,QAAI,aAAa,MAAM;AACrB,aAAO,EAAE,QAAQ,MAAM,EAAE,QAAQ;AAAA,IACnC;AAGA,QAAI,aAAa,QAAQ;AACvB,aAAO,EAAE,SAAS,MAAM,EAAE,SAAS;AAAA,IACrC;AAGA,UAAM,QAAQ,OAAO,KAAK,CAAC;AAC3B,UAAM,QAAQ,OAAO,KAAK,CAAC;AAE3B,QAAI,MAAM,WAAW,MAAM,OAAQ,QAAO;AAE1C,WAAO,MAAM,MAAM,CAAC,QAAQ,MAAM,SAAS,GAAG,KAAK,YAAY,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC,CAAC;AAAA,EAChF;AAEA,SAAO,YAAY,QAAQ,MAAM;AACnC;AAQO,SAAS,YAAY,UAAU;AACpC,QAAM,QAAQC;AAAA;AAAA,IAAyB;AAAA,EAAK;AAC5C,MAAI,CAAC,QAAQ,UAAU,MAAM,OAAO,GAAG;AACrC,UAAM,UAAU;AAAA,EAClB;AACA,SAAO,MAAM;AACf;AAOO,SAAS,QAAQ,cAAc;AACpC,QAAM,CAAC,cAAc,YAAY,IAAIC,UAAS,CAAC;AAC/C,QAAM,MAAMD,QAAO,YAAY;AAK/B,MAAI,kBAAkB;AAEtB,QAAM,WAAW,QAAQ,MAAM;AAC7B,sBAAkB;AAClB,WAAO,MAAM,IAAI;AAAA,EACnB,GAAG,CAAC,YAAY,CAAC;AAGjB,QAAM,WAAWE;AAAA;AAAA,IAEf,CAAC,UAAU;AACT,UAAI,UAAU,IAAI,SAAS;AACzB,YAAI,UAAU;AACd,qBAAa,CAAC,MAAM,IAAI,CAAC;AAAA,MAC3B;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO,CAAC,UAAU,UAAU,eAAe;AAC7C;AAEA,IAAM,gBACJ,OAAO,WAAW,eAAe,OAAO,aAAa,mBAAmB,GAAG;AAE7E,IAAM,8BAA8B,OAAO,gBAAgB,UAAU;AAS9D,SAAS,2BAA2B,EAAE,iBAAiB,eAAe,GAAG;AAC9E,MAAI,CAAC,iBAAiB,OAAO,WAAW,eAAe,CAAC,OAAO,eAAgB,QAAO;AAEtF,MAAI,YAAY;AAChB,QAAM,uBAAuB,MAAM;AACjC,QAAI,CAAC,OAAO,eAAgB;AAC5B,UAAM,aAAa,8BAA8B,OAAO,eAAe;AACvE,UAAM,eAAe,aAAa;AAClC,QAAI,cAAc,cAAc;AAC9B,kBAAY;AACZ,wBAAkB,SAAS;AAAA,IAC7B;AACA,qBAAiB,YAAY,SAAS;AAAA,EACxC;AACA,SAAO,eAAe,iBAAiB,UAAU,sBAAsB,EAAE,SAAS,KAAK,CAAC;AACxF,SAAO,MAAM;AACX,WAAO,gBAAgB,oBAAoB,UAAU,oBAAoB;AAAA,EAC3E;AACF;AAyBA,IAAM,eAAe,OAAO,cAAc,eAAe,UAAU,cAAc;AAW1E,SAAS,gBAAgB;AAAA,EAC9B,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAChB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,QAAM,CAAC,iBAAiB,kBAAkB,IAAID;AAAA;AAAA,IAAuC,CAAC;AAAA,EAAE;AACxF,QAAM,CAAC,WAAW,YAAY,IAAIA,UAAS,KAAK;AAChD,QAAM,CAAC,cAAc,eAAe,IAAIA,UAAS,CAAC;AAClD,QAAM,gBAAgBD;AAAA;AAAA,IAAmD,CAAC;AAAA,EAAE;AAC5E,QAAM,qBAAqBA;AAAA;AAAA,IAA8C;AAAA,EAAK;AAC9E,QAAM,mBAAmBA;AAAA;AAAA,IAA4D;AAAA,EAAK;AAE1F,QAAM,aAAaA,QAAO,KAAK;AAE/B,QAAM,oBAAoB,WAAW,KAAK;AAC1C,QAAM,aAAa,OAAO,2BAA2B;AAErD,QAAM,iBAAiB,YAAY,sBAAsB;AAEzD,QAAM,iBAAiB,YAAY,sBAAsB;AAEzD,QAAM,sBAAsBE;AAAA;AAAA,IAE1B,CAAC,WAAW;AACV,UAAI,aAAa;AACjB,iBAAW,QAAQ,QAAQ;AACzB,YACE,CAAC,cAAc,QAAQ,KAAK,KAAK,KACjC,CAAC,QAAQ,cAAc,QAAQ,KAAK,KAAK,GAAG,IAAI,GAChD;AACA,uBAAa;AACb,wBAAc,QAAQ,KAAK,KAAK,IAAI;AAAA,QACtC;AAAA,MACF;AACA,UAAI,YAAY;AACd,wBAAgB,CAAC,MAAM,IAAI,CAAC;AAAA,MAC9B;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AAIA,QAAM,wBAAwB,QAAQ,MAAM;AAC1C,QAAI,MAAM,QAAQ,cAAc,GAAG;AACjC,aAAO,eAAe;AAAA,QACpB,CAAC,KAAK,MAAM;AACV,cAAI,EAAE,KAAK,IAAI;AACf,iBAAO;AAAA,QACT;AAAA;AAAA,QAC4C,CAAC;AAAA,MAC/C;AAAA,IACF;AACA,WAAO,EAAE,GAAG,cAAc,QAAQ;AAAA,EACpC,GAAG,CAAC,gBAAgB,YAAY,CAAC;AAIjC,QAAM,mBAAmB;AAAA,IACvB,MAAM,eAAe,OAAO,CAAC,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAAA,IAC5D,CAAC,gBAAgB,YAAY;AAAA,EAC/B;AAOA,EAAAC,WAAU,MAAM;AACd,QAAI,CAAC,WAAY;AACjB,QAAI,iBAAiB,WAAW,EAAG;AAEnC,UAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAKD;AAAA;AACL,UAAM,wBAAwB;AAC9B,UAAM,kBAAkB,IAAI,gBAAgB;AAE5C;AAAA,MACE;AAAA,MACA,iBAAiB;AAAA,MACjB;AAAA,MACA,gBAAgB;AAAA,IAClB,EACG,KAAK,CAAC,YAAY;AACjB,UAAI,gBAAgB,OAAO,QAAS;AACpC,UAAI,SAAS,QAAQ;AACnB,4BAAoB,OAAO;AAAA,MAC7B;AACA,YAAM,kBAAkB,iBAAiB;AAAA,QACvC,CAAC,MAAM,CAAC,SAAS,KAAK,CAAC,MAAM,EAAE,UAAU,CAAC;AAAA,MAC5C;AACA,UAAI,gBAAgB,SAAS,GAAG;AAC9B,4BAAoB,gBAAgB,IAAI,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,EAAE,EAAE,CAAC;AAAA,MAC1E;AAAA,IACF,CAAC,EACA,MAAM,CAAC,UAAU;AAChB,UAAI,gBAAgB,OAAO,QAAS;AACpC,cAAQ,MAAM,oCAAoC,KAAK;AACvD,0BAAoB,iBAAiB,IAAI,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,EAAE,EAAE,CAAC;AAAA,IAC3E,CAAC;AAEH,WAAO,MAAM,gBAAgB,MAAM;AAAA,EACrC,GAAG;AAAA;AAAA,IAED,iBAAiB,SAAS;AAAA;AAAA;AAAA,IAE1B,aAAa,iBAAiB;AAAA,IAC9B;AAAA,EACF,CAAC;AAaD,EAAAA,WAAU,MAAM;AACd,uBAAmB,SAAS,MAAM;AAClC,QAAI,iBAAiB,SAAS;AAC5B,mBAAa,iBAAiB,OAAO;AACrC,uBAAiB,UAAU;AAAA,IAC7B;AAEA,QAAI,CAAC,QAAQ;AACX,yBAAmB,CAAC,CAAC;AACrB,mBAAa,KAAK;AAClB,iBAAW,UAAU;AACrB;AAAA,IACF;AAGA,UAAM,cAAc,CAAC,WAAW;AAChC,eAAW,UAAU;AAErB,QAAI,YAAY;AACd,YAAM;AAAA;AAAA,QAEF;AAAA;AAEJ,YAAM,wBAAwB;AAC9B,YAAM,kBAAkB,IAAI,gBAAgB;AAC5C,yBAAmB,UAAU;AAG7B,UAAI,eAAe,eAAe,IAAI;AAEtC,UAAI,YAAa,gBAAe;AAEhC,mBAAa,IAAI;AAEjB,YAAM,eAAe,YAAY;AAC/B,YAAI;AACF,gBAAM,UAAU,MAAM;AAAA,YACpB;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB;AAAA,UAClB;AAEA,cAAI,gBAAgB,OAAO,QAAS;AAEpC,cAAI,SAAS,QAAQ;AACnB,gCAAoB,OAAO;AAAA,UAC7B;AAEA,cAAI,iBAAiB,WAAW,CAAC;AACjC,cAAI,CAAC,mBAAmB;AACtB,kBAAM,2BAA2B,sBAC9B,OAAO,CAAC,MAAM,CAAC,SAAS,KAAK,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC,EAClD,OAAO,CAAC,MAAM,CAAC,cAAc,QAAQ,CAAC,CAAC,EACvC,IAAI,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,EAAE,EAAE;AACtC,gBAAI,yBAAyB,SAAS,GAAG;AACvC,kCAAoB,wBAAwB;AAC5C,+BAAiB,yBAAyB,OAAO,WAAW,CAAC,CAAC;AAAA,YAChE;AAAA,UACF;AAEA,gBAAM,UAAU,oBACZ,iBACA,gBAAgB,gBAAgB,qBAAqB;AAEzD,6BAAmB,cAAc,mBAAmB,SAAS,UAAU,KAAK,CAAC;AAC7E,uBAAa,KAAK;AAAA,QACpB,SAAS,OAAO;AACd,cAAI,gBAAgB,OAAO,QAAS;AACpC,uBAAa,KAAK;AAClB,gBAAM;AAAA,QACR;AAAA,MACF;AAEA,UAAI,eAAe,GAAG;AACpB,yBAAiB,UAAU,WAAW,cAAc,YAAY;AAAA,MAClE,OAAO;AACL,qBAAa;AAAA,MACf;AAEA,aAAO,MAAM;AACX,wBAAgB,MAAM;AACtB,YAAI,iBAAiB,SAAS;AAC5B,uBAAa,iBAAiB,OAAO;AAAA,QACvC;AAAA,MACF;AAAA,IAEF,OAAO;AAEL,YAAM;AAAA;AAAA,QAAwC;AAAA;AAC9C,YAAM,wBAAwB;AAC9B,YAAM,gBAAgB,sBACnB,OAAO,CAAC,MAAM,CAAC,sBAAsB,CAAC,CAAC,EACvC,IAAI,CAAC,OAAO,EAAE,OAAO,GAAG,OAAO,EAAE,EAAE,EACnC,OAAO,YAAY;AAEtB,YAAM,UAAU,aACZ,gBACA,gBAAgB,eAAe,qBAAqB;AAExD,yBAAmB,cAAc,YAAY,SAAS,UAAU,IAAI,CAAC;AAAA,IACvE;AAAA,EACF,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,iBAAiB,SAAS;AAAA;AAAA,IAC1B;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AD9RQ,SAEI,OAAAC,MAFJ,QAAAC,aAAA;AAnJR,IAAM,iBAAiB,CAAC;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAEJ,QAAM,CAAC,gBAAgB,iBAAiB,IAAIC,UAAS,EAAE;AACvD,QAAM,CAAC,uBAAuB,wBAAwB,IAAIA,UAAS,CAAC;AACpE,QAAM,eAAeC;AAAA;AAAA,IAA+C;AAAA,EAAK;AACzE,QAAM,eAAeA;AAAA;AAAA,IAA6C;AAAA,EAAK;AACvE,QAAM,sBAAsBA,QAAO,EAAE;AACrC,QAAM,0CAA0CA;AAAA;AAAA,IAAuC;AAAA,EAAK;AAC5F,QAAM,qCAAqCA,QAAO,KAAK;AACvD,QAAM,0BAA0BA;AAAA;AAAA,IACuB;AAAA,EACvD;AAGA,QAAM,wBAAwBC;AAAA;AAAA;AAAA;AAAA,IAI5B,CAAC,MAAM;AACL,YAAM,QAAQ,EAAE,cAAc;AAC9B,wBAAkB,KAAK;AACvB,oBAAc,KAAK;AAAA,IACrB;AAAA,IACA,CAAC,aAAa;AAAA,EAChB;AAEA,QAAM,mCAAmCA,aAAY,MAAM;AACzD,UAAM,QAAQ,aAAa;AAC3B,QAAI,CAAC,MAAO;AACZ,UAAM,gCACJ,mCAAmC,YAAY,QAAQ,SAAS,kBAAkB;AACpF,QAAI,CAAC,8BAA+B;AACpC,UAAM,aAAa,YAAY,UAAU;AACzC,QAAI,wBAAwB,SAAS;AACnC,mBAAa,wBAAwB,OAAO;AAAA,IAC9C;AACA,4BAAwB,UAAU,WAAW,MAAM;AACjD,YAAM,gBAAgB,UAAU;AAChC,8BAAwB,UAAU;AAAA,IACpC,GAAG,EAAE;AAAA,EACP,GAAG,CAAC,CAAC;AAGL,QAAM,cAAcA,aAAY,MAAM;AACpC,sBAAkB,EAAE;AACpB,6BAAyB,CAAC;AAC1B,uCAAmC,UAAU;AAC7C,4CAAwC,UAAU;AAClD,4CAAwC,UAAU;AAClD,QAAI,wBAAwB,SAAS;AACnC,mBAAa,wBAAwB,OAAO;AAC5C,8BAAwB,UAAU;AAAA,IACpC;AACA,iBAAa,SAAS,gBAAgB,UAAU;AAGhD,UAAM;AAAA;AAAA,MACJ,SAAS,oBAAoB,SAAS;AAAA;AAExC,qBAAiB,MAAM,WAAW,oBAAoB;AAEtD,YAAQ;AAAA,EACV,GAAG,CAAC,OAAO,CAAC;AAGZ,EAAAC,WAAU,MAAM;AACd,QAAI,QAAQ;AAEV,YAAM;AAAA;AAAA,QACJ,SAAS,oBAAoB,SAAS;AAAA;AAIxC,0BAAoB,UAAU,iBAAiB,MAAM;AACrD,uBAAiB,MAAM,WAAW;AAGlC,UAAI,CAAC,wCAAwC,SAAS;AACpD,gDAAwC,UAAU,2BAA2B;AAAA,UAC3E,eAAe,gBAAgB,WAAW;AACxC,qCAAyB,YAAY,iBAAiB,CAAC;AACvD,+CAAmC,UAAU,CAAC;AAAA,UAChD;AAAA,QACF,CAAC;AAAA,MACH;AAGA,mBAAa,SAAS,MAAM;AAAA,IAC9B;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAGX,EAAAA,WAAU,MAAM;AACd,WAAO,MAAM;AACX,UAAI,wCAAwC,SAAS;AACnD,gDAAwC,QAAQ;AAChD,gDAAwC,UAAU;AAAA,MACpD;AACA,UAAI,wBAAwB,SAAS;AACnC,qBAAa,wBAAwB,OAAO;AAC5C,gCAAwB,UAAU;AAAA,MACpC;AACA,mBAAa,SAAS,gBAAgB,UAAU;AAChD,yCAAmC,UAAU;AAAA,IAC/C;AAAA,EACF,GAAG,CAAC,CAAC;AAIL,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAEA;AAAA;AAAA;AAAA,IAGE,gBAAAL;AAAA,MAAC;AAAA;AAAA,QACC,KAAK;AAAA,QACL,WAAW,wBAAwB,mBAAmB,KAAK,EAAE;AAAA,QAC7D,OAAO,EAAE,SAAS,SAAS,OAAO,OAAO;AAAA,QACzC,SAAS,CAAC,MAAM;AAEd,cAAI,EAAE,WAAW,aAAa,SAAS;AACrC,wBAAY;AAAA,UACd;AAAA,QACF;AAAA,QACA,WAAW,CAAC,MAAM;AAChB,cAAI,EAAE,QAAQ,UAAU;AACtB,wBAAY;AAAA,UACd;AAAA,QACF;AAAA,QAEA,MAAK;AAAA,QACL,cAAW;AAAA,QACX,mBAAiB,YAAY,GAAG,EAAE,gBAAgB;AAAA,QAClD,UAAU;AAAA,QAEV,0BAAAC,MAAC,SAAI,WAAW,uBAAuB,mBAAmB,KAAK,EAAE,IAC/D;AAAA,0BAAAA,MAAC,SAAI,WAAU,6BACZ;AAAA,yBACC,gBAAAD;AAAA,cAAC;AAAA;AAAA,gBACC,IAAI,GAAG,EAAE;AAAA,gBACT,WAAU;AAAA,gBACV,SAAS,GAAG,EAAE;AAAA,gBAEb;AAAA;AAAA,YACH;AAAA,YAEF,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,IAAI,GAAG,EAAE;AAAA,gBACT,KAAK;AAAA,gBACL,MAAK;AAAA,gBACL,OAAO;AAAA,gBACP,aAAa,aAAa;AAAA,gBAC1B,UAAU;AAAA,gBACV,WAAW,CAAC,MAAM;AAChB,sBAAI,EAAE,QAAQ,UAAU;AACtB,gCAAY;AAAA,kBACd;AAAA,gBACF;AAAA,gBACA,WAAW,4BAA4B,CAAC,YAAY,sCAAsC,EAAE;AAAA,gBAC5F,MAAK;AAAA,gBACL,iBAAc;AAAA,gBACd,iBAAc;AAAA,gBACd,iBAAe,GAAG,EAAE;AAAA,gBACpB,cAAY,aAAa,aAAa;AAAA,gBACtC,cAAa;AAAA;AAAA,YACf;AAAA,aACF;AAAA,UACA,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,oBAAoB;AAAA,cACpB,qBAAqB;AAAA,cAEpB;AAAA;AAAA,UACH;AAAA,UACC,wBAAwB,KACvB,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,WAAU;AAAA,cACV,OAAO,EAAE,QAAQ,GAAG,qBAAqB,KAAK;AAAA,cAC9C,eAAY;AAAA;AAAA,UACd;AAAA,WAEJ;AAAA;AAAA,IACF;AAAA;AAEJ;AAEA,IAAO,yBAAQ;;;AHpBX,SAmHA,YAAAM,WAnHA,OAAAC,MAwHM,QAAAC,aAxHN;AAxDJ,IAAM,6BAA6B;AAAA,EACjC,mBAAmB;AAAA,EACnB,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAChB,4BAA4B;AAAA,EAC5B,2BAA2B;AAAA,EAC3B,4BAA4B;AAAA,EAC5B,WAAW;AAAA,EACX,gBAAgB;AAAA,EAChB,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,eAAe;AAAA,EACf,eAAe;AAAA,EACf,4BAA4B;AAAA,EAC5B,mBAAmB;AAAA,EACnB,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,mBAAmB;AAAA,EACnB,gBAAgB;AAAA,EAChB,sBAAsB;AAAA;AAAA,EAEtB,wBAAwB,CAAC,OAAO,SAAS,IAAI,KAAK,aAAa,IAAI,EAAE,OAAO,KAAK;AACnF;AAGA,IAAM,kBAAkB,OAAO,SAAS;AAKxC,SAAS,OAAO,KAAK;AACnB,SAAO,MAAM,KAAK,IAAI,IAAI,GAAG,CAAC;AAChC;AAQA,IAAM,SAAS,CAAC,EAAE,SAAS,SAAS,MAAM,UAAU,eAAe,MAAM;AACvE,QAAM,CAAC,KAAK,MAAM,IAAIC;AAAA;AAAA,IAAqC;AAAA,EAAK;AAEhE,EAAAC,WAAU,MAAM;AACd,QAAI,gBAAgB,SAAS;AAC3B,YAAM,UAAU,OAAO,iBAAiB,eAAe,OAAO,EAAE;AAChE,YAAM,YAAY,OAAO,iBAAiB,MAAM,EAAE;AAClD,UAAI,YAAY,WAAW;AACzB,eAAO,OAAO;AAAA,MAChB,OAAO;AACL,eAAO,IAAI;AAAA,MACb;AAAA,IACF;AAAA,EACF,GAAG,CAAC,gBAAgB,MAAM,CAAC;AAE3B,QAAM,kBAAkB,MACtB,gBAAAH,KAAC,SAAI;AAAA;AAAA,IAA4C;AAAA,KAAM,OAAO,EAAE,WAAW,IAAI,GAC5E,UACH,IAEA;AAGF,SAAO,aAAa,iBAAiB,MAAM;AAC7C;AAGA,IAAM,0BAA0B;AAAA,EAC9B;AAAA,IACE,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA;AAAA;AAAA,IAEE,MAAM;AAAA,IACN,SAAS;AAAA,IACT,OAAO;AAAA,IACP,UAAU,CAAC,eAAe;AAAA;AAAA,IAE1B,IAAI,CAAC,EAAE,MAAM,MAAM;AACjB,YAAM,OAAO,OAAO,WAAW,GAAG,MAAM,MAAM,UAAU,KAAK;AAAA,IAC/D;AAAA;AAAA,IAEA,QAAQ,CAAC,EAAE,MAAM,MAAM;AACrB,YAAM,SAAS,OAAO,MAAM,WAAW,GAAG,MAAM,SAAS,UAAU,WAAW;AAAA,IAChF;AAAA,EACF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,SAAS;AAAA,IACT,SAAS;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,EACF;AACF;AAEA,IAAM,yBAAyB;AAAA,EAC7B;AAAA,IACE,MAAM;AAAA,IACN,SAAS;AAAA,MACP,QAAQ,CAAC,GAAG,CAAC;AAAA,IACf;AAAA,EACF;AAAA,EACA;AAAA,IACE,MAAM;AAAA,IACN,SAAS;AAAA,IACT,SAAS;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,EACF;AACF;AAGA,IAAM,qBACJ,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,WAAU;AAAA,IACV,SAAQ;AAAA,IACR,OAAM;AAAA,IACN,QAAO;AAAA,IACP,eAAY;AAAA,IAEZ,0BAAAA,KAAC,UAAK,GAAE,sDAAqD;AAAA;AAC/D;AAGF,IAAM,kBACJ,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,WAAU;AAAA,IACV,SAAQ;AAAA,IACR,OAAM;AAAA,IACN,QAAO;AAAA,IACP,eAAY;AAAA,IAEZ,0BAAAA,KAAC,UAAK,GAAE,qDAAoD,MAAK,gBAAe;AAAA;AAClF;AAGF,IAAM,qBACJ,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,WAAU;AAAA,IACV,SAAQ;AAAA,IACR,OAAM;AAAA,IACN,QAAO;AAAA,IACP,eAAY;AAAA,IAEZ,0BAAAA,KAAC,UAAK,GAAE,kBAAiB;AAAA;AAC3B;AAIF,IAAM,yBAAyB,CAAC,gBAAgB;AAGzC,SAAS,sBAAsB;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,QAAM,qBAAqB,OAAO,UAAU,OAAO;AAMnD,QAAM,WAAW,CAAC,YAAY,eAC5B,gBAAAC,MAAAF,WAAA,EACG;AAAA,yBAAqB,QAAQ,KAAK;AAAA,IACnC,gBAAAE,MAAC,UAAK,WAAU,kCACd;AAAA,sBAAAD,KAAC,UAAM,sBAAW;AAAA,MACjB,sBAAsB,CAAC,YAAY,OAClC,gBAAAC,MAAC,UAAK,WAAU,8BAA6B,eAAY,QAAO;AAAA;AAAA,QAC5D;AAAA,QAAW;AAAA,SACf;AAAA,OAEJ;AAAA,KACF;AAGF,QAAM,EAAE,OAAO,OAAO,SAAS,YAAY,IAAI;AAC/C,MAAI;AACJ,MAAI,YAAY,WAAY,YAAY,WAAW,UAAU,OAAQ;AACnE,UAAM,aAAa,mBAAmB,aAAa,KAAK;AACxD,mBAAe,SAAS,YAAY,CAAC,KAAK,CAAC;AAAA,EAC7C,WAAW,YAAY,SAAS;AAC9B,UAAM,aAAa,mBAAmB,aAAa,KAAK;AACxD,mBAAe,SAAS,CAAC,KAAK,GAAG,UAAU;AAAA,EAC7C,OAAO;AAEL,mBAAe,SAAS,CAAC,KAAK,GAAG,CAAC,KAAK,CAAC;AAAA,EAC1C;AAEA,SACE,gBAAAA,MAAAF,WAAA,EACE;AAAA,oBAAAC;AAAA,MAAC;AAAA;AAAA,QACC,WAAW,iCACT,aAAa,4CAA4C,EAC3D;AAAA,QAEC,wBAAc;AAAA;AAAA,IACjB;AAAA,IACC;AAAA,IACA,aAAa;AAAA,KAChB;AAEJ;AAGA,SAAS,0BAA0B,QAAQ;AACzC,SAAO,OAAO,OACZ,gBAAAA,KAAC,UAAK,WAAU,6BAA4B,eAAY,QAAO,MAAK,OACjE,iBAAO,MACV,IACE;AACN;AAGA,IAAM,oBAAoB,CAAC;AAW3B,SAAS,4BAA4B,gBAAgB,MAAM,eAAe,UAAU,cAAc;AAChG,MAAI,CAAC,kBAAkB,eAAe,WAAW,GAAG;AAClD,WAAO,aAAa;AAAA,EACtB;AAEA,QAAM,SAAS,eAAe,IAAI,CAAC,UAAU,cAAc,KAAK,GAAG,SAAS,KAAK;AAEjF,QAAM,SAAS,OACX,SAAS,UACP,aAAa,iBACb,aAAa,mBACf,aAAa;AAEjB,MAAI,eAAe,UAAU,GAAG;AAC9B,WAAO,GAAG,MAAM,IAAI,IAAI,KAAK,WAAW,UAAU,EAAE,OAAO,QAAQ,MAAM,cAAc,CAAC,EAAE,OAAO,MAAM,CAAC;AAAA,EAC1G;AAEA,QAAM,aAAa,OAAO,MAAM,GAAG,CAAC;AACpC,QAAM,YAAY,eAAe,SAAS;AAC1C,QAAM,WACJ,cAAc,IACV,aAAa,eAAe,QAAQ,WAAW,UAAU,SAAS,CAAC,IACnE,aAAa,qBAAqB,QAAQ,WAAW,UAAU,SAAS,CAAC;AAE/E,SAAO,GAAG,MAAM,IAAI,WAAW,KAAK,IAAI,CAAC,IAAI,QAAQ;AACvD;AAMA,IAAM,iBAAiB,CAAC;AAAA,EACtB,IAAI;AAAA,EACJ,WAAW;AAAA,EACX;AAAA,EACA,gBAAgB;AAAA,EAChB;AAAA,EACA,QAAQ,WAAW,oBAAoB;AAAA,EACvC,WAAW;AAAA,EACX,cAAc;AAAA,EACd;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS,SAAS;AAAA,EAClB,YAAY;AAAA,EACZ;AAAA,EACA,YAAY,EAAE,iBAAiB,MAAM,GAAG,WAAW,IAAI,CAAC;AAAA,EACxD,uBAAuB;AAAA,EACvB,WAAW;AAAA,EACX;AAAA,EACA,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,qBAAqB;AAAA,EACrB,cAAc;AAAA,EACd,WAAW;AAAA,EACX,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,iBAAiB;AAAA,EACjB,WAAW;AAAA,EACX,eAAe;AAAA;AAAA,EAEf,8BAA8B;AAChC,MAAM;AAEJ,QAAM,qBAAqB;AAAA,IACzB,iBAAiB,6BACb,eACA,EAAE,GAAG,4BAA4B,GAAG,aAAa;AAAA,EACvD;AACA,QAAM,SAAS;AAAA;AAAA,IAAoC;AAAA,MAAS;AAC5D,QAAM,oBAAoB,WAAW;AAAA;AAAA,IAA8B;AAAA;AAGnE,MAAI;AACJ,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB;AAAA,IAA0C;AAAA,EAC5C,OAAO;AACL,qBAAiB,QAAQ;AAAA;AAAA,MAAwB;AAAA,IAAM,IAAI,CAAC;AAAA,EAC9D;AACA,QAAM,cAAc,YAAY,cAAc;AAC9C,QAAM,oBAAoBI,SAAQ,MAAM,IAAI,IAAI,WAAW,GAAG,CAAC,WAAW,CAAC;AAE3E,QAAM,SAAS,MAAM;AACrB,QAAM,KAAK,UAAU;AACrB,QAAM,CAAC,YAAY,aAAa,IAAIF,UAAS,EAAE;AAC/C,QAAM,CAAC,mBAAmB,iBAAiB,IAAI,QAAQ,KAAK;AAC5D,QAAM,CAAC,cAAc,YAAY,IAAI,QAAQ,KAAK;AAElD,QAAM,CAAC,2BAA2B,4BAA4B,IAAIA,UAAS,EAAE;AAE7E,QAAM,CAAC,qBAAqB,sBAAsB,IAAIA,UAAS,EAAE;AAEjE,QAAM,oBAAoBG;AAAA;AAAA,IACgD;AAAA,EAC1E;AAEA,QAAM,CAAC,uBAAuB,wBAAwB,IAAIH,UAAS,EAAE;AACrE,QAAM,CAAC,oBAAoB,qBAAqB,IAAIA,UAAS,KAAK;AAClE,QAAM,WAAWG;AAAA;AAAA,IAA+C;AAAA,EAAK;AACrE,QAAM,iBAAiBA;AAAA;AAAA,IAA0C;AAAA,EAAU;AAC3E,QAAM,iBAAiBA;AAAA;AAAA,IAA6C;AAAA,EAAK;AACzE,QAAM,oBAAoBA;AAAA;AAAA,IAA+C;AAAA,EAAK;AAC9E,QAAM,8BAA8BA,QAAO,KAAK;AAChD,QAAM,iBAAiBA,QAAO,IAAI;AAClC,QAAM,mBAAmBA,QAAO,IAAI;AACpC,QAAM,YAAYA;AAAA;AAAA,IAAkC,CAAC;AAAA,EAAE;AACvD,QAAM,YAAYA;AAAA;AAAA,IAAkC,CAAC;AAAA,EAAE;AACvD,QAAM,CAAC,cAAc,YAAY,IAAI,QAAQ,aAAa;AAG1D,QAAM,CAAC,eAAe,aAAa,IAAI,QAAQ,KAAK;AACpD,QAAM,0BAA0BA,QAAO,KAAK;AAC5C,QAAM,CAAC,gBAAgB,iBAAiB,IAAIH,UAAS,KAAK;AAC1D,QAAM,CAAC,sBAAsB,uBAAuB,IAAIA,UAAS,EAAE;AAGnE,EAAAC,WAAU,MAAM;AACd,QAAI,SAAS,QAAQ;AACnB,YAAM,aAAa,OAAO,WAAW,eAAe,cAAc,GAAG;AACrE,wBAAkB,WAAW,OAAO;AACpC,YAAM,eAAe,CAAoC,MAAM,kBAAkB,EAAE,OAAO;AAC1F,iBAAW,iBAAiB,UAAU,YAAY;AAClD,aAAO,MAAM,WAAW,oBAAoB,UAAU,YAAY;AAAA,IACpE;AAAA,EACF,GAAG,CAAC,MAAM,cAAc,CAAC;AAGzB,QAAM,gBAAgB,SAAS,QAAS,SAAS,UAAU;AAG3D,QAAM,mBAAmB,cAAc,IAAI,uBAAuB;AAClE,QAAM,eAAe,iBAAiB,KAAK;AAY3C,QAAM,4BAA4BG,aAAY,MAAM;AAClD,QAAI,cAAe,QAAO;AAC1B,QAAI,OAAO,SAAS,eAAe,YAAY,CAAC,SAAS,QAAS,QAAO;AAEzE,UAAM,eAAe,SAAS;AAC9B,UAAM,UAAU,aAAa;AAG7B,UAAM,iBAAiB,aAAa,aAAa,iBAAiB;AAClE,QAAI,gBAAgB;AAClB,YAAM,eAAe,SAAS,eAAe,cAAc;AAC3D,UAAI,cAAc;AAChB,eAAO,aAAa,aAAa,KAAK,KAAK;AAAA,MAC7C;AAAA,IACF;AAGA,UAAM,YAAY,aAAa,aAAa,YAAY;AACxD,QAAI,WAAW;AACb,aAAO,UAAU,KAAK;AAAA,IACxB;AAIA,QAAI,SAAS;AACX,YAAM,eAAe,SAAS,cAAc,cAAc,OAAO,IAAI;AACrE,UAAI,cAAc;AAChB,eAAO,aAAa,aAAa,KAAK,KAAK;AAAA,MAC7C;AAAA,IACF;AAGA,UAAM,gBAAgB,aAAa,QAAQ,OAAO;AAClD,QAAI,eAAe;AACjB,aAAO,cAAc,aAAa,KAAK,KAAK;AAAA,IAC9C;AAGA,UAAM,QAAQ,aAAa,aAAa,OAAO;AAC/C,QAAI,OAAO;AACT,aAAO,MAAM,KAAK;AAAA,IACpB;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,eAAe,QAAQ,CAAC;AAC5B,kBAAgB,MAAM;AACpB,iBAAa,0BAA0B,CAAC;AAAA,EAC1C,GAAG,CAAC,cAAc,yBAAyB,CAAC;AAG5C,QAAM,aAAa,gBAAgB,cAAc,IAAI,kBAAkB;AAGvE,QAAM,EAAE,iBAAiB,uBAAuB,UAAU,IAAI,gBAAgB;AAAA,IAC5E;AAAA,IACA,gBAAgB;AAAA,IAChB,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,EACF,CAAC;AAGD,QAAM,mBAAmB;AAEzB,QAAM,gBAAgBF,SAAQ,MAAM;AAClC,QAAI,cAAe,QAAO,CAAC;AAC3B,WAAO,aAAa,OAAO,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC,KAAK,CAAC;AAAA,EAC9D,GAAG,CAAC,eAAe,aAAa,gBAAgB,CAAC;AAEjD,QAAM,8BAA8BE;AAAA;AAAA;AAAA;AAAA;AAAA,IAKlC,CAAC,gBAAgB,SAAS;AACxB,YAAM,eAAe;AAAA,QACnB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,mCAA6B,YAAY;AAAA,IAC3C;AAAA,IACA,CAAC,kBAAkB,oBAAoB,QAAQ;AAAA,EACjD;AAMA,QAAM,+BAA+BA;AAAA;AAAA,IAEnC,CAACC,WAAU;AACT,+BAAyBA,MAAK;AAAA,IAChC;AAAA,IACA,CAAC;AAAA,EACH;AAEA,QAAM,gBAAgBD;AAAA,IACpB,CAAC,mBAAmB,UAAU;AAC5B,wBAAkB,KAAK;AAEvB,UAAI,kBAAkB,SAAS;AAE7B,0BAAkB,QAAQ,MAAM,UAAU;AAAA,MAC5C;AACA,UAAI,kBAAkB;AACpB,oCAA4B,UAAU;AAAA,MACxC;AAGA,kCAA4B,WAAW;AAGvC,wBAAkB,SAAS,sBAAsB;AAAA,IACnD;AAAA,IACA,CAAC,mBAAmB,6BAA6B,WAAW;AAAA,EAC9D;AAGA,EAAAH,WAAU,MAAM;AACd,QACE,kBAAkB,KAClB,CAAC,iBACD,eAAe,WACf,kBAAkB,SAClB;AAEA,YAAM,cAAc,OAAO,iBAAiB,eAAe,OAAO,EAAE;AACpE,YAAM,YAAY,gBAAgB,QAAQ,eAAe;AAEzD,YAAM,iBAAiB,aAAa,eAAe,SAAS,kBAAkB,SAAS;AAAA,QACrF;AAAA;AAAA,QAEA,WAAW;AAAA,MACb,CAAC;AACD,wBAAkB,QAAQ,MAAM,UAAU;AAE1C,aAAO,MAAM;AACX,uBAAe,QAAQ;AAAA,MACzB;AAAA,IACF;AACA,QAAI,iBAAiB,kBAAkB,SAAS;AAC9C,wBAAkB,QAAQ,MAAM,UAAU;AAAA,IAC5C;AAAA,EACF,GAAG,CAAC,mBAAmB,aAAa,CAAC;AAUrC,EAAAA,WAAU,MAAM;AACd,QACE,cAAc,SAAS,KACvB,sBACA,eAAe,WACf,iBAAiB,WACjB,eAAe,SACf;AAEA,YAAM,cAAc,OAAO,iBAAiB,eAAe,OAAO,EAAE;AACpE,YAAM,YAAY,gBAAgB,QAAQ,eAAe;AAEzD,YAAM,iBAAiB,aAAa,eAAe,SAAS,iBAAiB,SAAS;AAAA,QACpF;AAAA;AAAA,QAEA,WAAW;AAAA,MACb,CAAC;AAED,uBAAiB,QAAQ,MAAM,UAAU;AAGzC,aAAO,MAAM;AACX,uBAAe,QAAQ;AAAA,MACzB;AAAA,IACF;AAAA,EACF,GAAG,CAAC,oBAAoB,cAAc,MAAM,CAAC;AAM7C,QAAM,qBAAqBG;AAAA;AAAA;AAAA;AAAA;AAAA,IAKzB,CAAC,eAAe,EAAE,iBAAiB,MAAM,IAAI,CAAC,MAAM;AAElD,YAAM,SAAS,iBAAiB,aAAa;AAC7C,UAAI,QAAQ,UAAU;AACpB;AAAA,MACF;AACA,UAAI,QAAQ;AACV,cAAM,mBAAmB,OAAO,SAAS,aAAa;AACtD,YAAI;AACJ,YAAI,CAAC,oBAAqB,kBAAkB,kBAAmB;AAC7D,cAAI,kBAAkB,kBAAkB;AACtC,wBAAY,OAAO,OAAO,CAAC,MAAM,MAAM,aAAa;AAAA,UACtD,OAAO;AACL,wBAAY,CAAC,GAAG,QAAQ,aAAa;AAAA,UACvC;AACA,mBAAS,SAAS;AAClB;AAAA,YACE,CAAC,aAAa;AAAA,YACd,UAAU,SAAS,OAAO,SAAS,YAAY;AAAA,UACjD;AACA,oBAAU,QAAQ,KAAK,MAAM;AAC7B,oBAAU,UAAU,CAAC;AAAA,QACvB;AAAA,MACF,OAAO;AACL,YACE,sBAAsB,iBACrB,kBAAkB,sBAAsB,eACzC;AACA,cAAI;AACJ,cAAI,kBAAkB,sBAAsB,eAAe;AACzD,uBAAW;AAAA,UACb,OAAO;AACL,uBAAW;AAAA,UACb;AACA,mBAAS,QAAQ;AACjB,sCAA4B,CAAC,aAAa,GAAG,WAAW,YAAY,OAAO;AAC3E,oBAAU,QAAQ,KAAK,CAAC,QAAQ,CAAC;AACjC,oBAAU,UAAU,CAAC;AACrB,wBAAc;AAAA,QAChB;AACA,sBAAc,EAAE;AAAA,MAClB;AAAA,IACF;AAAA,IACA;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,QAAM,qCAAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQzC,CAAC,WAAW;AACV,YAAM;AAAA,QACJ;AAAA,QACA,8BAA8B;AAAA,QAC9B,oBAAoB;AAAA,QACpB,0BAA0B;AAAA,MAC5B,IAAI;AACJ,UAAI,CAAC,MAAO;AAGZ,YAAM,gCAAgC,+BAA+B,CAAC;AACtE,UAAI,+BAA+B;AACjC,cAAM,aAAa,YAAY,UAAU;AAAA,MAC3C;AAKA,YAAM,MAAM;AACZ,UAAI,+BAA+B;AACjC,YAAI,yBAAyB,SAAS;AACpC,uBAAa,wBAAwB,OAAO;AAAA,QAC9C;AACA,cAAM,iBAAiB,MAAM;AAC3B,gBAAM,gBAAgB,UAAU;AAChC,cAAI,yBAAyB;AAC3B,oCAAwB,UAAU;AAAA,UACpC;AAAA,QACF;AACA,YAAI,yBAAyB;AAC3B,kCAAwB,UAAU,WAAW,gBAAgB,EAAE;AAAA,QACjE,OAAO;AACL,qBAAW,gBAAgB,EAAE;AAAA,QAC/B;AAAA,MACF;AAAA,IACF;AAAA,IACA,CAAC;AAAA,EACH;AAEA,QAAM,aAAaA;AAAA,IACjB,CAAC,oBAAoB,UAAU;AAC7B,yCAAmC;AAAA,QACjC,OAAO,SAAS;AAAA,QAChB,6BACE,aAAa,KAAK,mCAAmC,YAAY;AAAA,QACnE;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IACA,CAAC,cAAc,kCAAkC;AAAA,EACnD;AAEA,QAAM,WAAWA,aAAY,MAAM;AACjC,QAAI,CAAC,cAAe;AACpB,kBAAc,IAAI;AAClB,sBAAkB,KAAK;AACvB,4BAAwB,UAAU;AAAA,EACpC,GAAG,CAAC,eAAe,mBAAmB,aAAa,CAAC;AAEpD,QAAM,YAAYA,aAAY,MAAM;AAClC,kBAAc,KAAK;AACnB,4BAAwB,EAAE;AAC1B,4BAAwB,UAAU;AAClC,eAAW,IAAI;AAAA,EACjB,GAAG,CAAC,eAAe,UAAU,CAAC;AAE9B,QAAM,oBAAoBA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKxB,CAAC,MAAM;AACL,UAAI,eAAe;AACjB,UAAE,eAAe;AACjB,iBAAS;AACT;AAAA,MACF;AACA,oBAAc,EAAE,cAAc,KAAK;AACnC,UAAI,CAAC,4BAA4B,SAAS;AACxC,0BAAkB,IAAI;AAAA,MACxB;AAAA,IACF;AAAA,IACA,CAAC,mBAAmB,eAAe,QAAQ;AAAA,EAC7C;AAEA,QAAM,wBAAwBA;AAAA;AAAA;AAAA;AAAA;AAAA,IAK5B,CAACC,WAAU;AACT,8BAAwBA,MAAK;AAAA,IAC/B;AAAA,IACA,CAAC;AAAA,EACH;AAQA,QAAM,qCAAqCF,QAAO,IAAI;AACtD,QAAM,qCAAqCA;AAAA;AAAA,IAAuC;AAAA,EAAK;AAEvF,QAAM,mBAAmBC,aAAY,MAAM;AACzC,iBAAa,IAAI;AACjB,iBAAa,eAAe,OAAO;AACnC,mBAAe,UAAU;AACzB,QAAI,eAAe;AACjB,UAAI,CAAC,wBAAwB,SAAS;AACpC,iBAAS;AAAA,MACX;AACA,8BAAwB,UAAU;AAAA,IACpC,OAAO;AACL,wBAAkB,IAAI;AACtB,kCAA4B,UAAU;AACtC,UAAI,CAAC,mCAAmC,SAAS;AAC/C,2CAAmC,UAAU,2BAA2B;AAAA,UACtE,gBAAgB,WAAW;AACzB,+CAAmC,UAAU,CAAC;AAAA,UAChD;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AACA,gCAA4B,WAAW;AAAA,EACzC,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAGD,QAAM,kBAAkBA,aAAY,MAAM;AACxC,iBAAa,KAAK;AAClB,iBAAa,eAAe,OAAO;AACnC,mBAAe,UAAU;AACzB,kBAAc;AACd,gCAA4B,UAAU;AAEtC,QAAI,CAAC,UAAU;AACb,UAAI,iBAAiB,iBAAiB,iBAAiB,YAAY,IAAI;AACrE,2BAAmB,YAAY;AAAA,MACjC;AAAA,IACF;AACA,kBAAc,EAAE;AAChB,iCAA6B,EAAE;AAC/B,QAAI,CAAC,eAAe;AAClB,yCAAmC,UAAU;AAC7C,yCAAmC,UAAU;AAC7C,yCAAmC,UAAU;AAAA,IAC/C;AAAA,EACF,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAM,qBAAqBA;AAAA;AAAA;AAAA;AAAA,IAIzB,CAAC,aAAa;AACZ,yBAAmB,QAAQ;AAE3B,wBAAkB,SAAS,oBAAoB,QAAQ;AAAA,IACzD;AAAA,IACA,CAAC,kBAAkB;AAAA,EACrB;AAKA,QAAM,gBAAgBA;AAAA;AAAA;AAAA;AAAA,IAIpB,CAAC,MAAM;AACL,UAAI,EAAE,QAAQ,SAAS;AACrB,UAAE,eAAe;AAEjB,cAAM,WAAW,kBAAkB,SAAS,aAAa;AAEzD,YAAI,CAAC,YAAY,iBAAiB,iBAAiB,IAAI;AACrD,6BAAmB,YAAY;AAAA,QACjC;AAAA,MACF,WAAW,EAAE,QAAQ,aAAa;AAChC,UAAE,eAAe;AACjB,0BAAkB,IAAI;AACtB,oCAA4B,UAAU;AAEtC,0BAAkB,SAAS,aAAa;AAAA,MAC1C,WAAW,EAAE,QAAQ,WAAW;AAC9B,UAAE,eAAe;AACjB,0BAAkB,IAAI;AACtB,oCAA4B,UAAU;AAEtC,0BAAkB,SAAS,WAAW;AAAA,MACxC,WAAW,EAAE,QAAQ,UAAU;AAC7B,sBAAc,IAAI;AAAA,MACpB,WAAW,EAAE,QAAQ,WAAW,EAAE,WAAW,CAAC,eAAe,kBAAkB,GAAG;AAChF,UAAE,eAAe;AACjB,0BAAkB,SAAS,gBAAgB;AAAA,MAC7C,WAAW,EAAE,QAAQ,UAAU,EAAE,WAAW,CAAC,eAAe,kBAAkB,GAAG;AAC/E,UAAE,eAAe;AACjB,0BAAkB,SAAS,eAAe;AAAA,MAC5C,WAAW,EAAE,QAAQ,YAAY;AAC/B,UAAE,eAAe;AACjB,0BAAkB,IAAI;AACtB,oCAA4B,UAAU;AACtC,0BAAkB,SAAS,iBAAiB;AAAA,MAC9C,WAAW,EAAE,QAAQ,UAAU;AAC7B,UAAE,eAAe;AACjB,0BAAkB,IAAI;AACtB,oCAA4B,UAAU;AACtC,0BAAkB,SAAS,eAAe;AAAA,MAE5C,WAAW,eAAe,OAAO,EAAE,WAAW,EAAE,YAAY,EAAE,QAAQ,KAAK;AACzE,UAAE,eAAe;AACjB,cAAM,aAAa,UAAU,QAAQ,IAAI;AACzC,YAAI,YAAY;AACd,mBAAS,UAAU;AACnB,sCAA4B,UAAU;AACtC,oBAAU,QAAQ,KAAK,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC;AAAA,QAC/D;AAAA,MAEF,WAAW,eAAe,OAAO,EAAE,WAAW,EAAE,YAAY,EAAE,QAAQ,KAAK;AACzE,UAAE,eAAe;AACjB,cAAM,aAAa,UAAU,QAAQ,IAAI;AACzC,YAAI,YAAY;AACd,mBAAS,UAAU;AACnB,sCAA4B,UAAU;AACtC,oBAAU,QAAQ,KAAK,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC;AAAA,QAC/D;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAIA,QAAM,cAAcA;AAAA;AAAA;AAAA;AAAA,IAIlB,CAAC,MAAM;AAEL,UAAI,CAAC,OAAQ;AAIb,YAAM,aAAa,OAAO,OAAO,gBAAgB;AAEjD,YAAM,eAAe;AAAA,QACnB,GAAG,OAAO,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AAAA,QAC/C,GAAG,OAAO,YAAY,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;AAAA,MACjE;AAEA,YAAM,wBAAwB;AAAA,QAC5B,GAAG,OAAO,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,EAAE,YAAY,GAAG,CAAC,CAAC,CAAC;AAAA,QAC7D,GAAG,OAAO,YAAY,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,MAAM,YAAY,GAAG,EAAE,KAAK,CAAC,CAAC;AAAA,MAC/E;AAEA,YAAM,qBAAqB,OAAO;AAAA,QAChC,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,MAAM,YAAY,GAAG,EAAE,KAAK,CAAC;AAAA,MACxD;AACA,YAAM,aAAa,EAAE,eAAe,QAAQ,MAAM,KAAK;AACvD,UAAI,CAAC,WAAY;AACjB,YAAM,gBAAgB,WACnB,MAAM,GAAG,EACT,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,EACnB,OAAO,CAAC,MAAM,MAAM,EAAE,EACtB;AAAA,QACC,CAAC,MACC,aAAa,CAAC,KACd,sBAAsB,EAAE,YAAY,CAAC,KACrC,mBAAmB,EAAE,kBAAkB,CAAC,KACxC;AAAA,MACJ;AAEF,YAAM,YAAY,OAAO,CAAC,GAAG,QAAQ,GAAG,aAAa,CAAC;AACtD,eAAS,SAAS;AAClB,kCAA4B,WAAW,OAAO;AAC9C,gBAAU,QAAQ,KAAK,MAAM;AAC7B,gBAAU,UAAU,CAAC;AAAA,IAEvB;AAAA,IACA,CAAC,kBAAkB,UAAU,QAAQ,2BAA2B;AAAA,EAClE;AAEA,QAAM,mBAAmBA,aAAY,MAAM;AACzC,kBAAc,EAAE;AAChB,aAAS,WAAW,CAAC,IAAI,EAAE;AAC3B,gCAA4B,aAAa,SAAS;AAClD,cAAU,QAAQ,KAAK,WAAW;AAClC,cAAU,UAAU,CAAC;AAGrB,QAAI,aAAa,GAAG;AAClB,iBAAW;AAAA,IACb;AAAA,EACF,GAAG,CAAC,UAAU,UAAU,aAAa,6BAA6B,cAAc,UAAU,CAAC;AAE3F,QAAM,yBAAyBA,aAAY,MAAM;AAC/C,QAAI,CAAC,UAAU;AACb,UAAI,eAAe;AACjB,iBAAS;AAAA,MACX,OAAO;AACL,YAAI,SAAS,WAAW,SAAS,kBAAkB,SAAS,SAAS;AAEnE,qBAAW,IAAI;AAAA,QACjB;AAGA,0BAAkB,IAAI;AACtB,oCAA4B,UAAU;AAAA,MACxC;AAAA,IACF;AAAA,EACF,GAAG,CAAC,UAAU,eAAe,UAAU,YAAY,iBAAiB,CAAC;AAGrE,QAAM,iBAAiBF;AAAA,IACrB,MACE,uBACI,YACG,IAAI,CAAC,QACJ,gBAAAJ,KAAC,YAAiB,OAAO,KAAK,UAAU,iBAAiB,GAAG,GAAG,UAC5D,2BAAiB,GAAG,GAAG,SAAS,OADtB,GAEb,CACD,EACA;AAAA,MACC,OAAO,mBAAmB,aACtB,eACG,OAAO,CAAC,MAAM,CAAC,kBAAkB,IAAI,EAAE,KAAK,CAAC,EAC7C,MAAM,GAAG,8BAA8B,YAAY,MAAM,EACzD,IAAI,CAAC,MACJ,gBAAAA,KAAC,YAAqB,OAAO,EAAE,OAAO,UAAU,EAAE,UAC/C,YAAE,SADQ,EAAE,KAEf,CACD,IACH,CAAC;AAAA,IACP,IACF;AAAA,IACN;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,EAAAG,WAAU,MAAM;AAEd,QAAI,aAAa,YAAY;AAC3B,6BAAuB,mBAAmB,0BAA0B;AAAA,IACtE,WAAW,uBAAuB,CAAC,aAAa,YAAY;AAG1D;AAAA,QACE,gBAAgB,SACZ,mBAAmB,4BACnB,mBAAmB;AAAA,MACzB;AAEA,YAAM,QAAQ,WAAW,MAAM;AAC7B,+BAAuB,EAAE;AAAA,MAC3B,GAAG,GAAI;AACP,aAAO,MAAM,aAAa,KAAK;AAAA,IACjC,WAAW,uBAAuB,CAAC,YAAY;AAE7C,6BAAuB,EAAE;AAAA,IAC3B;AAAA,EACF,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA,gBAAgB;AAAA,IAChB,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,EACrB,CAAC;AAGD,QAAM,mBAAmB,YAAY;AAGrC,QAAM,iBAAiBG;AAAA;AAAA,IAErB,CAAC,OAAO;AACN,wBAAkB,UAAU;AAAA,IAC9B;AAAA,IACA,CAAC;AAAA,EACH;AAEA,QAAM,iBAAiB,CAAC,WACtB,gBAAAN;AAAA,IAAC;AAAA;AAAA,MACC,KAAK;AAAA,MACL;AAAA,MACA,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,MAChB,0BAA0B;AAAA,MAC1B,SAAS,gBAAgB,YAAY;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA;AAAA,EACF,IACE;AAEJ,SACE,gBAAAC;AAAA,IAAC;AAAA;AAAA,MACC,WAAW;AAAA,QACT;AAAA,QACA;AAAA,QACA,WAAW,6BAA6B;AAAA,QACxC,mBAAmB,KAAK;AAAA,QACxB,SAAS,SAAS,6BAA6B;AAAA,MACjD,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AAAA,MACX,iBAAe;AAAA,MACf,SAAS;AAAA,MACT,IAAI,GAAG,EAAE;AAAA,MACT,KAAK;AAAA,MACJ,GAAG;AAAA,MAGJ;AAAA,wBAAAD,KAAC,SAAI,WAAU,yBAAwB,aAAU,UAAS,eAAY,QACnE,uBAAa,IAAI,4BAA4B,IAChD;AAAA,QAGA,gBAAAA,KAAC,SAAI,WAAU,yBAAwB,aAAU,UAAS,eAAY,QACnE,uBAAa,IAAI,sBAAsB,IAC1C;AAAA,QAGA,gBAAAA,KAAC,SAAI,WAAU,yBAAwB,aAAU,UAAS,eAAY,QACnE,wBAAc,SAAS,KAAK,aAAa,IACtC,mBAAmB,6BACnB,IACN;AAAA,QAEA,gBAAAC,MAAC,SAAI,WAAW,wBAAwB,WAAW,mCAAmC,EAAE,IACrF;AAAA,WAAC,oBACA,gBAAAA,MAAAF,WAAA,EAEG;AAAA,aAAC,YACA,qBACA,iBAAiB,iBAAiB,KAClC,qBAAqB,iBAAiB,iBAAiB,GAAG,IAAI;AAAA,YAChE,gBAAAC;AAAA,cAAC;AAAA;AAAA,gBACC;AAAA,gBACA,KAAK;AAAA,gBACL,MAAK;AAAA,gBACL,OAAO;AAAA,gBACP,aACE,CAAC,iBAAiB,kBAAkB,IAChC,mBAAmB,oBACnB,YAAY,SAAS,IACnB,YAAY,IAAI,CAACO,WAAU,iBAAiBA,MAAK,GAAG,SAASA,MAAK,EAAE,KAAK,IAAI,IAC7E;AAAA,gBAER,UAAU;AAAA,gBACV,WAAW;AAAA,gBACX,SAAS;AAAA,gBACT,QAAQ,MAAM;AAEZ,iCAAe,UAAU,WAAW,iBAAiB,GAAG;AAAA,gBAC1D;AAAA,gBACA,SAAS;AAAA,gBACT,WAAW,wBACT,WAAW,mCAAmC,EAChD,IAAI,WAAW,mCAAmC,EAAE;AAAA,gBACpD,MAAK;AAAA,gBACL,iBAAe,kBAAkB;AAAA,gBACjC,iBAAc;AAAA,gBACd,iBAAe,GAAG,EAAE;AAAA,gBACpB,yBACE,wBACI,GAAG,EAAE,WAAW,SAAS,qBAAqB,CAAC,KAC/C;AAAA,gBAEN;AAAA,gBACA,UAAU,YAAY,YAAY,WAAW;AAAA,gBAC5C,GAAG;AAAA;AAAA,YACN;AAAA,YACC,CAAC,YAAY,mBAAmB,YAAY,SAAS,IACpD,gBAAAP;AAAA,cAAC;AAAA;AAAA,gBACC,MAAK;AAAA,gBACL,WAAU;AAAA,gBACV,cAAY,mBAAmB;AAAA,gBAC/B,SAAS;AAAA,gBAET,0BAAAA,KAAC,UAAK,eAAY,QAAO,oBAAQ;AAAA;AAAA,YACnC,IACE;AAAA,YACH,cAAc,SAAS,KACtB,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBACC,KAAK;AAAA,gBACL,WAAU;AAAA,gBACV,cAAc,MAAM,sBAAsB,IAAI;AAAA,gBAC9C,cAAc,MAAM,sBAAsB,KAAK;AAAA,gBAE9C;AAAA;AAAA,YACH;AAAA,YAED,YAAY,YAAY,SAAS,KAChC,gBAAAA,KAAC,UAAK,WAAU,wBACb,6BAAmB,uBAAuB,YAAY,QAAQ,QAAQ,GACzE;AAAA,YAED;AAAA,aACH;AAAA,UAID,uBACC,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACE,GAAG;AAAA,cACJ;AAAA,cACA,QAAQ,CAAC;AAAA,cACT,UAAU,mBAAmB,IAAI;AAAA,cACjC,UAAU,CAAC;AAAA,cAEX;AAAA,cACA;AAAA,cACA,MAAM;AAAA,cACN,WAAW,mBAAmB,8BAA8B;AAAA,cAE3D;AAAA;AAAA,UACH,IACE;AAAA,WACN;AAAA,QAEC,iBACC,gBAAAA,KAAC,UAAO,QAAQ,QAAQ,gBACrB,0BACC,gBAAAA;AAAA,UAAC;AAAA;AAAA,YACC;AAAA,YACA,QAAQ,cAAc;AAAA,YACtB,SAAS;AAAA,YACT,WAAW,aAAa,KAAK;AAAA,YAC7B;AAAA,YACA,cAAc;AAAA,YACd,eAAe;AAAA,YAEd;AAAA;AAAA,QACH,IAEA,gBAEJ,IACE;AAAA,QACH,cAAc,SAAS,KAAK,sBAAsB,CAAC,YAClD,gBAAAA,KAAC,UAAO,QAAQ,QAAQ,gBACtB,0BAAAC;AAAA,UAAC;AAAA;AAAA,YACC,WAAW,+BAA+B,mBAAmB,KAAK,EAAE;AAAA,YACpE,MAAK;AAAA,YACL,KAAK;AAAA,YAEJ;AAAA,iCAAmB;AAAA,cACnB,cAAc,IAAI,CAACM,WAClB,gBAAAP,KAAC,SAAgB,WAAU,+BACxB,UAAAO,UADOA,MAEV,CACD;AAAA;AAAA;AAAA,QACH,GACF;AAAA;AAAA;AAAA,EAEJ;AAEJ;AAEA,IAAO,yBAAQ;",
  "names": ["useCallback", "useEffect", "useMemo", "useRef", "useState", "querySegments", "matches", "jsx", "useCallback", "useEffect", "useRef", "useState", "useCallback", "useEffect", "useRef", "useState", "useRef", "useState", "useCallback", "useEffect", "jsx", "jsxs", "useState", "useRef", "useCallback", "useEffect", "Fragment", "jsx", "jsxs", "useState", "useEffect", "useMemo", "useRef", "useCallback", "value"]
}
