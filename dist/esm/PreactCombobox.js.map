{
  "version": 3,
  "sources": ["../../lib/PreactCombobox.jsx", "../../lib/hooks.js"],
  "sourcesContent": ["import { createPopper } from \"@popperjs/core\";\nimport { createPortal } from \"preact/compat\";\nimport {\n  useCallback,\n  useEffect,\n  useId,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"preact/hooks\";\nimport { useDeepMemo, useLive } from \"./hooks.js\";\nimport \"./PreactCombobox.css\";\n\n// --- types ---\n/**\n * @typedef {Object} Option\n * @property {string} label - The display text for the option\n * @property {string} value - The value of the option\n * @property {VNode | string} [icon] - Optional icon element or URL to display before the label\n * @property {boolean} [disabled] - Whether the option is disabled and cannot be selected\n * @property {boolean} [divider] - Whether to show a divider line below this option (only when search is empty)\n */\n\n/**\n * @typedef {Object} OptionMatch\n * @property {string} label - The display text for the option\n * @property {string} value - The value of the option\n * @property {VNode|string} [icon] - Optional icon element or URL to display before the label\n * @property {boolean} [disabled] - Whether the option is disabled and cannot be selected\n * @property {boolean} [divider] - Whether to show a divider line below this option (only when search is empty)\n * @property {number} score - The match score\n * @property {'value' | 'label' | 'none'} matched - The match type\n * @property {Array<[number, number]>} matchSlices - The match slices\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/**\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @callback OptionTransformFunction\n * @param {Object} params\n * @param {OptionMatch} params.option\n * @param {string} params.language\n * @param {boolean} params.isSelected\n * @param {boolean} params.isInvalid\n * @param {boolean} params.isActive Active does not mean selected. Active means the option is being hovered over / keyboard focused over.\n * @param {boolean} params.showValue\n * @param {VNode} [params.warningIcon]\n * @param {VNode} [params.tickIcon]\n * @param {(option: Option, isInput?: boolean) => VNode|null} [params.optionIconRenderer] Read PreactComboboxProps\n * `optionIconRenderer` for more details.\n * @returns {VNode}\n */\n\n/**\n * @typedef {Object} Translations\n * @property {string} searchPlaceholder - Placeholder text for search input\n * @property {string} noOptionsFound - Text shown when no options match the search\n * @property {string} loadingOptions - Text shown when options are loading\n * @property {string} loadingOptionsAnnouncement - Announcement when options are loading (screen reader)\n * @property {string} optionsLoadedAnnouncement - Announcement when options finish loading (screen reader)\n * @property {string} noOptionsFoundAnnouncement - Announcement when no options found (screen reader)\n * @property {string} addOption - Text for adding a new option (includes {value} placeholder)\n * @property {string} typeToLoadMore - Text shown when more options can be loaded\n * @property {string} clearValue - Aria label for clear button\n * @property {string} selectedOption - Screen reader text for selected options\n * @property {string} invalidOption - Screen reader text for invalid options\n * @property {string} invalidValues - Header text for invalid values tooltip\n * @property {string} fieldContainsInvalidValues - Announcement for invalid values (screen reader)\n * @property {string} noOptionsSelected - Announcement when no options are selected\n * @property {string} selectionAdded - Announcement prefix when selection is added\n * @property {string} selectionRemoved - Announcement prefix when selection is removed\n * @property {string} selectionsCurrent - Announcement prefix for current selections\n * @property {string} selectionsMore - Text for additional options (singular)\n * @property {string} selectionsMorePlural - Text for additional options (plural)\n * @property {(count: number, language: string) => string} selectedCountFormatter - Function to format the count in the badge\n */\n\n/**\n * @typedef {Object} PreactComboboxProps\n * @property {string} id The id of the component\n * @property {boolean} [multiple=true] Multi-select or single-select mode\n * @property {Option[]\n * | ((\n *   queryOrValues: string[] | string,\n *   limit: number,\n *   currentSelections: string[],\n *   abortControllerSignal: AbortSignal\n * ) => Promise<Option[]>)} allowedOptions Array of allowed options or function to fetch allowed options\n * @property {boolean} [allowFreeText=false] Allow free text input\n * @property {(options: string[] | string) => void} onChange Callback when selection changes\n * @property {string[] | string} value Currently selected options (array for multi-select, string for single-select)\n * @property {string} [language='en'] BCP 47 language code for word splitting and matching. The language can be any language tag\n * recognized by Intl.Segmenter and Intl.Collator\n * @property {boolean} [showValue=false] experimental feature.\n * @property {boolean} [disabled=false] Disable the component\n * @property {boolean} [required=false] Is required for form submission\n * @property {boolean} [showClearButton=true] Show the clear button for single-select mode\n * @property {string} [name] name to be set on hidden select element\n * @property {string} [className] Additional class names for the component\n * @property {string} [placeholder] Input placeholder text shown when no selections are made\n * @property {'light' | 'dark' | 'system'} [theme='system'] Theme to use - 'light', 'dark', or 'system' (follows data-theme attribute)\n * @property {boolean | 'auto'} [tray=false] Enable mobile tray mode - true/false or 'auto' for media query detection\n * @property {string} [trayBreakpoint='768px'] CSS breakpoint for auto tray mode (e.g., '768px', '50rem')\n * @property {string} [trayLabel] Label text for the tray header (auto-detects from associated label if not provided)\n * @property {Translations} [translations] Custom translation strings\n *\n * @property {Record<string, any>} [rootElementProps] Root element props\n * @property {Record<string, any>} [inputProps] Input element props\n * @property {boolean} [formSubmitCompatible=false] Render a hidden select for progressive enhanced compatible form submission\n * @property {boolean} [isServer] Whether the component is rendered on the server (auto-detected if not provided).\n * This prop is only relevant if formSubmitCompatible is true.\n * @property {Record<string, any>} [selectElementProps] Props for the hidden select element. This is useful for forms\n *\n * @property {HTMLElement} [portal=document.body] The element to render the Dropdown <ul> element\n * @property {OptionTransformFunction} [optionRenderer=identity] Transform the label text\n * @property {(option: Option, isInput?: boolean) => VNode|null} [optionIconRenderer] Custom icon renderer for options.\n * isInput is `true` when rendering the icon besides the input element in single-select mode.\n * It's `undefined` or `false` when rendering the icon besides each option.\n * This function is also passed into `optionRenderer` as an argument instead of being used directly for option rendering.\n * @property {VNode} [warningIcon] Custom warning icon element or component\n * @property {VNode} [tickIcon] Custom tick icon element or component for selected options\n * @property {VNode} [chevronIcon] Custom chevron icon element or component\n * @property {(text: string) => VNode|string} [loadingRenderer] Custom loading indicator element or text\n *\n * @property {number} [maxNumberOfPresentedOptions=100] - [private property - do not use] Maximum number of options to present\n */\n\n// --- end of types ---\n\n/** @type {Translations} */\nconst defaultEnglishTranslations = {\n  searchPlaceholder: \"Search...\",\n  noOptionsFound: \"No options found\",\n  loadingOptions: \"Loading...\",\n  loadingOptionsAnnouncement: \"Loading options, please wait...\",\n  optionsLoadedAnnouncement: \"Options loaded.\",\n  noOptionsFoundAnnouncement: \"No options found.\",\n  addOption: 'Add \"{value}\"',\n  typeToLoadMore: \"...type to load more options\",\n  clearValue: \"Clear value\",\n  selectedOption: \"Selected option.\",\n  invalidOption: \"Invalid option.\",\n  invalidValues: \"Invalid values:\",\n  fieldContainsInvalidValues: \"Field contains invalid values\",\n  noOptionsSelected: \"No options selected\",\n  selectionAdded: \"added selection\",\n  selectionRemoved: \"removed selection\",\n  selectionsCurrent: \"currently selected\",\n  selectionsMore: \"and {count} more option\",\n  selectionsMorePlural: \"and {count} more options\",\n  // Function to format the count in badge, receives count and language as parameters\n  selectedCountFormatter: (count, lang) => new Intl.NumberFormat(lang).format(count),\n};\n\n// @ts-ignore\nconst isPlaywright = navigator.webdriver === true;\n\n// Auto-detect server-side rendering\nconst isServerDefault = typeof self === \"undefined\";\n\n/**\n * @param {string[]} arr Array to remove duplicates from\n */\nfunction unique(arr) {\n  return Array.from(new Set(arr));\n}\n\n/**\n * Converts any text into a valid HTML ID attribute value.\n * Returns empty string if text becomes empty after removing invalid characters.\n *\n * @param {string} text - The text to convert into an HTML ID\n * @returns {string} A valid HTML ID or empty string\n */\nfunction toHTMLId(text) {\n  // Remove any characters that are not letters, numbers, hyphens, underscores, colons, or periods\n  return text.replace(/[^a-zA-Z0-9\\-_:.]/g, \"\");\n}\n\n/**\n * @template {OptionMatch|Option} T\n * @param {T[]} options\n * @param {string[]} values\n * @returns {T[]}\n */\nfunction sortValuesToTop(options, values) {\n  const selectedSet = new Set(values);\n  return options.sort((a, b) => {\n    const aSelected = selectedSet.has(a.value);\n    const bSelected = selectedSet.has(b.value);\n    if (aSelected === bSelected) return 0;\n    return aSelected ? -1 : 1;\n  });\n}\n\n/**\n * @param {Object} props - Props for the PopperContent component\n * @param {HTMLElement} [props.parent=document.body] The parent element to render the PopperContent component\n * @param {VNode} props.children The children to render\n * @param {React.RefObject<HTMLElement>} [props.rootElementRef] Reference to the source element to get direction context\n */\nconst Portal = ({ parent = document.body, children, rootElementRef }) => {\n  const [dir, setDir] = useState(/** @type {string|null} */ (null));\n\n  useEffect(() => {\n    if (rootElementRef?.current) {\n      const rootDir = window.getComputedStyle(rootElementRef.current).direction;\n      const parentDir = window.getComputedStyle(parent).direction;\n      if (rootDir !== parentDir) {\n        setDir(rootDir);\n      } else {\n        setDir(null);\n      }\n    }\n  }, [rootElementRef, parent]);\n\n  const wrappedChildren = dir ? (\n    <div dir={/** @type {\"auto\" | \"rtl\" | \"ltr\"} */ (dir)} style={{ direction: dir }}>\n      {children}\n    </div>\n  ) : (\n    children\n  );\n\n  return createPortal(wrappedChildren, parent);\n};\n\n// Popper.js helper\nconst dropdownPopperModifiers = [\n  {\n    name: \"flip\",\n    enabled: true,\n  },\n  {\n    // make the popper width same as root element\n    name: \"referenceElementWidth\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    requires: [\"computeStyles\"],\n    // @ts-ignore\n    fn: ({ state }) => {\n      state.styles.popper.minWidth = `${state.rects.reference.width}px`;\n    },\n    // @ts-ignore\n    effect: ({ state }) => {\n      state.elements.popper.style.minWidth = `${state.elements.reference.offsetWidth}px`;\n    },\n  },\n  {\n    name: \"eventListeners\",\n    enabled: true,\n    options: {\n      scroll: true,\n      resize: true,\n    },\n  },\n];\n\nconst tooltipPopperModifiers = [\n  {\n    name: \"offset\",\n    options: {\n      offset: [0, 2],\n    },\n  },\n  {\n    name: \"eventListeners\",\n    enabled: true,\n    options: {\n      scroll: true,\n      resize: true,\n    },\n  },\n];\n\nconst isTouchDevice =\n  typeof window !== \"undefined\" && window.matchMedia?.(\"(pointer: coarse)\")?.matches;\n// Since page hasn't potentially fully loaded yet we get only an approximate height\nlet visualViewportInitialHeight = window.visualViewport?.height ?? 0;\nlet wasVisualViewportInitialHeightAnApproximate = true;\n\n/**\n * Subscribe to virtual keyboard visibility changes (touch devices only)\n * @param {Object} params - Parameters for subscribing to virtual keyboard\n * @param {function(boolean): void} [params.visibleCallback] - Called with boolean when keyboard visibility changes\n * @param {function(number, boolean): void} [params.heightCallback] - Called with keyboard height when keyboard height changes\n * @returns {function | null} - Unsubscribe function\n */\nexport function subscribeToVirtualKeyboard({ visibleCallback, heightCallback }) {\n  if (!isTouchDevice || typeof window === \"undefined\" || !window.visualViewport) return null;\n\n  let isVisible = false;\n  const handleViewportResize = () => {\n    if (!window.visualViewport) return;\n    const heightDiff = visualViewportInitialHeight - window.visualViewport.height;\n    const isVisibleNow = heightDiff > 150;\n    if (isVisible !== isVisibleNow) {\n      isVisible = isVisibleNow;\n      visibleCallback?.(isVisible);\n    }\n    heightCallback?.(heightDiff, isVisible);\n  };\n  window.visualViewport.addEventListener(\"resize\", handleViewportResize, { passive: true });\n  return () => {\n    window.visualViewport?.removeEventListener(\"resize\", handleViewportResize);\n  };\n}\n\n/** @type {Record<string, LanguageCache>} */\nconst languageCache = {};\n\n/**\n * @param {string} query\n * @param {Option} option\n * @param {string} language\n * @returns {OptionMatch|null}\n */\nfunction getExactMatchScore(query, option, language) {\n  const { label, value, ...rest } = option;\n  if (value === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (label === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  const { caseMatcher } = /** @type {LanguageCache} */ (languageCache[language]);\n  if (caseMatcher.compare(value, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (caseMatcher.compare(label, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  return null;\n}\n\n/**\n * Calculates the match score between a query text and a list of option labels.\n * It returns scores for each option sorted in descending order.\n *\n * It takes the `query` string, evaluates the following rules in order and assigns the one with highest score:\n * - Score 7: If whole query matches a label on an option (Case insensitive match)\n * - Score 5: Same as previous check but this time case and accent insensitive matching\n * - Score 3: Phrase matching (e.g. \"word1 partialWord2*\")\n * - Score 0-1: Number of words matched / total number of words in query (e.g. \"word1\")\n *\n * @param {string} query - The query text to match against options.\n * @param {Option[]} options\n * @param {string} [language='en'] Language to use for word splitting and matching\n * @param {boolean} [filterAndSort=true] Whether to filter and sort the results. If false, returns all options but with attempted matches.\n * @returns {Array<OptionMatch>}\n */\nfunction getMatchScore(query, options, language = \"en\", filterAndSort = true) {\n  // biome-ignore lint/style/noParameterAssign: ignore\n  query = query.trim();\n\n  if (!query) {\n    const matchSlices = /** @type {Array<[number, number]>} */ ([]);\n    return options.map((option) => ({\n      ...option,\n      label: option.label,\n      value: option.value,\n      score: 0,\n      matched: \"none\",\n      matchSlices,\n    }));\n  }\n\n  if (!languageCache[language]) {\n    languageCache[language] = {\n      baseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"base\",\n      }),\n      caseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"accent\",\n      }),\n      wordSegmenter: new Intl.Segmenter(language, {\n        granularity: \"word\",\n      }),\n    };\n  }\n  const { baseMatcher, caseMatcher, wordSegmenter } = languageCache[language];\n\n  const isCommaSeparated = query.includes(\",\");\n\n  let matches = options.map((option) => {\n    const { label, value, ...rest } = option;\n    if (isCommaSeparated) {\n      const querySegments = query.split(\",\");\n      const matches = querySegments\n        .map((querySegment) => getExactMatchScore(querySegment.trim(), option, language))\n        .filter((match) => match !== null)\n        .sort((a, b) => b.score - a.score);\n      return /** @type {OptionMatch} */ (\n        matches[0] || {\n          ...rest,\n          label,\n          value,\n          score: 0,\n          matched: \"none\",\n        }\n      );\n    }\n\n    // Rule 1: Exact match (case sensitive)\n    // Rule 2: Exact match (case insensitive)\n    const exactMatch = getExactMatchScore(query, option, language);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Rule 3: Exact match with accents normalized (case insensitive)\n    if (baseMatcher.compare(label, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'label'} */\n        matched: \"label\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, label.length]],\n      };\n    }\n    if (baseMatcher.compare(value, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, value.length]],\n      };\n    }\n\n    // Rule 4: Phrase match (imagine a wildcard query like \"word1 partialWord2*\")\n    // This match needs to be case and accent insensitive\n    const querySegments = Array.from(wordSegmenter.segment(query));\n    const labelWordSegments = Array.from(wordSegmenter.segment(label.trim()));\n    let len = 0;\n    let firstIndex = -1;\n    for (let i = 0; i < labelWordSegments.length; i++) {\n      const labelWordSegment = /** @type {Intl.SegmentData} */ (labelWordSegments[i]);\n      const querySegment = querySegments[len];\n      if (!querySegment) break;\n      if (len === querySegments.length - 1) {\n        // check for partial word match\n        // I can't use labelWordSegment.segment.startsWith(querySegment.segment) because it's case and accent sensitive\n        const lastQueryWord = querySegment.segment;\n        if (\n          baseMatcher.compare(\n            labelWordSegment.segment.slice(0, lastQueryWord.length),\n            lastQueryWord,\n          ) === 0\n        ) {\n          return {\n            ...rest,\n            label,\n            value,\n            score: 3,\n            /** @type {'label'} */\n            matched: \"label\",\n            /** @type {Array<[number, number]>} */\n            // @ts-ignore\n            matchSlices: [\n              [\n                firstIndex > -1 ? firstIndex : labelWordSegment.index,\n                labelWordSegment.index + lastQueryWord.length,\n              ],\n            ],\n          };\n        }\n      } else if (baseMatcher.compare(labelWordSegment.segment, querySegment.segment) === 0) {\n        len++;\n        if (len === 1) {\n          firstIndex = labelWordSegment.index;\n        }\n        continue;\n      }\n      len = 0;\n      firstIndex = -1;\n    }\n    // Also check for partial value match (this doesn't need accent check)\n    if (caseMatcher.compare(value.slice(0, query.length), query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 3,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, query.length]],\n      };\n    }\n\n    // Rule 5: Word matches\n    const queryWords = querySegments.filter((s) => s.isWordLike);\n    const labelWords = labelWordSegments.filter((s) => s.isWordLike);\n    /** @type {Array<[number, number]|undefined>} */\n    const slices = queryWords.map((word) => {\n      const match = labelWords.find(\n        (labelWord) => baseMatcher.compare(labelWord.segment, word.segment) === 0,\n      );\n      if (match) {\n        return [match.index, match.index + match.segment.length];\n      }\n    });\n    // TODO: Do we need a deep equal de-duplication here?\n    const matchSlices = slices.filter((s) => s !== undefined).sort((a, b) => a[0] - b[0]);\n    const wordScoring = matchSlices.length / queryWords.length;\n    return {\n      ...rest,\n      label,\n      value,\n      score: wordScoring,\n      /** @type {'label'|'none'} */\n      matched: wordScoring ? \"label\" : \"none\",\n      matchSlices,\n    };\n  });\n\n  if (filterAndSort) {\n    matches = matches.filter((match) => match.score > 0);\n    matches.sort((a, b) => {\n      if (a.score === b.score) {\n        const val = a.label.localeCompare(b.label, undefined, {\n          sensitivity: \"base\",\n        });\n        return val === 0 ? a.value.localeCompare(b.value, undefined, { sensitivity: \"base\" }) : val;\n      }\n      return b.score - a.score;\n    });\n  }\n  return matches;\n}\n\n/**\n * @param {OptionMatch['matchSlices']} matchSlices\n * @param {string} text\n * @returns {VNode[]}\n */\nexport function matchSlicesToNodes(matchSlices, text) {\n  const nodes = /** @type {VNode[]} */ ([]);\n  let index = 0;\n  matchSlices.map((slice) => {\n    const [start, end] = slice;\n    // console.log(slice);\n    if (index < start) {\n      // console.log(label.slice(index, start));\n      nodes.push(<span key={`${index}-${start}`}>{text.slice(index, start)}</span>);\n    }\n    // console.log(label.slice(start, end));\n    nodes.push(<u key={`${start}-${end}`}>{text.slice(start, end)}</u>);\n    index = end;\n  });\n  if (index < text.length) {\n    // console.log(label.slice(index));\n    nodes.push(<span key={`${index}-${text.length}`}>{text.slice(index)}</span>);\n  }\n  return nodes;\n}\n\n// Default icons\nconst defaultWarningIcon = (\n  <svg\n    className=\"PreactCombobox-warningIcon\"\n    viewBox=\"0 0 24 24\"\n    width=\"24\"\n    height=\"24\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z\" />\n  </svg>\n);\n\nconst defaultTickIcon = (\n  <svg\n    className=\"PreactCombobox-tickIcon\"\n    viewBox=\"0 0 24 24\"\n    width=\"14\"\n    height=\"14\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\" fill=\"currentColor\" />\n  </svg>\n);\n\nconst defaultChevronIcon = (\n  <svg\n    className=\"PreactCombobox-chevron\"\n    viewBox=\"0 0 24 24\"\n    width=\"24\"\n    height=\"24\"\n    aria-hidden=\"true\"\n  >\n    <path d=\"M7 10l5 5 5-5z\" />\n  </svg>\n);\n\n/** @type {NonNullable<PreactComboboxProps['loadingRenderer']>} */\nconst defaultLoadingRenderer = (loadingText) => loadingText;\n\n/** @type {OptionTransformFunction} */\nexport function defaultOptionRenderer({\n  option,\n  isSelected,\n  isInvalid,\n  showValue,\n  warningIcon,\n  tickIcon,\n  optionIconRenderer,\n}) {\n  const isLabelSameAsValue = option.value === option.label;\n  /**\n   * @param {(VNode|string)[]} labelNodes\n   * @param {(VNode|string)[]} valueNodes\n   * @returns {VNode}\n   */\n  const getLabel = (labelNodes, valueNodes) => (\n    <>\n      {optionIconRenderer?.(option, false)}\n      <span className=\"PreactCombobox-optionLabelFlex\">\n        <span>{labelNodes}</span>\n        {isLabelSameAsValue || !showValue ? null : (\n          <span className=\"PreactCombobox-optionValue\" aria-hidden=\"true\">\n            ({valueNodes})\n          </span>\n        )}\n      </span>\n    </>\n  );\n\n  const { label, value, matched, matchSlices } = option;\n  let labelElement;\n  if (matched === \"label\" || (matched === \"value\" && value === label)) {\n    const labelNodes = matchSlicesToNodes(matchSlices, label);\n    labelElement = getLabel(labelNodes, [value]);\n  } else if (matched === \"value\") {\n    const valueNodes = matchSlicesToNodes(matchSlices, value);\n    labelElement = getLabel([label], valueNodes);\n  } else {\n    // if matched === \"none\"\n    labelElement = getLabel([label], [value]);\n  }\n\n  return (\n    <>\n      <span\n        className={`PreactCombobox-optionCheckbox ${\n          isSelected ? \"PreactCombobox-optionCheckbox--selected\" : \"\"\n        }`}\n      >\n        {isSelected && tickIcon}\n      </span>\n      {labelElement}\n      {isInvalid && warningIcon}\n    </>\n  );\n}\n\n/** @type {NonNullable<PreactComboboxProps['optionIconRenderer']>} */\nfunction defaultOptionIconRenderer(option) {\n  return option.icon ? (\n    <span className=\"PreactCombobox-optionIcon\" aria-hidden=\"true\" role=\"img\">\n      {option.icon}\n    </span>\n  ) : null;\n}\n\n/** @type {string[]} */\nconst defaultArrayValue = [];\n\n/**\n * Creates a human-readable announcement of selected items\n * @param {string[]} selectedValues - Array of selected values\n * @param {\"added\"|\"removed\"|null|undefined} diff - Lookup object containing option labels\n * @param {string} language - Language code\n * @param {Record<string, Option>} optionsLookup - Lookup object containing option labels\n * @param {Translations} translations - Translations object\n * @returns {string} - Human-readable announcement of selections\n */\nfunction formatSelectionAnnouncement(selectedValues, diff, optionsLookup, language, translations) {\n  if (!selectedValues || selectedValues.length === 0) {\n    return translations.noOptionsSelected;\n  }\n\n  const labels = selectedValues.map((value) => optionsLookup[value]?.label || value);\n\n  const prefix = diff\n    ? diff === \"added\"\n      ? translations.selectionAdded\n      : translations.selectionRemoved\n    : translations.selectionsCurrent;\n\n  if (selectedValues.length <= 3) {\n    return `${prefix} ${new Intl.ListFormat(language, { style: \"long\", type: \"conjunction\" }).format(labels)}`;\n  }\n\n  const firstThree = labels.slice(0, 3);\n  const remaining = selectedValues.length - 3;\n  const moreText =\n    remaining === 1\n      ? translations.selectionsMore.replace(\"{count}\", remaining.toString())\n      : translations.selectionsMorePlural.replace(\"{count}\", remaining.toString());\n\n  return `${prefix} ${firstThree.join(\", \")} ${moreText}`;\n}\n\n/**\n * PreactCombobox component\n * @param {PreactComboboxProps} props - Component props\n */\nconst PreactCombobox = ({\n  id: idProp,\n  multiple = true,\n  allowedOptions,\n  allowFreeText = false,\n  onChange,\n  value = multiple ? defaultArrayValue : \"\",\n  language = \"en\",\n  placeholder = \"\",\n  disabled,\n  required,\n  name,\n  portal = document.body,\n  className = \"\",\n  rootElementProps,\n  inputProps: { tooltipContent = null, ...inputProps } = {},\n  formSubmitCompatible = false,\n  isServer = isServerDefault,\n  selectElementProps,\n  showValue = true,\n  showClearButton = true,\n  optionRenderer = defaultOptionRenderer,\n  optionIconRenderer = defaultOptionIconRenderer,\n  warningIcon = defaultWarningIcon,\n  tickIcon = defaultTickIcon,\n  chevronIcon = defaultChevronIcon,\n  loadingRenderer = defaultLoadingRenderer,\n  theme = \"system\",\n  tray = \"auto\",\n  trayBreakpoint = \"768px\",\n  trayLabel: trayLabelProp,\n  translations = defaultEnglishTranslations,\n  // private option for now\n  maxNumberOfPresentedOptions = 100,\n}) => {\n  // Merge default translations with provided translations\n  const mergedTranslations = useDeepMemo(\n    translations === defaultEnglishTranslations\n      ? translations\n      : { ...defaultEnglishTranslations, ...translations },\n  );\n  const values = multiple ? /** @type {string[]} */ (value) : null;\n  const singleSelectValue = multiple ? null : /** @type {string} */ (value);\n\n  /** @type {string[]} */\n  let tempArrayValue;\n  if (Array.isArray(value)) {\n    tempArrayValue = /** @type {string[]} */ (value);\n  } else {\n    tempArrayValue = value ? [/** @type {string} */ (value)] : [];\n  }\n  const arrayValues = useDeepMemo(tempArrayValue);\n  const arrayValuesLookup = useMemo(() => new Set(arrayValues), [arrayValues]);\n  const allowedOptionsAsKey = useDeepMemo(\n    typeof allowedOptions === \"function\" ? null : allowedOptions,\n  );\n\n  const autoId = useId();\n  const id = idProp || autoId;\n  const [inputValue, setInputValue] = useState(\"\");\n  const [getIsDropdownOpen, setIsDropdownOpen, hasDropdownOpenChanged] = useLive(false);\n  const cachedOptions = useRef(/** @type {{ [value: string]: Option }} */ ({}));\n  const [filteredOptions, setFilteredOptions] = useState(/** @type {OptionMatch[]} */ ([]));\n  const [isLoading, setIsLoading] = useState(false);\n  const [getIsFocused, setIsFocused] = useLive(false);\n  // For screen reader announcement\n  const [lastSelectionAnnouncement, setLastSelectionAnnouncement] = useState(\"\");\n  // For loading status announcements\n  const [loadingAnnouncement, setLoadingAnnouncement] = useState(\"\");\n  // NOTE: Using ref for performance. Setting few attributes by re-rendering a large list is too expensive.\n  const activeDescendant = useRef(\"\");\n  const [warningIconHovered, setWarningIconHovered] = useState(false);\n  const inputRef = useRef(/** @type {HTMLInputElement | null} */ (null));\n  const blurTimeoutRef = useRef(/** @type {number | undefined} */ (undefined));\n  const rootElementRef = useRef(/** @type {HTMLDivElement | null} */ (null));\n  const dropdownPopperRef = useRef(/** @type {HTMLUListElement | null} */ (null));\n  const dropdownClosedExplicitlyRef = useRef(false);\n  const warningIconRef = useRef(null);\n  const tooltipPopperRef = useRef(null);\n  const undoStack = useRef(/** @type {string[][]} */ ([]));\n  const redoStack = useRef(/** @type {string[][]} */ ([]));\n  const [getTrayLabel, setTrayLabel] = useLive(trayLabelProp);\n\n  // Tray-related state\n  const [getIsTrayOpen, setIsTrayOpen, hasTrayOpenChanged] = useLive(false);\n  const [trayInputValue, setTrayInputValue] = useState(\"\");\n  const trayInputRef = useRef(/** @type {HTMLInputElement | null} */ (null));\n  const trayModalRef = useRef(/** @type {HTMLDivElement | null} */ (null));\n  const trayClosedExplicitlyRef = useRef(false);\n  const [isMobileScreen, setIsMobileScreen] = useState(false);\n  const originalOverflowRef = useRef(\"\");\n  const [virtualKeyboardHeight, setVirtualKeyboardHeight] = useState(0);\n\n  // Media query detection for auto tray mode\n  useEffect(() => {\n    if (tray === \"auto\") {\n      const mediaQuery = window.matchMedia(`(max-width: ${trayBreakpoint})`);\n      setIsMobileScreen(mediaQuery.matches);\n      const handleChange = (/** @type {MediaQueryListEvent} */ e) => setIsMobileScreen(e.matches);\n      mediaQuery.addEventListener(\"change\", handleChange);\n      return () => mediaQuery.removeEventListener(\"change\", handleChange);\n    }\n  }, [tray, trayBreakpoint]);\n\n  // Determine if tray should be used\n  const shouldUseTray = tray === true || (tray === \"auto\" && isMobileScreen);\n\n  // Use appropriate input value based on mode\n  const activeInputValue = getIsTrayOpen() ? trayInputValue : inputValue;\n  const inputTrimmed = activeInputValue.trim();\n\n  /**\n   * Get the effective tray label\n   * If needed, automatically detect the label associated with the input field\n   * Following W3C accessible name computation priority order:\n   * 1. aria-labelledby (highest priority)\n   * 2. aria-label\n   * 3. Native HTML label element (label with 'for' attribute or wrapping label)\n   * 4. title attribute (fallback)\n   * @returns {string} The final computed tray label\n   */\n  const computeEffectiveTrayLabel = useCallback(() => {\n    if (trayLabelProp) return trayLabelProp;\n    if (typeof self === \"undefined\" || isServer || !inputRef.current) return \"\";\n\n    const inputElement = inputRef.current;\n    const inputId = inputElement.id;\n\n    // Priority 1: aria-labelledby (highest priority)\n    const ariaLabelledBy = inputElement.getAttribute(\"aria-labelledby\");\n    if (ariaLabelledBy) {\n      const labelElement = document.getElementById(ariaLabelledBy);\n      if (labelElement) {\n        return labelElement.textContent?.trim() || \"\";\n      }\n    }\n\n    // Priority 2: aria-label\n    const ariaLabel = inputElement.getAttribute(\"aria-label\");\n    if (ariaLabel) {\n      return ariaLabel.trim();\n    }\n\n    // Priority 3: Native HTML label element\n    // Method 3a: Look for label with 'for' attribute matching the input id\n    if (inputId) {\n      const labelElement = document.querySelector(`label[for=\"${inputId}\"]`);\n      if (labelElement) {\n        return labelElement.textContent?.trim() || \"\";\n      }\n    }\n\n    // Method 3b: Look for label that wraps the input element (using closest for efficiency)\n    const wrappingLabel = inputElement.closest(\"label\");\n    if (wrappingLabel) {\n      return wrappingLabel.textContent?.trim() || \"\";\n    }\n\n    // Priority 4: title attribute (fallback - lowest priority)\n    const title = inputElement.getAttribute(\"title\");\n    if (title) {\n      return title.trim();\n    }\n\n    return \"\";\n  }, [trayLabelProp, isServer]);\n  useLayoutEffect(() => {\n    setTrayLabel(computeEffectiveTrayLabel());\n  }, [setTrayLabel, computeEffectiveTrayLabel]);\n\n  const updateCachedOptions = useCallback(\n    /** @param {Option[]} update */\n    (update) => {\n      for (const item of update) {\n        cachedOptions.current[item.value] = item;\n      }\n    },\n    [],\n  );\n\n  const allOptions = useDeepMemo(\n    Array.isArray(allowedOptions) ? allowedOptions : Object.values(cachedOptions.current),\n  );\n  const allOptionsLookup = useMemo(\n    () =>\n      allOptions.reduce(\n        (acc, o) => {\n          acc[o.value] = o;\n          return acc;\n        },\n        /** @type {{ [value: string]: Option }} */ ({}),\n      ),\n    [allOptions],\n  );\n  const invalidValues = useMemo(() => {\n    if (allowFreeText) return [];\n    return arrayValues?.filter((v) => !allOptionsLookup[v]) || [];\n  }, [allowFreeText, arrayValues, allOptionsLookup]);\n\n  const updateSelectionAnnouncement = useCallback(\n    /**\n     * @param {string[]} selectedValues\n     * @param {\"added\"|\"removed\"|null} [diff]\n     */\n    (selectedValues, diff) => {\n      const announcement = formatSelectionAnnouncement(\n        selectedValues,\n        diff,\n        allOptionsLookup,\n        language,\n        mergedTranslations,\n      );\n      setLastSelectionAnnouncement(announcement);\n    },\n    [allOptionsLookup, mergedTranslations, language],\n  );\n\n  /**\n   * Note that aria-activedescendant only works with HTML id attributes.\n   * @param {string} optionValue - The value of the option to activate\n   * @param {boolean} [scroll=true] Scroll to the option if it's not already in view\n   */\n  const activateDescendant = useCallback(\n    /**\n     * @param {string} optionValue\n     * @param {boolean} [scroll=true]\n     */\n    (optionValue, scroll = true) => {\n      // NOTE: Using direct DOM API for performance\n      // Remove current active element CSS\n      if (activeDescendant.current && dropdownPopperRef.current) {\n        const el = dropdownPopperRef.current.querySelector(\".PreactCombobox-option--active\");\n        el?.classList.remove(\"PreactCombobox-option--active\");\n        // Remove non-active options from screen reader announcement\n        el?.querySelector('span[data-reader=\"selected\"]')?.setAttribute(\"aria-hidden\", \"true\");\n        el?.querySelector('span[data-reader=\"invalid\"]')?.setAttribute(\"aria-hidden\", \"true\");\n      }\n\n      activeDescendant.current = optionValue;\n\n      // Set the places in DOM where aria-activedescendant and aria-selected are set\n      const elementId = optionValue ? `${id}-option-${toHTMLId(optionValue)}` : \"\";\n      inputRef.current?.setAttribute(\"aria-activedescendant\", elementId);\n      if (elementId && dropdownPopperRef.current) {\n        const activeDescendantElement = dropdownPopperRef.current.querySelector(`#${elementId}`);\n        if (activeDescendantElement) {\n          activeDescendantElement.classList.add(\"PreactCombobox-option--active\");\n          activeDescendantElement\n            .querySelector('span[data-reader=\"selected\"]')\n            ?.setAttribute(\"aria-hidden\", \"false\");\n          activeDescendantElement\n            .querySelector('span[data-reader=\"invalid\"]')\n            ?.setAttribute(\"aria-hidden\", \"false\");\n          if (scroll) {\n            const dropdownRect = dropdownPopperRef.current.getBoundingClientRect();\n            const itemRect = activeDescendantElement.getBoundingClientRect();\n\n            if (itemRect.top < dropdownRect.top) {\n              dropdownPopperRef.current.scrollTop += itemRect.top - dropdownRect.top;\n            } else if (itemRect.bottom > dropdownRect.bottom) {\n              dropdownPopperRef.current.scrollTop += itemRect.bottom - dropdownRect.bottom;\n            }\n          }\n        }\n      }\n    },\n    [id],\n  );\n\n  const closeDropdown = useCallback(\n    (closedExplicitly = false) => {\n      setIsDropdownOpen(false);\n      // Don't wait till next render cycle (which destroys the popper) to hide the popper\n      if (dropdownPopperRef.current) {\n        // @ts-ignore\n        dropdownPopperRef.current.style.display = \"none\";\n      }\n      if (closedExplicitly) {\n        dropdownClosedExplicitlyRef.current = true;\n      }\n\n      // Announce current selections when dropdown is closed\n      updateSelectionAnnouncement(arrayValues);\n\n      activateDescendant(\"\");\n    },\n    [setIsDropdownOpen, activateDescendant, updateSelectionAnnouncement, arrayValues],\n  );\n\n  // Setup popper when dropdown is opened\n  useEffect(() => {\n    if (\n      getIsDropdownOpen() &&\n      !shouldUseTray &&\n      rootElementRef.current &&\n      dropdownPopperRef.current\n    ) {\n      // Get computed direction to handle RTL layout\n      const computedDir = window.getComputedStyle(rootElementRef.current).direction;\n      const placement = computedDir === \"rtl\" ? \"bottom-end\" : \"bottom-start\";\n\n      const popperInstance = createPopper(rootElementRef.current, dropdownPopperRef.current, {\n        placement: placement,\n        // @ts-ignore\n        modifiers: dropdownPopperModifiers,\n      });\n      dropdownPopperRef.current.style.display = \"block\";\n      // Clean up function\n      return () => {\n        popperInstance.destroy();\n      };\n    }\n    if (shouldUseTray && dropdownPopperRef.current) {\n      dropdownPopperRef.current.style.display = \"none\";\n    }\n  }, [getIsDropdownOpen, shouldUseTray]);\n\n  const abortControllerRef = useRef(/** @type {AbortController | null} */ (null));\n  const inputTypingDebounceTimer = useRef(/** @type {any} */ (null));\n  const newUnknownValues = arrayValues.filter((v) => !allOptionsLookup[v]);\n  const newUnknownValuesAsKey = useDeepMemo(newUnknownValues);\n  // Fill the dropdown with options on open and also on input change\n  // Not on useEffect deps:\n  // arrayValues doesn't need to be a dependency except on an unexpected selection change from parent\n  // because options info don't change on arrayValues change rather only the toggle state of the rendered\n  // option changes.\n  // biome-ignore lint/correctness/useExhaustiveDependencies: see above comment\n  useEffect(() => {\n    const isOpen = shouldUseTray ? getIsTrayOpen() : getIsDropdownOpen();\n    const shouldFetchOptions = isOpen || typeof allowedOptions === \"function\";\n    if (!shouldFetchOptions) return;\n\n    const abortController = typeof allowedOptions === \"function\" ? new AbortController() : null;\n    abortControllerRef.current?.abort();\n    abortControllerRef.current = abortController;\n\n    let debounceTime = 0; // for local data\n    if (\n      typeof allowedOptions === \"function\" &&\n      !(\n        // don't debounce for initial render (when we have to resolve the labels for selected values).\n        // don't debounce for first time the dropdown is opened as well.\n        (\n          newUnknownValues.length > 0 ||\n          (isOpen && shouldUseTray ? hasTrayOpenChanged : hasDropdownOpenChanged)\n        )\n      ) &&\n      // Hack: We avoid debouncing to speed up playwright tests\n      !isPlaywright\n    ) {\n      // a typical user types 4 characters per second, so 250ms is a good debounce time\n      debounceTime = 250;\n    }\n    clearTimeout(inputTypingDebounceTimer.current);\n\n    const callback = async () => {\n      if (typeof allowedOptions === \"function\") {\n        // @ts-ignore\n        const signal = /** @type {AbortSignal} */ (abortController.signal);\n        const [searchResults, selectedResults] = await Promise.all([\n          isOpen\n            ? allowedOptions(inputTrimmed, maxNumberOfPresentedOptions, arrayValues, signal)\n            : /** @type {Option[]} */ ([]),\n          // We need to fetch unknown options's labels regardless of whether the dropdown\n          // is open or not, because we want to show it in the placeholder.\n          newUnknownValues.length > 0\n            ? allowedOptions(newUnknownValues, newUnknownValues.length, arrayValues, signal)\n            : null,\n        ]).catch((error) => {\n          if (signal.aborted) {\n            return [null, null];\n          }\n          setIsLoading(false);\n          throw error;\n        });\n\n        setIsLoading(false);\n        if (searchResults?.length) {\n          updateCachedOptions(searchResults);\n        }\n        if (selectedResults?.length) {\n          updateCachedOptions(selectedResults);\n        }\n        let updatedOptions = searchResults || [];\n        // Handle case where backend doesn't return labels for all the sent selections\n        if (!inputTrimmed) {\n          const unreturnedValues = newUnknownValues\n            .filter((v) => !cachedOptions.current[v])\n            .map((v) => ({ label: v, value: v }));\n          if (unreturnedValues.length > 0) {\n            updateCachedOptions(unreturnedValues);\n            updatedOptions = unreturnedValues.concat(searchResults || []);\n          }\n        }\n        // when search is applied don't sort the selected values to the top\n        const options = inputTrimmed\n          ? updatedOptions\n          : sortValuesToTop(updatedOptions, arrayValues);\n        // we don't need to re-sort what the backend returns, so pass filterAndSort=false to getMatchScore()\n        setFilteredOptions(getMatchScore(inputTrimmed, options, language, false));\n      } else {\n        const mergedOptions = arrayValues\n          .filter((v) => !allOptionsLookup[v])\n          .map((v) => ({ label: v, value: v }))\n          .concat(allowedOptions);\n        // when search is applied don't sort the selected values to the top\n        const options = activeInputValue\n          ? mergedOptions\n          : sortValuesToTop(mergedOptions, arrayValues);\n        setFilteredOptions(getMatchScore(activeInputValue, options, language, true));\n      }\n    };\n\n    // We need to set isLoading immediately to show \"loading\" state without waiting\n    // for the debounce to complete so that playwright tests don't need an arbitrary\n    // wait delay for the options to load.\n    if (typeof allowedOptions === \"function\") {\n      setIsLoading(true);\n    }\n\n    let timer = null;\n    if (debounceTime > 0) {\n      timer = setTimeout(callback, debounceTime);\n    } else {\n      callback();\n    }\n    inputTypingDebounceTimer.current = timer;\n\n    // Clean up function\n    return () => {\n      abortController?.abort();\n      if (timer) clearTimeout(timer);\n    };\n  }, [\n    getIsDropdownOpen,\n    getIsTrayOpen,\n    shouldUseTray,\n    inputTrimmed,\n    language,\n    newUnknownValuesAsKey,\n    allowedOptionsAsKey,\n  ]);\n\n  const addNewOptionVisible =\n    !isLoading &&\n    allowFreeText &&\n    inputTrimmed &&\n    !arrayValues.includes(inputTrimmed) &&\n    !filteredOptions.find((o) => o.value === inputTrimmed);\n\n  // Detect changes to filtered options and re-activate or deactivate the active descendant\n  useEffect(() => {\n    const isOpen = shouldUseTray ? getIsTrayOpen() : getIsDropdownOpen();\n    if (!isOpen) return;\n    if (\n      activeDescendant.current &&\n      filteredOptions.find((o) => o.value === activeDescendant.current)\n    ) {\n      activateDescendant(activeDescendant.current);\n    } else if (addNewOptionVisible && activeDescendant.current === inputTrimmed) {\n      activateDescendant(inputTrimmed);\n    } else {\n      activateDescendant(\"\");\n    }\n  }, [\n    shouldUseTray,\n    getIsDropdownOpen,\n    getIsTrayOpen,\n    filteredOptions,\n    activateDescendant,\n    addNewOptionVisible,\n    inputTrimmed,\n  ]);\n\n  // Setup warning tooltip popper when hovering over warning icon\n  useEffect(() => {\n    if (\n      invalidValues.length > 0 &&\n      warningIconHovered &&\n      warningIconRef.current &&\n      tooltipPopperRef.current &&\n      rootElementRef.current\n    ) {\n      // Get computed direction to handle RTL layout\n      const computedDir = window.getComputedStyle(rootElementRef.current).direction;\n      const placement = computedDir === \"rtl\" ? \"bottom-end\" : \"bottom-start\";\n\n      const popperInstance = createPopper(warningIconRef.current, tooltipPopperRef.current, {\n        placement: placement,\n        // @ts-ignore\n        modifiers: tooltipPopperModifiers,\n      });\n      // @ts-ignore\n      tooltipPopperRef.current.style.display = \"block\";\n\n      // Clean up function\n      return () => {\n        popperInstance.destroy();\n      };\n    }\n  }, [warningIconHovered, invalidValues.length]);\n\n  /**\n   * Handle option selection\n   * @param {string} selectedValue The selected option value\n   */\n  const handleOptionSelect = useCallback(\n    /**\n     * @param {string} selectedValue\n     * @param {{ toggleSelected?: boolean }} [options]\n     */\n    (selectedValue, { toggleSelected = false } = {}) => {\n      // Check if the option is disabled\n      const option = allOptionsLookup[selectedValue];\n      if (option?.disabled) {\n        return;\n      }\n      if (values) {\n        const isExistingOption = values.includes(selectedValue);\n        let newValues;\n        if (!isExistingOption || (toggleSelected && isExistingOption)) {\n          if (toggleSelected && isExistingOption) {\n            newValues = values.filter((v) => v !== selectedValue);\n          } else {\n            newValues = [...values, selectedValue];\n          }\n          onChange(newValues);\n          updateSelectionAnnouncement(\n            [selectedValue],\n            newValues.length < values.length ? \"removed\" : \"added\",\n          );\n          undoStack.current.push(values);\n          redoStack.current = [];\n        }\n      } else {\n        if (\n          singleSelectValue !== selectedValue ||\n          (toggleSelected && singleSelectValue === selectedValue)\n        ) {\n          let newValue;\n          if (toggleSelected && singleSelectValue === selectedValue) {\n            newValue = \"\";\n          } else {\n            newValue = selectedValue;\n          }\n          onChange(newValue);\n          updateSelectionAnnouncement([selectedValue], newValue ? \"removed\" : \"added\");\n          undoStack.current.push([newValue]);\n          redoStack.current = [];\n          closeDropdown();\n        }\n        setInputValue(\"\");\n      }\n    },\n    [\n      onChange,\n      singleSelectValue,\n      values,\n      updateSelectionAnnouncement,\n      closeDropdown,\n      allOptionsLookup,\n    ],\n  );\n\n  const focusInputWithVirtualKeyboardGuard = useCallback(\n    /**\n     * @param {Object} params\n     * @param {HTMLInputElement | null} params.input\n     * @param {boolean} [params.shouldPreventKeyboardReopen]\n     * @param {boolean} [params.forceOpenKeyboard]\n     * @param {{ current: ReturnType<typeof setTimeout> | null } | null} [params.readonlyResetTimeoutRef]\n     */\n    (params) => {\n      const {\n        input,\n        shouldPreventKeyboardReopen = false,\n        forceOpenKeyboard = false,\n        readonlyResetTimeoutRef = null,\n      } = params;\n      if (!input) return;\n      // If user explicitly closed the keyboard, we need to temporarily disable the input\n      // to prevent the keyboard from being reopened.\n      const shouldTemporarilyDisableInput = shouldPreventKeyboardReopen && !forceOpenKeyboard;\n      if (shouldTemporarilyDisableInput) {\n        input.setAttribute(\"readonly\", \"readonly\");\n      }\n      // Does it make sense to focus the input if it's already focused?\n      // Yes, because it's possible that the next event in the event loop\n      // is the one that will trigger the a 'blur' event. To cancel the blur,\n      // we need to focus the input again.\n      input.focus();\n      if (shouldTemporarilyDisableInput) {\n        if (readonlyResetTimeoutRef?.current) {\n          clearTimeout(readonlyResetTimeoutRef.current);\n        }\n        const removeReadonly = () => {\n          input.removeAttribute(\"readonly\");\n          if (readonlyResetTimeoutRef) {\n            readonlyResetTimeoutRef.current = null;\n          }\n        };\n        if (readonlyResetTimeoutRef) {\n          readonlyResetTimeoutRef.current = setTimeout(removeReadonly, 10);\n        } else {\n          setTimeout(removeReadonly, 10);\n        }\n      }\n    },\n    [],\n  );\n\n  const focusInput = useCallback(\n    (forceOpenKeyboard = false) => {\n      focusInputWithVirtualKeyboardGuard({\n        input: inputRef.current,\n        shouldPreventKeyboardReopen:\n          getIsFocused() && virtualKeyboardExplicitlyClosedRef.current === true,\n        forceOpenKeyboard,\n      });\n    },\n    [getIsFocused, focusInputWithVirtualKeyboardGuard],\n  );\n\n  const focusTrayInput = useCallback(\n    (forceOpenKeyboard = false) => {\n      const input = trayInputRef.current;\n      focusInputWithVirtualKeyboardGuard({\n        input,\n        shouldPreventKeyboardReopen:\n          document.activeElement === input && virtualKeyboardExplicitlyClosedRef.current === true,\n        forceOpenKeyboard,\n        readonlyResetTimeoutRef: trayReadonlyResetTimeoutRef,\n      });\n    },\n    [focusInputWithVirtualKeyboardGuard],\n  );\n\n  const openTray = useCallback(() => {\n    if (!shouldUseTray) return;\n    // Get the scrolling element (body or html)\n    const scrollingElement = /** @type {HTMLElement} */ (\n      document.scrollingElement || document.documentElement\n    );\n\n    // Save original overflow and apply hidden\n    originalOverflowRef.current = scrollingElement.style.overflow;\n    scrollingElement.style.overflow = \"hidden\";\n\n    setIsTrayOpen(true);\n    setIsDropdownOpen(false);\n    trayClosedExplicitlyRef.current = false;\n\n    // Subscribe to virtual keyboard for tray\n    if (!virtualKeyboardHeightAdjustSubscription.current) {\n      if (wasVisualViewportInitialHeightAnApproximate && trayModalRef.current) {\n        trayModalRef.current.style.removeProperty(\"display\");\n        const height = trayModalRef.current.offsetHeight;\n        if (height > 0) {\n          visualViewportInitialHeight = height;\n          wasVisualViewportInitialHeightAnApproximate = false;\n        }\n      }\n      virtualKeyboardHeightAdjustSubscription.current = subscribeToVirtualKeyboard({\n        heightCallback(keyboardHeight, isVisible) {\n          setVirtualKeyboardHeight(isVisible ? keyboardHeight : 0);\n          virtualKeyboardExplicitlyClosedRef.current = !isVisible;\n        },\n      });\n    }\n  }, [shouldUseTray, setIsDropdownOpen, setIsTrayOpen]);\n\n  // focus the input when the tray is opened first time\n  useEffect(() => {\n    if (shouldUseTray && getIsTrayOpen()) {\n      focusTrayInput(true);\n    }\n  }, [shouldUseTray, getIsTrayOpen, focusTrayInput]);\n\n  const closeTray = useCallback(() => {\n    setIsTrayOpen(false);\n    setTrayInputValue(\"\");\n    setVirtualKeyboardHeight(0);\n    virtualKeyboardExplicitlyClosedRef.current = null;\n    virtualKeyboardHeightAdjustSubscription.current?.();\n    virtualKeyboardHeightAdjustSubscription.current = null;\n    if (trayReadonlyResetTimeoutRef.current) {\n      clearTimeout(trayReadonlyResetTimeoutRef.current);\n      trayReadonlyResetTimeoutRef.current = null;\n    }\n    trayInputRef.current?.removeAttribute(\"readonly\");\n\n    // Restore original overflow\n    const scrollingElement = /** @type {HTMLElement} */ (\n      document.scrollingElement || document.documentElement\n    );\n    scrollingElement.style.overflow = originalOverflowRef.current;\n\n    trayClosedExplicitlyRef.current = true;\n    focusInput(true);\n  }, [setIsTrayOpen, focusInput]);\n\n  const handleInputChange = useCallback(\n    /**\n     * Handle input change\n     * @param {import('preact/compat').ChangeEvent<HTMLInputElement>} e - Input change event\n     */\n    (e) => {\n      if (shouldUseTray) {\n        e.preventDefault();\n        openTray();\n        return;\n      }\n      setInputValue(e.currentTarget.value);\n      if (!dropdownClosedExplicitlyRef.current) {\n        setIsDropdownOpen(true);\n      }\n    },\n    [setIsDropdownOpen, shouldUseTray, openTray],\n  );\n\n  const handleTrayInputChange = useCallback(\n    /**\n     * Handle tray input change\n     * @param {import('preact/compat').ChangeEvent<HTMLInputElement>} e - Input change event\n     */\n    (e) => {\n      setTrayInputValue(e.currentTarget.value);\n    },\n    [],\n  );\n\n  /**\n   * Tristate - null means virtual keyboard is not actively being detected.\n   * True means virtual keyboard was explicitly closed.\n   * False means virtual keyboard was not explicitly closed.\n   * @type {import('preact').RefObject<boolean|null>}\n   */\n  const virtualKeyboardExplicitlyClosedRef = useRef(null);\n  const virtualKeyboardDismissSubscription = useRef(/** @type {function | null} */ (null));\n  const virtualKeyboardHeightAdjustSubscription = useRef(/** @type {function | null} */ (null));\n  const trayReadonlyResetTimeoutRef = useRef(\n    /** @type {ReturnType<typeof setTimeout> | null} */ (null),\n  );\n\n  const handleInputFocus = useCallback(() => {\n    setIsFocused(true);\n    clearTimeout(blurTimeoutRef.current);\n    blurTimeoutRef.current = undefined;\n    if (shouldUseTray) {\n      if (!trayClosedExplicitlyRef.current) {\n        openTray();\n      }\n      trayClosedExplicitlyRef.current = false;\n    } else {\n      setIsDropdownOpen(true);\n      dropdownClosedExplicitlyRef.current = false;\n      if (!virtualKeyboardDismissSubscription.current) {\n        virtualKeyboardDismissSubscription.current = subscribeToVirtualKeyboard({\n          visibleCallback(isVisible) {\n            virtualKeyboardExplicitlyClosedRef.current = !isVisible;\n          },\n        });\n      }\n    }\n    updateSelectionAnnouncement(arrayValues);\n  }, [\n    setIsFocused,\n    setIsDropdownOpen,\n    openTray,\n    arrayValues,\n    updateSelectionAnnouncement,\n    shouldUseTray,\n  ]);\n\n  // Delay blur to allow option selection\n  const handleInputBlur = useCallback(() => {\n    setIsFocused(false);\n    clearTimeout(blurTimeoutRef.current);\n    blurTimeoutRef.current = undefined;\n    closeDropdown();\n    dropdownClosedExplicitlyRef.current = false;\n    // Auto-select matching option if single-select\n    if (!multiple) {\n      if (inputTrimmed && (allowFreeText || allOptionsLookup[inputTrimmed])) {\n        handleOptionSelect(inputTrimmed);\n      }\n    }\n    setInputValue(\"\");\n    setLastSelectionAnnouncement(\"\");\n    if (!shouldUseTray) {\n      virtualKeyboardDismissSubscription.current?.();\n      virtualKeyboardDismissSubscription.current = null;\n      virtualKeyboardExplicitlyClosedRef.current = null;\n    }\n  }, [\n    setIsFocused,\n    allOptionsLookup,\n    allowFreeText,\n    handleOptionSelect,\n    multiple,\n    inputTrimmed,\n    closeDropdown,\n    shouldUseTray,\n  ]);\n\n  const handleAddNewOption = useCallback(\n    /**\n     * @param {string} newValue\n     */\n    (newValue) => {\n      handleOptionSelect(newValue);\n      if (!filteredOptions.find((o) => o.value === newValue)) {\n        setFilteredOptions((options) => {\n          // biome-ignore lint/style/noParameterAssign:\n          options = [\n            /** @type {OptionMatch} */ ({\n              label: newValue,\n              value: newValue,\n            }),\n          ].concat(options);\n          const isRemoteSearch = typeof allowedOptions === \"function\";\n          return getMatchScore(inputTrimmed, options, language, !isRemoteSearch);\n        });\n      }\n      activateDescendant(newValue);\n    },\n    [\n      allowedOptions,\n      language,\n      handleOptionSelect,\n      activateDescendant,\n      inputTrimmed,\n      filteredOptions,\n    ],\n  );\n\n  /**\n   * Handle keydown events on the input\n   */\n  const handleKeyDown = useCallback(\n    /**\n     * @param {import('preact/compat').KeyboardEvent<HTMLInputElement>} e - Keyboard event\n     */\n    (e) => {\n      const currentActiveDescendant = activeDescendant.current;\n      if (e.key === \"Enter\") {\n        e.preventDefault();\n        const currentIndex = currentActiveDescendant\n          ? filteredOptions.findIndex((o) => o.value === currentActiveDescendant)\n          : -1;\n        if (currentIndex > -1) {\n          const option = /** @type {OptionMatch} */ (filteredOptions[currentIndex]);\n          handleOptionSelect(option.value, {\n            toggleSelected: true,\n          });\n        } else if (allowFreeText && inputTrimmed !== \"\") {\n          handleAddNewOption(inputTrimmed);\n        }\n        // ArrowDown highlights next option\n      } else if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n        if (!filteredOptions.length && !addNewOptionVisible) return;\n        const currentIndex = currentActiveDescendant\n          ? filteredOptions.findIndex((o) => o.value === currentActiveDescendant)\n          : -1;\n        if (\n          addNewOptionVisible &&\n          currentActiveDescendant !== inputTrimmed &&\n          (currentIndex < 0 || currentIndex === filteredOptions.length - 1)\n        ) {\n          activateDescendant(inputTrimmed);\n        } else if (filteredOptions.length) {\n          // Find next non-disabled option\n          let nextIndex = currentIndex === filteredOptions.length - 1 ? 0 : currentIndex + 1;\n          let attempts = 0;\n          while (attempts < filteredOptions.length) {\n            const option = /** @type {OptionMatch} */ (filteredOptions[nextIndex]);\n            if (!option.disabled) {\n              activateDescendant(option.value);\n              break;\n            }\n            nextIndex = nextIndex === filteredOptions.length - 1 ? 0 : nextIndex + 1;\n            attempts++;\n          }\n        }\n        // ArrowUp highlights previous option\n      } else if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n        if (!filteredOptions.length && !addNewOptionVisible) return;\n        const currentIndex = currentActiveDescendant\n          ? filteredOptions.findIndex((o) => o.value === currentActiveDescendant)\n          : 0;\n        if (\n          addNewOptionVisible &&\n          currentActiveDescendant !== inputTrimmed &&\n          ((currentIndex === 0 && currentActiveDescendant) || !filteredOptions.length)\n        ) {\n          activateDescendant(inputTrimmed);\n        } else if (filteredOptions.length) {\n          // Find previous non-disabled option\n          let prevIndex = (currentIndex - 1 + filteredOptions.length) % filteredOptions.length;\n          let attempts = 0;\n          while (attempts < filteredOptions.length) {\n            const option = /** @type {OptionMatch} */ (filteredOptions[prevIndex]);\n            if (!option.disabled) {\n              activateDescendant(option.value);\n              break;\n            }\n            prevIndex = (prevIndex - 1 + filteredOptions.length) % filteredOptions.length;\n            attempts++;\n          }\n        }\n        // Escape blurs input\n      } else if (e.key === \"Escape\") {\n        closeDropdown(true);\n        // Home key navigates to first option\n      } else if (e.key === \"Home\" && e.ctrlKey && getIsDropdownOpen()) {\n        e.preventDefault();\n        if (filteredOptions.length > 0) {\n          // Find first non-disabled option\n          const firstNonDisabledOption = filteredOptions.find((option) => !option.disabled);\n          if (firstNonDisabledOption) {\n            activateDescendant(firstNonDisabledOption.value);\n          }\n        } else if (addNewOptionVisible) {\n          activateDescendant(inputTrimmed);\n        }\n        // End key navigates to last option\n      } else if (e.key === \"End\" && e.ctrlKey && getIsDropdownOpen()) {\n        e.preventDefault();\n        if (filteredOptions.length > 0) {\n          // Find last non-disabled option\n          const lastNonDisabledOption = filteredOptions.findLast((option) => !option.disabled);\n          if (lastNonDisabledOption) {\n            activateDescendant(lastNonDisabledOption.value);\n          }\n        } else if (addNewOptionVisible) {\n          activateDescendant(inputTrimmed);\n        }\n        // Undo action\n      } else if (inputValue === \"\" && (e.ctrlKey || e.metaKey) && e.key === \"z\") {\n        e.preventDefault();\n        const prevValues = undoStack.current.pop();\n        if (prevValues) {\n          onChange(prevValues);\n          updateSelectionAnnouncement(prevValues);\n          redoStack.current.push(Array.isArray(value) ? value : [value]);\n        }\n        // Redo action\n      } else if (inputValue === \"\" && (e.ctrlKey || e.metaKey) && e.key === \"y\") {\n        e.preventDefault();\n        const nextValues = redoStack.current.pop();\n        if (nextValues) {\n          onChange(nextValues);\n          updateSelectionAnnouncement(nextValues);\n          undoStack.current.push(Array.isArray(value) ? value : [value]);\n        }\n      }\n    },\n    [\n      activateDescendant,\n      allowFreeText,\n      filteredOptions,\n      addNewOptionVisible,\n      handleOptionSelect,\n      handleAddNewOption,\n      inputValue,\n      inputTrimmed,\n      onChange,\n      getIsDropdownOpen,\n      setIsDropdownOpen,\n      value,\n      closeDropdown,\n      updateSelectionAnnouncement,\n    ],\n  );\n  /**\n   * Handle paste event\n   */\n  const handlePaste = useCallback(\n    /**\n     * @param {import('preact/compat').ClipboardEvent<HTMLInputElement>} e - Clipboard event\n     */\n    (e) => {\n      // only handle paste in multi-select mode\n      if (!values) return;\n\n      // e.preventDefault();\n      // Case 1 : Exact matches\n      const valuesLookup = {\n        ...Object.fromEntries(values.map((v) => [v, v])),\n        ...Object.fromEntries(allOptions.map((o) => [o.value, o.value])),\n      };\n      // Case 2 : Case insensitive matches\n      const valuesLowerCaseLookup = {\n        ...Object.fromEntries(values.map((v) => [v.toLowerCase(), v])),\n        ...Object.fromEntries(allOptions.map((o) => [o.value.toLowerCase(), o.value])),\n      };\n      // Case 3 : Case insensitive matches against label\n      const optionsLabelLookup = Object.fromEntries(\n        allOptions.map((o) => [o.label.toLowerCase(), o.value]),\n      );\n      const pastedText = e.clipboardData?.getData(\"text\") || \"\";\n      if (!pastedText) return;\n      const pastedOptions = pastedText\n        .split(\",\")\n        .map((x) => x.trim())\n        .filter((x) => x !== \"\")\n        .map(\n          (x) =>\n            valuesLookup[x] ||\n            valuesLowerCaseLookup[x.toLowerCase()] ||\n            optionsLabelLookup[x.toLocaleLowerCase()] ||\n            x,\n        );\n\n      const newValues = unique([...values, ...pastedOptions]);\n      onChange(newValues);\n      updateSelectionAnnouncement(newValues, \"added\");\n      undoStack.current.push(values);\n      redoStack.current = [];\n      // force a re-render\n      setFilteredOptions((filteredOptions) => filteredOptions.slice());\n    },\n    [allOptions, onChange, values, updateSelectionAnnouncement],\n  );\n\n  const handleClearValue = useCallback(() => {\n    setInputValue(\"\");\n    onChange(multiple ? [] : \"\");\n    updateSelectionAnnouncement(arrayValues, \"removed\");\n    undoStack.current.push(arrayValues);\n    redoStack.current = [];\n    // If current input is focused, we need to prevent a blur event from being triggered\n    // by focusing the input again. Else don't focus the input.\n    if (getIsFocused()) {\n      focusInput();\n    }\n  }, [onChange, multiple, arrayValues, updateSelectionAnnouncement, getIsFocused, focusInput]);\n\n  const handleRootElementClick = useCallback(() => {\n    if (!disabled) {\n      if (shouldUseTray) {\n        openTray();\n      } else {\n        if (inputRef.current && document.activeElement !== inputRef.current) {\n          // We regard an explicit click on the root element as an attempt to open the keyboard.\n          focusInput(true);\n        }\n        // This set is not redundant as input may already be focused\n        // and handleInputFocus may not be called\n        setIsDropdownOpen(true);\n        dropdownClosedExplicitlyRef.current = false;\n      }\n    }\n  }, [disabled, shouldUseTray, openTray, focusInput, setIsDropdownOpen]);\n\n  // Memoize whatever JSX that can be memoized\n  const selectChildren = useMemo(\n    () =>\n      formSubmitCompatible\n        ? arrayValues\n            .map((val) => (\n              <option key={val} value={val} disabled={allOptionsLookup[val]?.disabled}>\n                {allOptionsLookup[val]?.label || val}\n              </option>\n            ))\n            .concat(\n              typeof allowedOptions !== \"function\"\n                ? allowedOptions\n                    .filter((o) => !arrayValuesLookup.has(o.value))\n                    .slice(0, maxNumberOfPresentedOptions - arrayValues.length)\n                    .map((o) => (\n                      <option key={o.value} value={o.value} disabled={o.disabled}>\n                        {o.label}\n                      </option>\n                    ))\n                : [],\n            )\n        : null,\n    [\n      arrayValues,\n      allOptionsLookup,\n      formSubmitCompatible,\n      allowedOptions,\n      arrayValuesLookup,\n      maxNumberOfPresentedOptions,\n    ],\n  );\n\n  // Update loading announcement when isLoading changes\n  useEffect(() => {\n    const isOpen = getIsDropdownOpen() || getIsTrayOpen();\n    // Only announce loading if the dropdown is open\n    if (isLoading && isOpen) {\n      setLoadingAnnouncement(mergedTranslations.loadingOptionsAnnouncement);\n    } else if (loadingAnnouncement && !isLoading && isOpen) {\n      // Only announce completion if we previously announced loading\n      // and the dropdown is still open\n      setLoadingAnnouncement(\n        filteredOptions.length\n          ? mergedTranslations.optionsLoadedAnnouncement\n          : mergedTranslations.noOptionsFoundAnnouncement,\n      );\n      // Clear the announcement after a delay\n      const timer = setTimeout(() => {\n        setLoadingAnnouncement(\"\");\n      }, 1000);\n      return () => clearTimeout(timer);\n    } else if (loadingAnnouncement && !isOpen) {\n      // Clear any loading announcements when dropdown closes\n      setLoadingAnnouncement(\"\");\n    }\n  }, [\n    isLoading,\n    loadingAnnouncement,\n    getIsDropdownOpen,\n    getIsTrayOpen,\n    filteredOptions.length,\n    mergedTranslations.loadingOptionsAnnouncement,\n    mergedTranslations.optionsLoadedAnnouncement,\n    mergedTranslations.noOptionsFoundAnnouncement,\n  ]);\n\n  // Determine if we should render interactive elements\n  const isServerSideForm = isServer && formSubmitCompatible;\n\n  let list = null;\n  if (!isServer) {\n    list = (\n      // biome-ignore lint/a11y/useFocusableInteractive: <explanation>\n      <ul\n        className={[\n          \"PreactCombobox-options\",\n          `PreactCombobox--${theme}`,\n          shouldUseTray ? \"PreactCombobox-options--tray\" : \"\",\n        ]\n          .filter(Boolean)\n          .join(\" \")}\n        // biome-ignore lint/a11y/useSemanticElements: it is correct by examples I've found for comboboxes\n        role=\"listbox\"\n        id={`${id}-options-listbox`}\n        aria-multiselectable={multiple ? \"true\" : undefined}\n        hidden={shouldUseTray ? !getIsTrayOpen() : !getIsDropdownOpen()}\n        ref={shouldUseTray ? null : dropdownPopperRef}\n      >\n        {isLoading ? (\n          <li className=\"PreactCombobox-option\" aria-disabled>\n            {loadingRenderer(mergedTranslations.loadingOptions)}\n          </li>\n        ) : (\n          <>\n            {addNewOptionVisible && (\n              <li\n                key={inputTrimmed}\n                id={`${id}-option-${toHTMLId(inputTrimmed)}`}\n                className=\"PreactCombobox-option\"\n                // biome-ignore lint/a11y/useSemanticElements: parent is <ul> so want to keep equivalent semantics\n                role=\"option\"\n                tabIndex={-1}\n                aria-selected={false}\n                onMouseEnter={() => activateDescendant(inputTrimmed, false)}\n                onMouseDown={(e) => {\n                  e.preventDefault();\n                  e.stopPropagation();\n                  handleAddNewOption(inputTrimmed);\n                  if (shouldUseTray) {\n                    if (!multiple) {\n                      closeTray();\n                    } else {\n                      focusTrayInput();\n                    }\n                  } else {\n                    if (!multiple) {\n                      closeDropdown();\n                    }\n                    focusInput();\n                  }\n                }}\n              >\n                {mergedTranslations.addOption.replace(\"{value}\", inputTrimmed)}\n              </li>\n            )}\n            {filteredOptions.map((option) => {\n              // \"Active\" means it's like a focus / hover. It doesn't mean the option was selected.\n              // aria-activedescendant is used to tell screen readers the active option.\n              const isActive = activeDescendant.current === option.value;\n              const isSelected = arrayValues.includes(option.value);\n              const isInvalid = invalidValues.includes(option.value);\n              const isDisabled = option.disabled;\n              const hasDivider = option.divider && !inputTrimmed; // Only show divider when search is empty\n              const optionClasses = [\n                \"PreactCombobox-option\",\n                isActive ? \"PreactCombobox-option--active\" : \"\",\n                isSelected ? \"PreactCombobox-option--selected\" : \"\",\n                isInvalid ? \"PreactCombobox-option--invalid\" : \"\",\n                isDisabled ? \"PreactCombobox-option--disabled\" : \"\",\n                hasDivider ? \"PreactCombobox-option--divider\" : \"\",\n              ]\n                .filter(Boolean)\n                .join(\" \");\n              return (\n                <li\n                  key={option.value}\n                  id={`${id}-option-${toHTMLId(option.value)}`}\n                  className={optionClasses}\n                  // biome-ignore lint/a11y/useSemanticElements: <explanation>\n                  role=\"option\"\n                  tabIndex={-1}\n                  aria-selected={isSelected}\n                  aria-disabled={isDisabled}\n                  onMouseEnter={() => !isDisabled && activateDescendant(option.value, false)}\n                  onMouseDown={(e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    handleOptionSelect(option.value, { toggleSelected: true });\n                    if (shouldUseTray) {\n                      if (!multiple) {\n                        closeTray();\n                      } else {\n                        focusTrayInput();\n                      }\n                    } else {\n                      if (!multiple) {\n                        closeDropdown();\n                      }\n                      focusInput();\n                    }\n                  }}\n                >\n                  {optionRenderer({\n                    option,\n                    language,\n                    isActive,\n                    isSelected,\n                    isInvalid,\n                    showValue,\n                    warningIcon,\n                    tickIcon,\n                    optionIconRenderer,\n                  })}\n                  {isSelected ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"selected\"\n                      aria-hidden={!isActive}\n                    >\n                      {mergedTranslations.selectedOption}\n                    </span>\n                  ) : null}\n                  {isInvalid ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"invalid\"\n                      aria-hidden={!isActive}\n                    >\n                      {mergedTranslations.invalidOption}\n                    </span>\n                  ) : null}\n                </li>\n              );\n            })}\n            {filteredOptions.length === 0 &&\n              !isLoading &&\n              (!allowFreeText || !activeInputValue || arrayValues.includes(activeInputValue)) && (\n                <li className=\"PreactCombobox-option\">{mergedTranslations.noOptionsFound}</li>\n              )}\n            {filteredOptions.length === maxNumberOfPresentedOptions && (\n              <li className=\"PreactCombobox-option\">{mergedTranslations.typeToLoadMore}</li>\n            )}\n          </>\n        )}\n      </ul>\n    );\n  }\n\n  return (\n    <div\n      className={[\n        className,\n        \"PreactCombobox\",\n        disabled ? \"PreactCombobox--disabled\" : \"\",\n        `PreactCombobox--${theme}`,\n        tray === \"auto\" ? \"PreactCombobox--trayAuto\" : \"\",\n      ]\n        .filter(Boolean)\n        .join(\" \")}\n      aria-disabled={disabled}\n      onClick={handleRootElementClick}\n      id={`${id}-root`}\n      ref={rootElementRef}\n      {...rootElementProps}\n    >\n      {/* Live region for announcing selections to screen readers */}\n      <div className=\"PreactCombobox-srOnly\" aria-live=\"polite\" aria-atomic=\"true\">\n        {getIsFocused() ? lastSelectionAnnouncement : \"\"}\n      </div>\n\n      {/* Live region for announcing loading status to screen readers */}\n      <div className=\"PreactCombobox-srOnly\" aria-live=\"polite\" aria-atomic=\"true\">\n        {getIsFocused() ? loadingAnnouncement : \"\"}\n      </div>\n\n      {/* Live region for announcing loading status to screen readers */}\n      <div className=\"PreactCombobox-srOnly\" aria-live=\"polite\" aria-atomic=\"true\">\n        {invalidValues.length > 0 && getIsFocused()\n          ? mergedTranslations.fieldContainsInvalidValues\n          : \"\"}\n      </div>\n\n      <div className={`PreactCombobox-field ${disabled ? \"PreactCombobox-field--disabled\" : \"\"}`}>\n        {!isServerSideForm && (\n          <>\n            {/* Show icon for single select mode */}\n            {!multiple &&\n              singleSelectValue &&\n              allOptionsLookup[singleSelectValue] &&\n              optionIconRenderer?.(allOptionsLookup[singleSelectValue], true)}\n            <input\n              id={id}\n              ref={inputRef}\n              type=\"text\"\n              value={inputValue}\n              placeholder={\n                !shouldUseTray && getIsDropdownOpen()\n                  ? mergedTranslations.searchPlaceholder\n                  : arrayValues.length > 0\n                    ? arrayValues.map((value) => allOptionsLookup[value]?.label || value).join(\", \")\n                    : placeholder\n              }\n              onChange={handleInputChange}\n              onKeyDown={handleKeyDown}\n              onFocus={handleInputFocus}\n              onBlur={() => {\n                // @ts-ignore\n                blurTimeoutRef.current = setTimeout(handleInputBlur, 200);\n              }}\n              onPaste={handlePaste}\n              className={`PreactCombobox-input ${\n                multiple ? \"PreactCombobox-input--multiple\" : \"\"\n              } ${disabled ? \"PreactCombobox-input--disabled\" : \"\"}`}\n              role=\"combobox\"\n              aria-expanded={getIsDropdownOpen()}\n              aria-haspopup=\"listbox\"\n              aria-controls={`${id}-options-listbox`}\n              aria-activedescendant={\n                activeDescendant.current\n                  ? `${id}-option-${toHTMLId(activeDescendant.current)}`\n                  : undefined\n              }\n              disabled={disabled}\n              required={required && arrayValues.length === 0}\n              {...inputProps}\n            />\n            {!disabled && showClearButton && arrayValues.length > 0 ? (\n              <button\n                type=\"button\"\n                className=\"PreactCombobox-clearButton\"\n                aria-label={mergedTranslations.clearValue}\n                onClick={handleClearValue}\n              >\n                <span aria-hidden=\"true\">&#x2715;</span>\n              </button>\n            ) : null}\n            {invalidValues.length > 0 && (\n              <span\n                ref={warningIconRef}\n                className=\"PreactCombobox-warningIconWrapper\"\n                onMouseEnter={() => setWarningIconHovered(true)}\n                onMouseLeave={() => setWarningIconHovered(false)}\n              >\n                {warningIcon}\n              </span>\n            )}\n            {multiple && arrayValues.length > 1 && (\n              <span className=\"PreactCombobox-badge\">\n                {mergedTranslations.selectedCountFormatter(arrayValues.length, language)}\n              </span>\n            )}\n            {chevronIcon}\n          </>\n        )}\n\n        {/* This is a hidden select element to allow for form submission */}\n        {formSubmitCompatible ? (\n          <select\n            {...selectElementProps}\n            multiple={multiple}\n            hidden={!isServerSideForm}\n            tabIndex={isServerSideForm ? 0 : -1}\n            readOnly={!isServerSideForm}\n            // @ts-expect-error this is a valid react attribute\n            value={value}\n            name={name}\n            size={1}\n            className={isServerSideForm ? \"PreactCombobox-formSelect\" : \"\"}\n          >\n            {selectChildren}\n          </select>\n        ) : null}\n      </div>\n\n      {list && (\n        <Portal parent={portal} rootElementRef={rootElementRef}>\n          {shouldUseTray ? (\n            // I couldn't use native <dialog> element because trying to focus input right\n            // after dialog.close() doesn't seem to work on Chrome (Android).\n            <div\n              ref={trayModalRef}\n              className={`PreactCombobox-modal ${`PreactCombobox--${theme}`}`}\n              style={{ display: getIsTrayOpen() ? null : \"none\" }}\n              onClick={(e) => {\n                // Close modal when clicking backdrop\n                if (e.target === trayModalRef.current) {\n                  closeTray();\n                }\n              }}\n              onKeyDown={(e) => {\n                if (e.key === \"Escape\") {\n                  closeTray();\n                }\n              }}\n              // biome-ignore lint/a11y/useSemanticElements: Custom modal implementation instead of dialog element\n              role=\"dialog\"\n              aria-modal=\"true\"\n              aria-labelledby={getTrayLabel() ? `${id}-tray-label` : undefined}\n              tabIndex={-1}\n            >\n              <div className={`PreactCombobox-tray ${`PreactCombobox--${theme}`}`}>\n                <div className=\"PreactCombobox-trayHeader\">\n                  {getTrayLabel() && (\n                    <label\n                      id={`${id}-tray-label`}\n                      className=\"PreactCombobox-trayLabel\"\n                      htmlFor={`${id}-tray-input`}\n                    >\n                      {getTrayLabel()}\n                    </label>\n                  )}\n                  <input\n                    id={`${id}-tray-input`}\n                    ref={trayInputRef}\n                    type=\"text\"\n                    value={trayInputValue}\n                    placeholder={mergedTranslations.searchPlaceholder}\n                    onChange={handleTrayInputChange}\n                    onKeyDown={(e) => {\n                      if (e.key === \"Escape\") {\n                        closeTray();\n                      }\n                    }}\n                    className={`PreactCombobox-trayInput ${!getTrayLabel() ? \"PreactCombobox-trayInput--noLabel\" : \"\"}`}\n                    role=\"combobox\"\n                    aria-expanded=\"true\"\n                    aria-haspopup=\"listbox\"\n                    aria-controls={`${id}-options-listbox`}\n                    aria-label={getTrayLabel() || mergedTranslations.searchPlaceholder}\n                    autoComplete=\"off\"\n                  />\n                </div>\n                {list}\n                {virtualKeyboardHeight > 0 && (\n                  <div\n                    className=\"PreactCombobox-virtualKeyboardSpacer\"\n                    style={{ height: `${virtualKeyboardHeight}px` }}\n                    aria-hidden=\"true\"\n                  />\n                )}\n              </div>\n            </div>\n          ) : (\n            list\n          )}\n        </Portal>\n      )}\n      {invalidValues.length > 0 && warningIconHovered && !isServer && (\n        <Portal parent={portal} rootElementRef={rootElementRef}>\n          <div\n            className={`PreactCombobox-valueTooltip ${`PreactCombobox--${theme}`}`}\n            role=\"tooltip\"\n            ref={tooltipPopperRef}\n          >\n            {mergedTranslations.invalidValues}\n            {invalidValues.map((value) => (\n              <div key={value} className=\"PreactCombobox-tooltipValue\">\n                {value}\n              </div>\n            ))}\n          </div>\n        </Portal>\n      )}\n    </div>\n  );\n};\n\nexport default PreactCombobox;\n", "import { useCallback, useMemo, useRef, useState } from \"preact/hooks\";\n\nexport function isEqual(value1, value2) {\n  // Handle circular references using WeakMap\n  const seenA = new WeakMap();\n  const seenB = new WeakMap();\n\n  function deepCompare(a, b) {\n    // Handle primitives\n    if (Object.is(a, b)) return true;\n    if (a === null || b === null || typeof a !== \"object\" || typeof b !== \"object\") {\n      return a === b;\n    }\n\n    // Handle React/JSX elements - direct reference comparison since they're immutable\n    // This prevents unnecessary deep comparisons\n    if (a.$$typeof === Symbol.for(\"react.element\") || b.$$typeof === Symbol.for(\"react.element\")) {\n      return a === b;\n    }\n\n    // Handle different types\n    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n      return false;\n    }\n\n    // Check for circular references\n    if (seenA.has(a)) return seenA.get(a) === b;\n    if (seenB.has(b)) return seenB.get(b) === a;\n    // detect cross object circular references\n    if (seenA.has(b) || seenB.has(a)) return false;\n    seenA.set(a, b);\n    seenB.set(b, a);\n\n    // Handle Arrays\n    if (Array.isArray(a)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      return a.every((item, index) => deepCompare(item, b[index]));\n    }\n\n    // Handle Dates\n    if (a instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n\n    // Handle RegExp\n    if (a instanceof RegExp) {\n      return a.toString() === b.toString();\n    }\n\n    // Handle Objects\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    return keysA.every((key) => keysB.includes(key) && deepCompare(a[key], b[key]));\n  }\n\n  return deepCompare(value1, value2);\n}\n\n/**\n * Both dependencies and state are compared using a deep equality function.\n * @template T\n * @param {T} newState\n * @returns {T}\n */\nexport function useDeepMemo(newState) {\n  const state = useRef(/** @type {T} */ (null));\n  if (!isEqual(newState, state.current)) {\n    state.current = newState;\n  }\n  return state.current;\n}\n\n/**\n * @template T\n * @param {T} initialValue\n * @returns {[() => T, (value: T) => void, boolean]}\n */\nexport function useLive(initialValue) {\n  const [refreshValue, forceRefresh] = useState(0);\n  const ref = useRef(initialValue);\n\n  // refreshValue is used to create a new getter so that any useEffect etc that depends on it will be re-run\n  // In addition, provide `hasValueChanged` to help detect in a multi-dependency useEffect whether this specific\n  // state has changed.\n  let hasValueChanged = false;\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explanation above\n  const getValue = useMemo(() => {\n    hasValueChanged = true;\n    return () => ref.current;\n  }, [refreshValue]);\n\n  // setter doesn't need to be created on every render\n  const setValue = useCallback((value) => {\n    if (value !== ref.current) {\n      ref.current = value;\n      forceRefresh((x) => x + 1);\n    }\n  }, []);\n\n  return [getValue, setValue, hasValueChanged];\n}\n"],
  "mappings": "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",
  "names": ["useCallback", "useMemo", "useRef", "useState", "useState", "querySegments", "matches", "useMemo", "useRef", "useCallback", "filteredOptions", "value"]
}
