{
  "version": 3,
  "sources": ["../../lib/OptionsListbox.jsx", "../../lib/utils.jsx"],
  "sourcesContent": ["import { forwardRef } from \"preact/compat\";\nimport { useCallback, useEffect, useImperativeHandle, useRef, useState } from \"preact/hooks\";\nimport { toHTMLId } from \"./utils.jsx\";\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"./PreactCombobox.jsx\").Translations} Translations\n * @typedef {import(\"./PreactCombobox.jsx\").OptionTransformFunction} OptionTransformFunction\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @typedef {Object} OptionsListboxProps\n * @property {string} id - Component ID for ARIA attributes\n * @property {string} searchText - Current search/input text\n * @property {OptionMatch[]} filteredOptions - Pre-filtered options to display\n * @property {boolean} isLoading - Whether options are currently loading\n * @property {string[]} arrayValues - Currently selected values\n * @property {string[]} invalidValues - Invalid selected values\n * @property {boolean} multiple - Whether multi-select is enabled\n * @property {boolean} allowFreeText - Allow adding custom options\n * @property {(selectedValue: string, options?: {toggleSelected?: boolean}) => void} onOptionSelect - Handle option selection\n * @property {(value: string) => void} [onActiveDescendantChange] - Callback when active descendant changes (for aria-activedescendant)\n * @property {() => void} [onClose] - Handle close (for single-select)\n * @property {OptionTransformFunction} optionRenderer - Function to render options\n * @property {VNode} warningIcon - Warning icon element\n * @property {VNode} tickIcon - Tick icon element\n * @property {(option: Option, isInput?: boolean) => VNode|null} optionIconRenderer - Option icon renderer\n * @property {boolean} showValue - Whether to show option values\n * @property {string} language - Language code for rendering\n * @property {(text: string) => VNode|string} loadingRenderer - Loading renderer\n * @property {Translations} translations - Translation strings\n * @property {string} theme - Theme for styling\n * @property {boolean} isOpen - Whether the list should be visible\n * @property {boolean} shouldUseTray - Whether this is used in tray mode\n * @property {(ref: HTMLUListElement | null) => void} [setDropdownRef] - Callback to set dropdown ref for popper\n */\n\n/**\n * @typedef {Object} OptionsListboxRef\n * @property {() => void} navigateUp - Navigate to previous option\n * @property {() => void} navigateDown - Navigate to next option\n * @property {() => void} navigateToFirst - Navigate to first option\n * @property {() => void} navigateToLast - Navigate to last option\n * @property {() => boolean} selectActive - Select the currently active option, returns true if selection was made\n * @property {() => string} getActiveDescendant - Get the currently active descendant value\n * @property {(value: string) => void} setActiveDescendant - Set the active descendant value\n * @property {() => void} clearActiveDescendant - Clear the active descendant\n */\n\n/**\n * OptionsListbox component - renders a listbox with keyboard navigation and selection\n * Receives pre-filtered options and handles navigation/selection\n * @type {import(\"preact/compat\").ForwardRefExoticComponent<OptionsListboxProps & import(\"preact/compat\").RefAttributes<OptionsListboxRef>>}\n */\nconst OptionsListbox = forwardRef(\n  (\n    /** @type {OptionsListboxProps} */\n    {\n      id,\n      searchText,\n      filteredOptions,\n      isLoading,\n      arrayValues,\n      invalidValues,\n      multiple,\n      allowFreeText,\n      onOptionSelect,\n      onActiveDescendantChange,\n      onClose,\n      optionRenderer,\n      warningIcon,\n      tickIcon,\n      optionIconRenderer,\n      showValue,\n      language,\n      loadingRenderer,\n      translations,\n      theme,\n      isOpen,\n      shouldUseTray,\n      setDropdownRef,\n    },\n    ref,\n  ) => {\n    const [activeDescendant, setActiveDescendant] = useState(\"\");\n    const listRef = useRef(/** @type {HTMLUListElement | null} */ (null));\n\n    const searchTextTrimmed = searchText.trim();\n\n    const addNewOptionVisible =\n      !isLoading &&\n      allowFreeText &&\n      searchTextTrimmed &&\n      !arrayValues.includes(searchTextTrimmed) &&\n      !filteredOptions.find((/** @type {OptionMatch} */ o) => o.value === searchTextTrimmed);\n\n    const scrollOptionIntoView = useCallback(\n      /** @param {string} optionValue */\n      (optionValue) => {\n        if (!listRef.current || !optionValue) return;\n        const elementId = `${id}-option-${toHTMLId(optionValue)}`;\n        const element = listRef.current.querySelector(`#${CSS.escape(elementId)}`);\n        if (element) {\n          const listRect = listRef.current.getBoundingClientRect();\n          const itemRect = element.getBoundingClientRect();\n          if (itemRect.bottom > listRect.bottom) {\n            element.scrollIntoView({ block: \"end\" });\n          } else if (itemRect.top < listRect.top) {\n            element.scrollIntoView({ block: \"start\" });\n          }\n        }\n      },\n      [id],\n    );\n\n    const getNavigableOptions = useCallback(() => {\n      const options = filteredOptions\n        .filter((/** @type {OptionMatch} */ o) => !o.disabled)\n        .map((/** @type {OptionMatch} */ o) => o.value);\n      if (addNewOptionVisible) {\n        return [searchTextTrimmed, ...options];\n      }\n      return options;\n    }, [filteredOptions, addNewOptionVisible, searchTextTrimmed]);\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        navigateDown: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : -1;\n          const nextIndex = currentIndex === options.length - 1 ? 0 : currentIndex + 1;\n          const nextValue = options[nextIndex];\n          if (nextValue !== undefined) {\n            setActiveDescendant(nextValue);\n            scrollOptionIntoView(nextValue);\n          }\n        },\n        navigateUp: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : 0;\n          const prevIndex = currentIndex <= 0 ? options.length - 1 : currentIndex - 1;\n          const prevValue = options[prevIndex];\n          if (prevValue !== undefined) {\n            setActiveDescendant(prevValue);\n            scrollOptionIntoView(prevValue);\n          }\n        },\n        navigateToFirst: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const firstValue = options[0];\n          if (firstValue !== undefined) {\n            setActiveDescendant(firstValue);\n            scrollOptionIntoView(firstValue);\n          }\n        },\n        navigateToLast: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const lastValue = options[options.length - 1];\n          if (lastValue !== undefined) {\n            setActiveDescendant(lastValue);\n            scrollOptionIntoView(lastValue);\n          }\n        },\n        selectActive: () => {\n          if (!activeDescendant) return false;\n\n          if (addNewOptionVisible && activeDescendant === searchTextTrimmed) {\n            onOptionSelect(searchTextTrimmed);\n            if (!multiple && onClose) {\n              onClose();\n            }\n            return true;\n          }\n\n          const option = filteredOptions.find(\n            (/** @type {OptionMatch} */ o) => o.value === activeDescendant,\n          );\n          if (option && !option.disabled) {\n            onOptionSelect(option.value, { toggleSelected: true });\n            if (!multiple && onClose) {\n              onClose();\n            }\n            return true;\n          }\n\n          return false;\n        },\n        getActiveDescendant: () => activeDescendant,\n        setActiveDescendant: (value) => {\n          setActiveDescendant(value);\n          scrollOptionIntoView(value);\n        },\n        clearActiveDescendant: () => setActiveDescendant(\"\"),\n      }),\n      [\n        activeDescendant,\n        getNavigableOptions,\n        scrollOptionIntoView,\n        addNewOptionVisible,\n        searchTextTrimmed,\n        filteredOptions,\n        onOptionSelect,\n        multiple,\n        onClose,\n      ],\n    );\n\n    useEffect(() => {\n      if (!isOpen) {\n        setActiveDescendant(\"\");\n      }\n    }, [isOpen]);\n\n    useEffect(() => {\n      onActiveDescendantChange?.(activeDescendant);\n    }, [activeDescendant, onActiveDescendantChange]);\n\n    const handleListRef = useCallback(\n      /** @param {HTMLUListElement | null} el */\n      (el) => {\n        listRef.current = el;\n        if (setDropdownRef && !shouldUseTray) {\n          setDropdownRef(el);\n        }\n      },\n      [setDropdownRef, shouldUseTray],\n    );\n\n    if (!isOpen) {\n      return null;\n    }\n\n    return (\n      // biome-ignore lint/a11y/useFocusableInteractive: <explanation>\n      <ul\n        className={[\n          \"PreactCombobox-options\",\n          `PreactCombobox--${theme}`,\n          shouldUseTray ? \"PreactCombobox-options--tray\" : \"\",\n        ]\n          .filter(Boolean)\n          .join(\" \")}\n        // biome-ignore lint/a11y/useSemanticElements: it is correct by examples I've found for comboboxes\n        role=\"listbox\"\n        id={`${id}-options-listbox`}\n        aria-multiselectable={multiple ? \"true\" : undefined}\n        hidden={!isOpen}\n        ref={handleListRef}\n      >\n        {isLoading ? (\n          <li className=\"PreactCombobox-option\" aria-disabled>\n            {loadingRenderer(translations.loadingOptions)}\n          </li>\n        ) : (\n          <>\n            {addNewOptionVisible && (\n              <li\n                key={searchTextTrimmed}\n                id={`${id}-option-${toHTMLId(searchTextTrimmed)}`}\n                className={`PreactCombobox-option ${activeDescendant === searchTextTrimmed ? \"PreactCombobox-option--active\" : \"\"}`}\n                // biome-ignore lint/a11y/useSemanticElements: parent is <ul> so want to keep equivalent semantics\n                role=\"option\"\n                tabIndex={-1}\n                aria-selected={false}\n                onMouseEnter={() => setActiveDescendant(searchTextTrimmed)}\n                onMouseDown={(e) => {\n                  e.preventDefault();\n                  e.stopPropagation();\n                  onOptionSelect(searchTextTrimmed);\n                  if (!multiple && onClose) {\n                    onClose();\n                  }\n                }}\n              >\n                {translations.addOption.replace(\"{value}\", searchTextTrimmed)}\n              </li>\n            )}\n            {filteredOptions.map((/** @type {OptionMatch} */ option) => {\n              const isActive = activeDescendant === option.value;\n              const isSelected = arrayValues.includes(option.value);\n              const isInvalid = invalidValues.includes(option.value);\n              const isDisabled = option.disabled;\n              const hasDivider = option.divider && !searchTextTrimmed;\n              const optionClasses = [\n                \"PreactCombobox-option\",\n                isActive ? \"PreactCombobox-option--active\" : \"\",\n                isSelected ? \"PreactCombobox-option--selected\" : \"\",\n                isInvalid ? \"PreactCombobox-option--invalid\" : \"\",\n                isDisabled ? \"PreactCombobox-option--disabled\" : \"\",\n                hasDivider ? \"PreactCombobox-option--divider\" : \"\",\n              ]\n                .filter(Boolean)\n                .join(\" \");\n              return (\n                <li\n                  key={option.value}\n                  id={`${id}-option-${toHTMLId(option.value)}`}\n                  className={optionClasses}\n                  // biome-ignore lint/a11y/useSemanticElements: <explanation>\n                  role=\"option\"\n                  tabIndex={-1}\n                  aria-selected={isSelected}\n                  aria-disabled={isDisabled}\n                  onMouseEnter={() => !isDisabled && setActiveDescendant(option.value)}\n                  onMouseDown={(e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onOptionSelect(option.value, { toggleSelected: true });\n                    if (!multiple && onClose) {\n                      onClose();\n                    }\n                  }}\n                >\n                  {optionRenderer({\n                    option,\n                    language,\n                    isActive,\n                    isSelected,\n                    isInvalid,\n                    showValue,\n                    warningIcon,\n                    tickIcon,\n                    optionIconRenderer,\n                  })}\n                  {isSelected ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"selected\"\n                      aria-hidden={!isActive}\n                    >\n                      {translations.selectedOption}\n                    </span>\n                  ) : null}\n                  {isInvalid ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"invalid\"\n                      aria-hidden={!isActive}\n                    >\n                      {translations.invalidOption}\n                    </span>\n                  ) : null}\n                </li>\n              );\n            })}\n            {filteredOptions.length === 0 &&\n              !isLoading &&\n              (!allowFreeText || !searchText || arrayValues.includes(searchText)) && (\n                <li className=\"PreactCombobox-option\">{translations.noOptionsFound}</li>\n              )}\n          </>\n        )}\n      </ul>\n    );\n  },\n);\n\nexport default OptionsListbox;\n", "/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/** @type {Record<string, LanguageCache>} */\nconst languageCache = {};\n\n/**\n * Converts any text into a valid HTML ID attribute value.\n * Returns empty string if text becomes empty after removing invalid characters.\n *\n * @param {string} text - The text to convert into an HTML ID\n * @returns {string} A valid HTML ID or empty string\n */\nexport function toHTMLId(text) {\n  // Remove any characters that are not letters, numbers, hyphens, underscores, colons, or periods\n  return text.replace(/[^a-zA-Z0-9\\-_:.]/g, \"\");\n}\n\n/**\n * @template {OptionMatch|Option} T\n * @param {T[]} options\n * @param {string[]} values\n * @returns {T[]}\n */\nexport function sortValuesToTop(options, values) {\n  const selectedSet = new Set(values);\n  return options.sort((a, b) => {\n    const aSelected = selectedSet.has(a.value);\n    const bSelected = selectedSet.has(b.value);\n    if (aSelected === bSelected) return 0;\n    return aSelected ? -1 : 1;\n  });\n}\n\n/**\n * @param {string} query\n * @param {Option} option\n * @param {string} language\n * @returns {OptionMatch|null}\n */\nfunction getExactMatchScore(query, option, language) {\n  const { label, value, ...rest } = option;\n  if (value === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (label === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  const { caseMatcher } = /** @type {LanguageCache} */ (languageCache[language]);\n  if (caseMatcher.compare(value, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (caseMatcher.compare(label, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  return null;\n}\n\n/**\n * Calculates the match score between a query text and a list of option labels.\n * It returns scores for each option sorted in descending order.\n *\n * It takes the `query` string, evaluates the following rules in order and assigns the one with highest score:\n * - Score 7: If whole query matches a label on an option (Case insensitive match)\n * - Score 5: Same as previous check but this time case and accent insensitive matching\n * - Score 3: Phrase matching (e.g. \"word1 partialWord2*\")\n * - Score 0-1: Number of words matched / total number of words in query (e.g. \"word1\")\n *\n * @param {string} query - The query text to match against options.\n * @param {Option[]} options\n * @param {string} [language='en'] Language to use for word splitting and matching\n * @param {boolean} [filterAndSort=true] Whether to filter and sort the results. If false, returns all options but with attempted matches.\n * @returns {Array<OptionMatch>}\n */\nexport function getMatchScore(query, options, language = \"en\", filterAndSort = true) {\n  // biome-ignore lint/style/noParameterAssign: ignore\n  query = query.trim();\n\n  if (!query) {\n    const matchSlices = /** @type {Array<[number, number]>} */ ([]);\n    return options.map((option) => ({\n      ...option,\n      label: option.label,\n      value: option.value,\n      score: 0,\n      matched: \"none\",\n      matchSlices,\n    }));\n  }\n\n  if (!languageCache[language]) {\n    languageCache[language] = {\n      baseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"base\",\n      }),\n      caseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"accent\",\n      }),\n      wordSegmenter: new Intl.Segmenter(language, {\n        granularity: \"word\",\n      }),\n    };\n  }\n  const { baseMatcher, caseMatcher, wordSegmenter } = languageCache[language];\n\n  const isCommaSeparated = query.includes(\",\");\n\n  let matches = options.map((option) => {\n    const { label, value, ...rest } = option;\n    if (isCommaSeparated) {\n      const querySegments = query.split(\",\");\n      const matches = querySegments\n        .map((querySegment) => getExactMatchScore(querySegment.trim(), option, language))\n        .filter((match) => match !== null)\n        .sort((a, b) => b.score - a.score);\n      return /** @type {OptionMatch} */ (\n        matches[0] || {\n          ...rest,\n          label,\n          value,\n          score: 0,\n          matched: \"none\",\n        }\n      );\n    }\n\n    // Rule 1: Exact match (case sensitive)\n    // Rule 2: Exact match (case insensitive)\n    const exactMatch = getExactMatchScore(query, option, language);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Rule 3: Exact match with accents normalized (case insensitive)\n    if (baseMatcher.compare(label, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'label'} */\n        matched: \"label\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, label.length]],\n      };\n    }\n    if (baseMatcher.compare(value, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, value.length]],\n      };\n    }\n\n    // Rule 4: Phrase match (imagine a wildcard query like \"word1 partialWord2*\")\n    // This match needs to be case and accent insensitive\n    const querySegments = Array.from(wordSegmenter.segment(query));\n    const labelWordSegments = Array.from(wordSegmenter.segment(label.trim()));\n    let len = 0;\n    let firstIndex = -1;\n    for (let i = 0; i < labelWordSegments.length; i++) {\n      const labelWordSegment = /** @type {Intl.SegmentData} */ (labelWordSegments[i]);\n      const querySegment = querySegments[len];\n      if (!querySegment) break;\n      if (len === querySegments.length - 1) {\n        // check for partial word match\n        // I can't use labelWordSegment.segment.startsWith(querySegment.segment) because it's case and accent sensitive\n        const lastQueryWord = querySegment.segment;\n        if (\n          baseMatcher.compare(\n            labelWordSegment.segment.slice(0, lastQueryWord.length),\n            lastQueryWord,\n          ) === 0\n        ) {\n          return {\n            ...rest,\n            label,\n            value,\n            score: 3,\n            /** @type {'label'} */\n            matched: \"label\",\n            /** @type {Array<[number, number]>} */\n            // @ts-ignore\n            matchSlices: [\n              [\n                firstIndex > -1 ? firstIndex : labelWordSegment.index,\n                labelWordSegment.index + lastQueryWord.length,\n              ],\n            ],\n          };\n        }\n      } else if (baseMatcher.compare(labelWordSegment.segment, querySegment.segment) === 0) {\n        len++;\n        if (len === 1) {\n          firstIndex = labelWordSegment.index;\n        }\n        continue;\n      }\n      len = 0;\n      firstIndex = -1;\n    }\n    // Also check for partial value match (this doesn't need accent check)\n    if (caseMatcher.compare(value.slice(0, query.length), query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 3,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, query.length]],\n      };\n    }\n\n    // Rule 5: Word matches\n    const queryWords = querySegments.filter((s) => s.isWordLike);\n    const labelWords = labelWordSegments.filter((s) => s.isWordLike);\n    /** @type {Array<[number, number]|undefined>} */\n    const slices = queryWords.map((word) => {\n      const match = labelWords.find(\n        (labelWord) => baseMatcher.compare(labelWord.segment, word.segment) === 0,\n      );\n      if (match) {\n        return [match.index, match.index + match.segment.length];\n      }\n    });\n    // TODO: Do we need a deep equal de-duplication here?\n    const matchSlices = slices.filter((s) => s !== undefined).sort((a, b) => a[0] - b[0]);\n    const wordScoring = matchSlices.length / queryWords.length;\n    return {\n      ...rest,\n      label,\n      value,\n      score: wordScoring,\n      /** @type {'label'|'none'} */\n      matched: wordScoring ? \"label\" : \"none\",\n      matchSlices,\n    };\n  });\n\n  if (filterAndSort) {\n    matches = matches.filter((match) => match.score > 0);\n    matches.sort((a, b) => {\n      if (a.score === b.score) {\n        const val = a.label.localeCompare(b.label, undefined, {\n          sensitivity: \"base\",\n        });\n        return val === 0 ? a.value.localeCompare(b.value, undefined, { sensitivity: \"base\" }) : val;\n      }\n      return b.score - a.score;\n    });\n  }\n  return matches;\n}\n\n/**\n * @param {OptionMatch['matchSlices']} matchSlices\n * @param {string} text\n * @returns {VNode[]}\n */\nexport function matchSlicesToNodes(matchSlices, text) {\n  const nodes = /** @type {VNode[]} */ ([]);\n  let index = 0;\n  matchSlices.map((slice) => {\n    const [start, end] = slice;\n    if (index < start) {\n      nodes.push(<span key={`${index}-${start}`}>{text.slice(index, start)}</span>);\n    }\n    nodes.push(<u key={`${start}-${end}`}>{text.slice(start, end)}</u>);\n    index = end;\n  });\n  if (index < text.length) {\n    nodes.push(<span key={`${index}-${text.length}`}>{text.slice(index)}</span>);\n  }\n  return nodes;\n}\n"],
  "mappings": ";AAAA,SAAS,kBAAkB;AAC3B,SAAS,aAAa,WAAW,qBAAqB,QAAQ,gBAAgB;;;ACkU7D;AA3SV,SAAS,SAAS,MAAM;AAE7B,SAAO,KAAK,QAAQ,sBAAsB,EAAE;AAC9C;;;ADwOU,SAIA,UAJA,OAAAA,MA4CM,YA5CN;AA3MV,IAAM,iBAAiB;AAAA,EACrB,CAEE;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GACA,QACG;AACH,UAAM,CAAC,kBAAkB,mBAAmB,IAAI,SAAS,EAAE;AAC3D,UAAM,UAAU;AAAA;AAAA,MAA+C;AAAA,IAAK;AAEpE,UAAM,oBAAoB,WAAW,KAAK;AAE1C,UAAM,sBACJ,CAAC,aACD,iBACA,qBACA,CAAC,YAAY,SAAS,iBAAiB,KACvC,CAAC,gBAAgB,KAAK,CAA4B,MAAM,EAAE,UAAU,iBAAiB;AAEvF,UAAM,uBAAuB;AAAA;AAAA,MAE3B,CAAC,gBAAgB;AACf,YAAI,CAAC,QAAQ,WAAW,CAAC,YAAa;AACtC,cAAM,YAAY,GAAG,EAAE,WAAW,SAAS,WAAW,CAAC;AACvD,cAAM,UAAU,QAAQ,QAAQ,cAAc,IAAI,IAAI,OAAO,SAAS,CAAC,EAAE;AACzE,YAAI,SAAS;AACX,gBAAM,WAAW,QAAQ,QAAQ,sBAAsB;AACvD,gBAAM,WAAW,QAAQ,sBAAsB;AAC/C,cAAI,SAAS,SAAS,SAAS,QAAQ;AACrC,oBAAQ,eAAe,EAAE,OAAO,MAAM,CAAC;AAAA,UACzC,WAAW,SAAS,MAAM,SAAS,KAAK;AACtC,oBAAQ,eAAe,EAAE,OAAO,QAAQ,CAAC;AAAA,UAC3C;AAAA,QACF;AAAA,MACF;AAAA,MACA,CAAC,EAAE;AAAA,IACL;AAEA,UAAM,sBAAsB,YAAY,MAAM;AAC5C,YAAM,UAAU,gBACb,OAAO,CAA4B,MAAM,CAAC,EAAE,QAAQ,EACpD,IAAI,CAA4B,MAAM,EAAE,KAAK;AAChD,UAAI,qBAAqB;AACvB,eAAO,CAAC,mBAAmB,GAAG,OAAO;AAAA,MACvC;AACA,aAAO;AAAA,IACT,GAAG,CAAC,iBAAiB,qBAAqB,iBAAiB,CAAC;AAE5D;AAAA,MACE;AAAA,MACA,OAAO;AAAA,QACL,cAAc,MAAM;AAClB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAE1B,gBAAM,eAAe,mBAAmB,QAAQ,QAAQ,gBAAgB,IAAI;AAC5E,gBAAM,YAAY,iBAAiB,QAAQ,SAAS,IAAI,IAAI,eAAe;AAC3E,gBAAM,YAAY,QAAQ,SAAS;AACnC,cAAI,cAAc,QAAW;AAC3B,gCAAoB,SAAS;AAC7B,iCAAqB,SAAS;AAAA,UAChC;AAAA,QACF;AAAA,QACA,YAAY,MAAM;AAChB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAE1B,gBAAM,eAAe,mBAAmB,QAAQ,QAAQ,gBAAgB,IAAI;AAC5E,gBAAM,YAAY,gBAAgB,IAAI,QAAQ,SAAS,IAAI,eAAe;AAC1E,gBAAM,YAAY,QAAQ,SAAS;AACnC,cAAI,cAAc,QAAW;AAC3B,gCAAoB,SAAS;AAC7B,iCAAqB,SAAS;AAAA,UAChC;AAAA,QACF;AAAA,QACA,iBAAiB,MAAM;AACrB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAC1B,gBAAM,aAAa,QAAQ,CAAC;AAC5B,cAAI,eAAe,QAAW;AAC5B,gCAAoB,UAAU;AAC9B,iCAAqB,UAAU;AAAA,UACjC;AAAA,QACF;AAAA,QACA,gBAAgB,MAAM;AACpB,gBAAM,UAAU,oBAAoB;AACpC,cAAI,QAAQ,WAAW,EAAG;AAC1B,gBAAM,YAAY,QAAQ,QAAQ,SAAS,CAAC;AAC5C,cAAI,cAAc,QAAW;AAC3B,gCAAoB,SAAS;AAC7B,iCAAqB,SAAS;AAAA,UAChC;AAAA,QACF;AAAA,QACA,cAAc,MAAM;AAClB,cAAI,CAAC,iBAAkB,QAAO;AAE9B,cAAI,uBAAuB,qBAAqB,mBAAmB;AACjE,2BAAe,iBAAiB;AAChC,gBAAI,CAAC,YAAY,SAAS;AACxB,sBAAQ;AAAA,YACV;AACA,mBAAO;AAAA,UACT;AAEA,gBAAM,SAAS,gBAAgB;AAAA,YAC7B,CAA4B,MAAM,EAAE,UAAU;AAAA,UAChD;AACA,cAAI,UAAU,CAAC,OAAO,UAAU;AAC9B,2BAAe,OAAO,OAAO,EAAE,gBAAgB,KAAK,CAAC;AACrD,gBAAI,CAAC,YAAY,SAAS;AACxB,sBAAQ;AAAA,YACV;AACA,mBAAO;AAAA,UACT;AAEA,iBAAO;AAAA,QACT;AAAA,QACA,qBAAqB,MAAM;AAAA,QAC3B,qBAAqB,CAAC,UAAU;AAC9B,8BAAoB,KAAK;AACzB,+BAAqB,KAAK;AAAA,QAC5B;AAAA,QACA,uBAAuB,MAAM,oBAAoB,EAAE;AAAA,MACrD;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,cAAU,MAAM;AACd,UAAI,CAAC,QAAQ;AACX,4BAAoB,EAAE;AAAA,MACxB;AAAA,IACF,GAAG,CAAC,MAAM,CAAC;AAEX,cAAU,MAAM;AACd,iCAA2B,gBAAgB;AAAA,IAC7C,GAAG,CAAC,kBAAkB,wBAAwB,CAAC;AAE/C,UAAM,gBAAgB;AAAA;AAAA,MAEpB,CAAC,OAAO;AACN,gBAAQ,UAAU;AAClB,YAAI,kBAAkB,CAAC,eAAe;AACpC,yBAAe,EAAE;AAAA,QACnB;AAAA,MACF;AAAA,MACA,CAAC,gBAAgB,aAAa;AAAA,IAChC;AAEA,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AAEA;AAAA;AAAA,MAEE,gBAAAA;AAAA,QAAC;AAAA;AAAA,UACC,WAAW;AAAA,YACT;AAAA,YACA,mBAAmB,KAAK;AAAA,YACxB,gBAAgB,iCAAiC;AAAA,UACnD,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AAAA,UAEX,MAAK;AAAA,UACL,IAAI,GAAG,EAAE;AAAA,UACT,wBAAsB,WAAW,SAAS;AAAA,UAC1C,QAAQ,CAAC;AAAA,UACT,KAAK;AAAA,UAEJ,sBACC,gBAAAA,KAAC,QAAG,WAAU,yBAAwB,iBAAa,MAChD,0BAAgB,aAAa,cAAc,GAC9C,IAEA,iCACG;AAAA,mCACC,gBAAAA;AAAA,cAAC;AAAA;AAAA,gBAEC,IAAI,GAAG,EAAE,WAAW,SAAS,iBAAiB,CAAC;AAAA,gBAC/C,WAAW,yBAAyB,qBAAqB,oBAAoB,kCAAkC,EAAE;AAAA,gBAEjH,MAAK;AAAA,gBACL,UAAU;AAAA,gBACV,iBAAe;AAAA,gBACf,cAAc,MAAM,oBAAoB,iBAAiB;AAAA,gBACzD,aAAa,CAAC,MAAM;AAClB,oBAAE,eAAe;AACjB,oBAAE,gBAAgB;AAClB,iCAAe,iBAAiB;AAChC,sBAAI,CAAC,YAAY,SAAS;AACxB,4BAAQ;AAAA,kBACV;AAAA,gBACF;AAAA,gBAEC,uBAAa,UAAU,QAAQ,WAAW,iBAAiB;AAAA;AAAA,cAjBvD;AAAA,YAkBP;AAAA,YAED,gBAAgB,IAAI,CAA4B,WAAW;AAC1D,oBAAM,WAAW,qBAAqB,OAAO;AAC7C,oBAAM,aAAa,YAAY,SAAS,OAAO,KAAK;AACpD,oBAAM,YAAY,cAAc,SAAS,OAAO,KAAK;AACrD,oBAAM,aAAa,OAAO;AAC1B,oBAAM,aAAa,OAAO,WAAW,CAAC;AACtC,oBAAM,gBAAgB;AAAA,gBACpB;AAAA,gBACA,WAAW,kCAAkC;AAAA,gBAC7C,aAAa,oCAAoC;AAAA,gBACjD,YAAY,mCAAmC;AAAA,gBAC/C,aAAa,oCAAoC;AAAA,gBACjD,aAAa,mCAAmC;AAAA,cAClD,EACG,OAAO,OAAO,EACd,KAAK,GAAG;AACX,qBACE;AAAA,gBAAC;AAAA;AAAA,kBAEC,IAAI,GAAG,EAAE,WAAW,SAAS,OAAO,KAAK,CAAC;AAAA,kBAC1C,WAAW;AAAA,kBAEX,MAAK;AAAA,kBACL,UAAU;AAAA,kBACV,iBAAe;AAAA,kBACf,iBAAe;AAAA,kBACf,cAAc,MAAM,CAAC,cAAc,oBAAoB,OAAO,KAAK;AAAA,kBACnE,aAAa,CAAC,MAAM;AAClB,sBAAE,eAAe;AACjB,sBAAE,gBAAgB;AAClB,mCAAe,OAAO,OAAO,EAAE,gBAAgB,KAAK,CAAC;AACrD,wBAAI,CAAC,YAAY,SAAS;AACxB,8BAAQ;AAAA,oBACV;AAAA,kBACF;AAAA,kBAEC;AAAA,mCAAe;AAAA,sBACd;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,sBACA;AAAA,oBACF,CAAC;AAAA,oBACA,aACC,gBAAAA;AAAA,sBAAC;AAAA;AAAA,wBACC,WAAU;AAAA,wBACV,eAAY;AAAA,wBACZ,eAAY;AAAA,wBACZ,eAAa,CAAC;AAAA,wBAEb,uBAAa;AAAA;AAAA,oBAChB,IACE;AAAA,oBACH,YACC,gBAAAA;AAAA,sBAAC;AAAA;AAAA,wBACC,WAAU;AAAA,wBACV,eAAY;AAAA,wBACZ,eAAY;AAAA,wBACZ,eAAa,CAAC;AAAA,wBAEb,uBAAa;AAAA;AAAA,oBAChB,IACE;AAAA;AAAA;AAAA,gBAhDC,OAAO;AAAA,cAiDd;AAAA,YAEJ,CAAC;AAAA,YACA,gBAAgB,WAAW,KAC1B,CAAC,cACA,CAAC,iBAAiB,CAAC,cAAc,YAAY,SAAS,UAAU,MAC/D,gBAAAA,KAAC,QAAG,WAAU,yBAAyB,uBAAa,gBAAe;AAAA,aAEzE;AAAA;AAAA,MAEJ;AAAA;AAAA,EAEJ;AACF;AAEA,IAAO,yBAAQ;",
  "names": ["jsx"]
}
