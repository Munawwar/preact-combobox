{
  "version": 3,
  "sources": ["../../lib/AutocompleteList.jsx", "../../lib/hooks.js", "../../lib/utils.jsx"],
  "sourcesContent": ["import { forwardRef } from \"preact/compat\";\nimport { useCallback, useEffect, useImperativeHandle, useMemo, useRef, useState } from \"preact/hooks\";\nimport { useDeepMemo } from \"./hooks.js\";\nimport { getMatchScore, sortValuesToTop, toHTMLId } from \"./utils.jsx\";\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"./PreactCombobox.jsx\").Translations} Translations\n * @typedef {import(\"./PreactCombobox.jsx\").OptionTransformFunction} OptionTransformFunction\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * @typedef {Object} AutocompleteListProps\n * @property {string} id - Component ID for ARIA attributes\n * @property {string} searchText - Current search/input text\n * @property {Option[] | ((queryOrValues: string[] | string, limit: number, currentSelections: string[], abortControllerSignal: AbortSignal) => Promise<Option[]>)} allowedOptions - Options data or fetcher function\n * @property {string[]} arrayValues - Currently selected values\n * @property {string[]} invalidValues - Invalid selected values\n * @property {boolean} multiple - Whether multi-select is enabled\n * @property {boolean} allowFreeText - Allow adding custom options\n * @property {string} language - Language code for matching\n * @property {number} maxNumberOfPresentedOptions - Maximum options to show\n * @property {(selectedValue: string, options?: {toggleSelected?: boolean}) => void} onOptionSelect - Handle option selection\n * @property {(value: string) => void} [onActiveDescendantChange] - Callback when active descendant changes (for aria-activedescendant)\n * @property {() => void} [onClose] - Handle close (for single-select)\n * @property {OptionTransformFunction} optionRenderer - Function to render options\n * @property {VNode} warningIcon - Warning icon element\n * @property {VNode} tickIcon - Tick icon element\n * @property {(option: Option, isInput?: boolean) => VNode|null} optionIconRenderer - Option icon renderer\n * @property {boolean} showValue - Whether to show option values\n * @property {(text: string) => VNode|string} loadingRenderer - Loading renderer\n * @property {Translations} translations - Translation strings\n * @property {string} theme - Theme for styling\n * @property {boolean} isOpen - Whether the list should be visible\n * @property {boolean} shouldUseTray - Whether this is used in tray mode\n * @property {(ref: HTMLUListElement | null) => void} [setDropdownRef] - Callback to set dropdown ref for popper\n */\n\n/**\n * @typedef {Object} AutocompleteListRef\n * @property {() => void} navigateUp - Navigate to previous option\n * @property {() => void} navigateDown - Navigate to next option\n * @property {() => void} navigateToFirst - Navigate to first option\n * @property {() => void} navigateToLast - Navigate to last option\n * @property {() => boolean} selectActive - Select the currently active option, returns true if selection was made\n * @property {() => string} getActiveDescendant - Get the currently active descendant value\n * @property {(value: string) => void} setActiveDescendant - Set the active descendant value\n * @property {() => void} clearActiveDescendant - Clear the active descendant\n */\n\n// @ts-ignore\nconst isPlaywright = navigator.webdriver === true;\n\n/**\n * AutocompleteList component - handles filtering, fetching, and rendering options list\n * @type {import(\"preact/compat\").ForwardRefExoticComponent<AutocompleteListProps & import(\"preact/compat\").RefAttributes<AutocompleteListRef>>}\n */\nconst AutocompleteList = forwardRef(\n  (\n    {\n      id,\n      searchText,\n      allowedOptions,\n      arrayValues,\n      invalidValues,\n      multiple,\n      allowFreeText,\n      language,\n      maxNumberOfPresentedOptions,\n      onOptionSelect,\n      onActiveDescendantChange,\n      onClose,\n      optionRenderer,\n      warningIcon,\n      tickIcon,\n      optionIconRenderer,\n      showValue,\n      loadingRenderer,\n      translations,\n      theme,\n      isOpen,\n      shouldUseTray,\n      setDropdownRef,\n    },\n    ref,\n  ) => {\n    // Internal state for filtering/fetching\n    const [filteredOptions, setFilteredOptions] = useState(/** @type {OptionMatch[]} */ ([]));\n    const [isLoading, setIsLoading] = useState(false);\n    const [activeDescendant, setActiveDescendant] = useState(\"\");\n    const cachedOptions = useRef(/** @type {{ [value: string]: Option }} */ ({}));\n    const abortControllerRef = useRef(/** @type {AbortController | null} */ (null));\n    const inputTypingDebounceTimer = useRef(/** @type {any} */ (null));\n    const listRef = useRef(/** @type {HTMLUListElement | null} */ (null));\n\n    const searchTextTrimmed = searchText.trim();\n    const allowedOptionsAsKey = useDeepMemo(\n      typeof allowedOptions === \"function\" ? null : allowedOptions,\n    );\n\n    const updateCachedOptions = useCallback(\n      /** @param {Option[]} update */\n      (update) => {\n        for (const item of update) {\n          cachedOptions.current[item.value] = item;\n        }\n      },\n      [],\n    );\n\n    const allOptions = useDeepMemo(\n      Array.isArray(allowedOptions) ? allowedOptions : Object.values(cachedOptions.current),\n    );\n    const allOptionsLookup = useMemo(\n      () =>\n        allOptions.reduce(\n          (acc, o) => {\n            acc[o.value] = o;\n            return acc;\n          },\n          /** @type {{ [value: string]: Option }} */ ({}),\n        ),\n      [allOptions],\n    );\n\n    const newUnknownValues = arrayValues.filter((v) => !allOptionsLookup[v]);\n    const newUnknownValuesAsKey = useDeepMemo(newUnknownValues);\n\n    const addNewOptionVisible =\n      !isLoading &&\n      allowFreeText &&\n      searchTextTrimmed &&\n      !arrayValues.includes(searchTextTrimmed) &&\n      !filteredOptions.find((o) => o.value === searchTextTrimmed);\n\n    // Helper to scroll an option into view\n    const scrollOptionIntoView = useCallback(\n      /** @param {string} optionValue */\n      (optionValue) => {\n        if (!listRef.current || !optionValue) return;\n        const elementId = `${id}-option-${toHTMLId(optionValue)}`;\n        const element = listRef.current.querySelector(`#${elementId}`);\n        if (element) {\n          const listRect = listRef.current.getBoundingClientRect();\n          const itemRect = element.getBoundingClientRect();\n          if (itemRect.bottom > listRect.bottom) {\n            element.scrollIntoView({ block: \"end\" });\n          } else if (itemRect.top < listRect.top) {\n            element.scrollIntoView({ block: \"start\" });\n          }\n        }\n      },\n      [id],\n    );\n\n    // Build list of navigable options (including \"add new\" option if visible)\n    const getNavigableOptions = useCallback(() => {\n      const options = filteredOptions.filter((o) => !o.disabled).map((o) => o.value);\n      if (addNewOptionVisible) {\n        // \"Add new\" option appears at the top\n        return [searchTextTrimmed, ...options];\n      }\n      return options;\n    }, [filteredOptions, addNewOptionVisible, searchTextTrimmed]);\n\n    // Expose navigation methods via ref\n    useImperativeHandle(\n      ref,\n      () => ({\n        navigateDown: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : -1;\n          const nextIndex = currentIndex === options.length - 1 ? 0 : currentIndex + 1;\n          const nextValue = options[nextIndex];\n          if (nextValue !== undefined) {\n            setActiveDescendant(nextValue);\n            scrollOptionIntoView(nextValue);\n          }\n        },\n        navigateUp: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n\n          const currentIndex = activeDescendant ? options.indexOf(activeDescendant) : 0;\n          const prevIndex = currentIndex <= 0 ? options.length - 1 : currentIndex - 1;\n          const prevValue = options[prevIndex];\n          if (prevValue !== undefined) {\n            setActiveDescendant(prevValue);\n            scrollOptionIntoView(prevValue);\n          }\n        },\n        navigateToFirst: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const firstValue = options[0];\n          if (firstValue !== undefined) {\n            setActiveDescendant(firstValue);\n            scrollOptionIntoView(firstValue);\n          }\n        },\n        navigateToLast: () => {\n          const options = getNavigableOptions();\n          if (options.length === 0) return;\n          const lastValue = options[options.length - 1];\n          if (lastValue !== undefined) {\n            setActiveDescendant(lastValue);\n            scrollOptionIntoView(lastValue);\n          }\n        },\n        selectActive: () => {\n          if (!activeDescendant) return false;\n\n          // Check if it's the \"add new\" option\n          if (addNewOptionVisible && activeDescendant === searchTextTrimmed) {\n            onOptionSelect(searchTextTrimmed);\n            if (!multiple && onClose) {\n              onClose();\n            }\n            return true;\n          }\n\n          // Check if it's a regular option\n          const option = filteredOptions.find((o) => o.value === activeDescendant);\n          if (option && !option.disabled) {\n            onOptionSelect(option.value, { toggleSelected: true });\n            if (!multiple && onClose) {\n              onClose();\n            }\n            return true;\n          }\n\n          return false;\n        },\n        getActiveDescendant: () => activeDescendant,\n        setActiveDescendant: (value) => {\n          setActiveDescendant(value);\n          scrollOptionIntoView(value);\n        },\n        clearActiveDescendant: () => setActiveDescendant(\"\"),\n      }),\n      [\n        activeDescendant,\n        getNavigableOptions,\n        scrollOptionIntoView,\n        addNewOptionVisible,\n        searchTextTrimmed,\n        filteredOptions,\n        onOptionSelect,\n        multiple,\n        onClose,\n      ],\n    );\n\n    // Clear active descendant when dropdown closes\n    useEffect(() => {\n      if (!isOpen) {\n        setActiveDescendant(\"\");\n      }\n    }, [isOpen]);\n\n    // Notify parent when active descendant changes (for aria-activedescendant on input)\n    useEffect(() => {\n      onActiveDescendantChange?.(activeDescendant);\n    }, [activeDescendant, onActiveDescendantChange]);\n\n    // Main filtering/fetching effect\n    useEffect(() => {\n      const shouldFetchOptions = isOpen || typeof allowedOptions === \"function\";\n      if (!shouldFetchOptions) return;\n\n      const abortController = typeof allowedOptions === \"function\" ? new AbortController() : null;\n      abortControllerRef.current?.abort();\n      abortControllerRef.current = abortController;\n\n      let debounceTime = 0; // for local data\n      if (\n        typeof allowedOptions === \"function\" &&\n        !(\n          // don't debounce for initial render (when we have to resolve the labels for selected values).\n          // don't debounce for first time the dropdown is opened as well.\n          (newUnknownValues.length > 0 || isOpen)\n        ) &&\n        // Hack: We avoid debouncing to speed up playwright tests\n        !isPlaywright\n      ) {\n        // a typical user types 4 characters per second, so 250ms is a good debounce time\n        debounceTime = 250;\n      }\n      clearTimeout(inputTypingDebounceTimer.current);\n\n      const callback = async () => {\n        if (typeof allowedOptions === \"function\") {\n          // @ts-ignore\n          const signal = /** @type {AbortSignal} */ (abortController.signal);\n          const [searchResults, selectedResults] = await Promise.all([\n            isOpen\n              ? allowedOptions(searchTextTrimmed, maxNumberOfPresentedOptions, arrayValues, signal)\n              : /** @type {Option[]} */ ([]),\n            // We need to fetch unknown options's labels regardless of whether the dropdown\n            // is open or not, because we want to show it in the placeholder.\n            newUnknownValues.length > 0\n              ? allowedOptions(newUnknownValues, newUnknownValues.length, arrayValues, signal)\n              : null,\n          ]).catch((error) => {\n            if (signal.aborted) {\n              return [null, null];\n            }\n            setIsLoading(false);\n            throw error;\n          });\n\n          setIsLoading(false);\n          if (searchResults?.length) {\n            updateCachedOptions(searchResults);\n          }\n          if (selectedResults?.length) {\n            updateCachedOptions(selectedResults);\n          }\n          let updatedOptions = searchResults || [];\n          // Handle case where backend doesn't return labels for all the sent selections\n          if (!searchTextTrimmed) {\n            const unreturnedValues = newUnknownValues\n              .filter((v) => !cachedOptions.current[v])\n              .map((v) => ({ label: v, value: v }));\n            if (unreturnedValues.length > 0) {\n              updateCachedOptions(unreturnedValues);\n              updatedOptions = unreturnedValues.concat(searchResults || []);\n            }\n          }\n          // when search is applied don't sort the selected values to the top\n          const options = searchTextTrimmed\n            ? updatedOptions\n            : sortValuesToTop(updatedOptions, arrayValues);\n          // we don't need to re-sort what the backend returns, so pass filterAndSort=false to getMatchScore()\n          setFilteredOptions(getMatchScore(searchTextTrimmed, options, language, false));\n        } else {\n          const mergedOptions = arrayValues\n            .filter((v) => !allOptionsLookup[v])\n            .map((v) => ({ label: v, value: v }))\n            .concat(allowedOptions);\n          // when search is applied don't sort the selected values to the top\n          const options = searchText ? mergedOptions : sortValuesToTop(mergedOptions, arrayValues);\n          setFilteredOptions(getMatchScore(searchText, options, language, true));\n        }\n      };\n\n      // We need to set isLoading immediately to show \"loading\" state without waiting\n      // for the debounce to complete so that playwright tests don't need an arbitrary\n      // wait delay for the options to load.\n      if (typeof allowedOptions === \"function\") {\n        setIsLoading(true);\n      }\n\n      let timer = null;\n      if (debounceTime > 0) {\n        timer = setTimeout(callback, debounceTime);\n      } else {\n        callback();\n      }\n      inputTypingDebounceTimer.current = timer;\n\n      // Clean up function\n      return () => {\n        abortController?.abort();\n        if (timer) clearTimeout(timer);\n      };\n    }, [\n      isOpen,\n      searchTextTrimmed,\n      language,\n      newUnknownValuesAsKey,\n      allowedOptionsAsKey,\n      arrayValues,\n      maxNumberOfPresentedOptions,\n      updateCachedOptions,\n      allOptionsLookup,\n      searchText,\n      allowedOptions,\n    ]);\n\n    // Set ref callback for parent's popper\n    const handleListRef = useCallback(\n      /** @param {HTMLUListElement | null} el */\n      (el) => {\n        listRef.current = el;\n        if (setDropdownRef && !shouldUseTray) {\n          setDropdownRef(el);\n        }\n      },\n      [setDropdownRef, shouldUseTray],\n    );\n\n    if (!isOpen) {\n      return null;\n    }\n\n    return (\n      // biome-ignore lint/a11y/useFocusableInteractive: <explanation>\n      <ul\n        className={[\n          \"PreactCombobox-options\",\n          `PreactCombobox--${theme}`,\n          shouldUseTray ? \"PreactCombobox-options--tray\" : \"\",\n        ]\n          .filter(Boolean)\n          .join(\" \")}\n        // biome-ignore lint/a11y/useSemanticElements: it is correct by examples I've found for comboboxes\n        role=\"listbox\"\n        id={`${id}-options-listbox`}\n        aria-multiselectable={multiple ? \"true\" : undefined}\n        hidden={!isOpen}\n        ref={handleListRef}\n      >\n        {isLoading ? (\n          <li className=\"PreactCombobox-option\" aria-disabled>\n            {loadingRenderer(translations.loadingOptions)}\n          </li>\n        ) : (\n          <>\n            {addNewOptionVisible && (\n              <li\n                key={searchTextTrimmed}\n                id={`${id}-option-${toHTMLId(searchTextTrimmed)}`}\n                className={`PreactCombobox-option ${activeDescendant === searchTextTrimmed ? \"PreactCombobox-option--active\" : \"\"}`}\n                // biome-ignore lint/a11y/useSemanticElements: parent is <ul> so want to keep equivalent semantics\n                role=\"option\"\n                tabIndex={-1}\n                aria-selected={false}\n                onMouseEnter={() => setActiveDescendant(searchTextTrimmed)}\n                onMouseDown={(e) => {\n                  e.preventDefault();\n                  e.stopPropagation();\n                  onOptionSelect(searchTextTrimmed);\n                  if (!multiple && onClose) {\n                    onClose();\n                  }\n                }}\n              >\n                {translations.addOption.replace(\"{value}\", searchTextTrimmed)}\n              </li>\n            )}\n            {filteredOptions.map((option) => {\n              // \"Active\" means it's like a focus / hover. It doesn't mean the option was selected.\n              // aria-activedescendant is used to tell screen readers the active option.\n              const isActive = activeDescendant === option.value;\n              const isSelected = arrayValues.includes(option.value);\n              const isInvalid = invalidValues.includes(option.value);\n              const isDisabled = option.disabled;\n              const hasDivider = option.divider && !searchTextTrimmed; // Only show divider when search is empty\n              const optionClasses = [\n                \"PreactCombobox-option\",\n                isActive ? \"PreactCombobox-option--active\" : \"\",\n                isSelected ? \"PreactCombobox-option--selected\" : \"\",\n                isInvalid ? \"PreactCombobox-option--invalid\" : \"\",\n                isDisabled ? \"PreactCombobox-option--disabled\" : \"\",\n                hasDivider ? \"PreactCombobox-option--divider\" : \"\",\n              ]\n                .filter(Boolean)\n                .join(\" \");\n              return (\n                <li\n                  key={option.value}\n                  id={`${id}-option-${toHTMLId(option.value)}`}\n                  className={optionClasses}\n                  // biome-ignore lint/a11y/useSemanticElements: <explanation>\n                  role=\"option\"\n                  tabIndex={-1}\n                  aria-selected={isSelected}\n                  aria-disabled={isDisabled}\n                  onMouseEnter={() => !isDisabled && setActiveDescendant(option.value)}\n                  onMouseDown={(e) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onOptionSelect(option.value, { toggleSelected: true });\n                    if (!multiple && onClose) {\n                      onClose();\n                    }\n                  }}\n                >\n                  {optionRenderer({\n                    option,\n                    language,\n                    isActive,\n                    isSelected,\n                    isInvalid,\n                    showValue,\n                    warningIcon,\n                    tickIcon,\n                    optionIconRenderer,\n                  })}\n                  {isSelected ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"selected\"\n                      aria-hidden={!isActive}\n                    >\n                      {translations.selectedOption}\n                    </span>\n                  ) : null}\n                  {isInvalid ? (\n                    <span\n                      className=\"PreactCombobox-srOnly\"\n                      aria-atomic=\"true\"\n                      data-reader=\"invalid\"\n                      aria-hidden={!isActive}\n                    >\n                      {translations.invalidOption}\n                    </span>\n                  ) : null}\n                </li>\n              );\n            })}\n            {filteredOptions.length === 0 &&\n              !isLoading &&\n              (!allowFreeText || !searchText || arrayValues.includes(searchText)) && (\n                <li className=\"PreactCombobox-option\">{translations.noOptionsFound}</li>\n              )}\n            {filteredOptions.length === maxNumberOfPresentedOptions && (\n              <li className=\"PreactCombobox-option\">{translations.typeToLoadMore}</li>\n            )}\n          </>\n        )}\n      </ul>\n    );\n  },\n);\n\nexport default AutocompleteList;\n", "import { useCallback, useMemo, useRef, useState } from \"preact/hooks\";\n\nexport function isEqual(value1, value2) {\n  // Handle circular references using WeakMap\n  const seenA = new WeakMap();\n  const seenB = new WeakMap();\n\n  function deepCompare(a, b) {\n    // Handle primitives\n    if (Object.is(a, b)) return true;\n    if (a === null || b === null || typeof a !== \"object\" || typeof b !== \"object\") {\n      return a === b;\n    }\n\n    // Handle React/JSX elements - direct reference comparison since they're immutable\n    // This prevents unnecessary deep comparisons\n    if (a.$$typeof === Symbol.for(\"react.element\") || b.$$typeof === Symbol.for(\"react.element\")) {\n      return a === b;\n    }\n\n    // Handle different types\n    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n      return false;\n    }\n\n    // Check for circular references\n    if (seenA.has(a)) return seenA.get(a) === b;\n    if (seenB.has(b)) return seenB.get(b) === a;\n    // detect cross object circular references\n    if (seenA.has(b) || seenB.has(a)) return false;\n    seenA.set(a, b);\n    seenB.set(b, a);\n\n    // Handle Arrays\n    if (Array.isArray(a)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      return a.every((item, index) => deepCompare(item, b[index]));\n    }\n\n    // Handle Dates\n    if (a instanceof Date) {\n      return a.getTime() === b.getTime();\n    }\n\n    // Handle RegExp\n    if (a instanceof RegExp) {\n      return a.toString() === b.toString();\n    }\n\n    // Handle Objects\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) return false;\n\n    return keysA.every((key) => keysB.includes(key) && deepCompare(a[key], b[key]));\n  }\n\n  return deepCompare(value1, value2);\n}\n\n/**\n * Both dependencies and state are compared using a deep equality function.\n * @template T\n * @param {T} newState\n * @returns {T}\n */\nexport function useDeepMemo(newState) {\n  const state = useRef(/** @type {T} */ (null));\n  if (!isEqual(newState, state.current)) {\n    state.current = newState;\n  }\n  return state.current;\n}\n\n/**\n * @template T\n * @param {T} initialValue\n * @returns {[() => T, (value: T) => void, boolean]}\n */\nexport function useLive(initialValue) {\n  const [refreshValue, forceRefresh] = useState(0);\n  const ref = useRef(initialValue);\n\n  // refreshValue is used to create a new getter so that any useEffect etc that depends on it will be re-run\n  // In addition, provide `hasValueChanged` to help detect in a multi-dependency useEffect whether this specific\n  // state has changed.\n  let hasValueChanged = false;\n  // biome-ignore lint/correctness/useExhaustiveDependencies: explanation above\n  const getValue = useMemo(() => {\n    hasValueChanged = true;\n    return () => ref.current;\n  }, [refreshValue]);\n\n  // setter doesn't need to be created on every render\n  const setValue = useCallback((value) => {\n    if (value !== ref.current) {\n      ref.current = value;\n      forceRefresh((x) => x + 1);\n    }\n  }, []);\n\n  return [getValue, setValue, hasValueChanged];\n}\n\nconst isTouchDevice =\n  typeof window !== \"undefined\" && window.matchMedia?.(\"(pointer: coarse)\")?.matches;\n// Since page hasn't potentially fully loaded yet we get only an approximate height\nlet visualViewportInitialHeight = window.visualViewport?.height ?? 0;\n\n/**\n * Subscribe to virtual keyboard visibility changes (touch devices only)\n * @param {Object} params - Parameters for subscribing to virtual keyboard\n * @param {function(boolean): void} [params.visibleCallback] - Called with boolean when keyboard visibility changes\n * @param {function(number, boolean): void} [params.heightCallback] - Called with keyboard height when keyboard height changes\n * @returns {function | null} - Unsubscribe function\n */\nexport function subscribeToVirtualKeyboard({ visibleCallback, heightCallback }) {\n  if (!isTouchDevice || typeof window === \"undefined\" || !window.visualViewport) return null;\n\n  let isVisible = false;\n  const handleViewportResize = () => {\n    if (!window.visualViewport) return;\n    const heightDiff = visualViewportInitialHeight - window.visualViewport.height;\n    const isVisibleNow = heightDiff > 150;\n    if (isVisible !== isVisibleNow) {\n      isVisible = isVisibleNow;\n      visibleCallback?.(isVisible);\n    }\n    heightCallback?.(heightDiff, isVisible);\n  };\n  window.visualViewport.addEventListener(\"resize\", handleViewportResize, { passive: true });\n  return () => {\n    window.visualViewport?.removeEventListener(\"resize\", handleViewportResize);\n  };\n}\n", "import { h } from \"preact\";\n\n/**\n * @typedef {import(\"./PreactCombobox.jsx\").Option} Option\n * @typedef {import(\"./PreactCombobox.jsx\").OptionMatch} OptionMatch\n * @typedef {import(\"preact\").VNode} VNode\n */\n\n/**\n * Cache for language-specific word segmenters\n * @typedef {Object} LanguageCache\n * @property {Intl.Collator} baseMatcher - The base matcher for the language\n * @property {Intl.Collator} caseMatcher - The case matcher for the language\n * @property {Intl.Segmenter} wordSegmenter - The word segmenter for the language\n */\n\n/** @type {Record<string, LanguageCache>} */\nconst languageCache = {};\n\n/**\n * Converts any text into a valid HTML ID attribute value.\n * Returns empty string if text becomes empty after removing invalid characters.\n *\n * @param {string} text - The text to convert into an HTML ID\n * @returns {string} A valid HTML ID or empty string\n */\nexport function toHTMLId(text) {\n  // Remove any characters that are not letters, numbers, hyphens, underscores, colons, or periods\n  return text.replace(/[^a-zA-Z0-9\\-_:.]/g, \"\");\n}\n\n/**\n * @template {OptionMatch|Option} T\n * @param {T[]} options\n * @param {string[]} values\n * @returns {T[]}\n */\nexport function sortValuesToTop(options, values) {\n  const selectedSet = new Set(values);\n  return options.sort((a, b) => {\n    const aSelected = selectedSet.has(a.value);\n    const bSelected = selectedSet.has(b.value);\n    if (aSelected === bSelected) return 0;\n    return aSelected ? -1 : 1;\n  });\n}\n\n/**\n * @param {string} query\n * @param {Option} option\n * @param {string} language\n * @returns {OptionMatch|null}\n */\nfunction getExactMatchScore(query, option, language) {\n  const { label, value, ...rest } = option;\n  if (value === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (label === query) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 9,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  const { caseMatcher } = /** @type {LanguageCache} */ (languageCache[language]);\n  if (caseMatcher.compare(value, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'value'} */\n      matched: \"value\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, value.length]],\n    };\n  }\n  if (caseMatcher.compare(label, query) === 0) {\n    return {\n      ...rest,\n      label,\n      value,\n      score: 7,\n      /** @type {'label'} */\n      matched: \"label\",\n      /** @type {Array<[number, number]>} */\n      matchSlices: [[0, label.length]],\n    };\n  }\n\n  return null;\n}\n\n/**\n * Calculates the match score between a query text and a list of option labels.\n * It returns scores for each option sorted in descending order.\n *\n * It takes the `query` string, evaluates the following rules in order and assigns the one with highest score:\n * - Score 7: If whole query matches a label on an option (Case insensitive match)\n * - Score 5: Same as previous check but this time case and accent insensitive matching\n * - Score 3: Phrase matching (e.g. \"word1 partialWord2*\")\n * - Score 0-1: Number of words matched / total number of words in query (e.g. \"word1\")\n *\n * @param {string} query - The query text to match against options.\n * @param {Option[]} options\n * @param {string} [language='en'] Language to use for word splitting and matching\n * @param {boolean} [filterAndSort=true] Whether to filter and sort the results. If false, returns all options but with attempted matches.\n * @returns {Array<OptionMatch>}\n */\nexport function getMatchScore(query, options, language = \"en\", filterAndSort = true) {\n  // biome-ignore lint/style/noParameterAssign: ignore\n  query = query.trim();\n\n  if (!query) {\n    const matchSlices = /** @type {Array<[number, number]>} */ ([]);\n    return options.map((option) => ({\n      ...option,\n      label: option.label,\n      value: option.value,\n      score: 0,\n      matched: \"none\",\n      matchSlices,\n    }));\n  }\n\n  if (!languageCache[language]) {\n    languageCache[language] = {\n      baseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"base\",\n      }),\n      caseMatcher: new Intl.Collator(language, {\n        usage: \"search\",\n        sensitivity: \"accent\",\n      }),\n      wordSegmenter: new Intl.Segmenter(language, {\n        granularity: \"word\",\n      }),\n    };\n  }\n  const { baseMatcher, caseMatcher, wordSegmenter } = languageCache[language];\n\n  const isCommaSeparated = query.includes(\",\");\n\n  let matches = options.map((option) => {\n    const { label, value, ...rest } = option;\n    if (isCommaSeparated) {\n      const querySegments = query.split(\",\");\n      const matches = querySegments\n        .map((querySegment) => getExactMatchScore(querySegment.trim(), option, language))\n        .filter((match) => match !== null)\n        .sort((a, b) => b.score - a.score);\n      return /** @type {OptionMatch} */ (\n        matches[0] || {\n          ...rest,\n          label,\n          value,\n          score: 0,\n          matched: \"none\",\n        }\n      );\n    }\n\n    // Rule 1: Exact match (case sensitive)\n    // Rule 2: Exact match (case insensitive)\n    const exactMatch = getExactMatchScore(query, option, language);\n    if (exactMatch) {\n      return exactMatch;\n    }\n\n    // Rule 3: Exact match with accents normalized (case insensitive)\n    if (baseMatcher.compare(label, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'label'} */\n        matched: \"label\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, label.length]],\n      };\n    }\n    if (baseMatcher.compare(value, query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 5,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, value.length]],\n      };\n    }\n\n    // Rule 4: Phrase match (imagine a wildcard query like \"word1 partialWord2*\")\n    // This match needs to be case and accent insensitive\n    const querySegments = Array.from(wordSegmenter.segment(query));\n    const labelWordSegments = Array.from(wordSegmenter.segment(label.trim()));\n    let len = 0;\n    let firstIndex = -1;\n    for (let i = 0; i < labelWordSegments.length; i++) {\n      const labelWordSegment = /** @type {Intl.SegmentData} */ (labelWordSegments[i]);\n      const querySegment = querySegments[len];\n      if (!querySegment) break;\n      if (len === querySegments.length - 1) {\n        // check for partial word match\n        // I can't use labelWordSegment.segment.startsWith(querySegment.segment) because it's case and accent sensitive\n        const lastQueryWord = querySegment.segment;\n        if (\n          baseMatcher.compare(\n            labelWordSegment.segment.slice(0, lastQueryWord.length),\n            lastQueryWord,\n          ) === 0\n        ) {\n          return {\n            ...rest,\n            label,\n            value,\n            score: 3,\n            /** @type {'label'} */\n            matched: \"label\",\n            /** @type {Array<[number, number]>} */\n            // @ts-ignore\n            matchSlices: [\n              [\n                firstIndex > -1 ? firstIndex : labelWordSegment.index,\n                labelWordSegment.index + lastQueryWord.length,\n              ],\n            ],\n          };\n        }\n      } else if (baseMatcher.compare(labelWordSegment.segment, querySegment.segment) === 0) {\n        len++;\n        if (len === 1) {\n          firstIndex = labelWordSegment.index;\n        }\n        continue;\n      }\n      len = 0;\n      firstIndex = -1;\n    }\n    // Also check for partial value match (this doesn't need accent check)\n    if (caseMatcher.compare(value.slice(0, query.length), query) === 0) {\n      return {\n        ...rest,\n        label,\n        value,\n        score: 3,\n        /** @type {'value'} */\n        matched: \"value\",\n        /** @type {Array<[number, number]>} */\n        matchSlices: [[0, query.length]],\n      };\n    }\n\n    // Rule 5: Word matches\n    const queryWords = querySegments.filter((s) => s.isWordLike);\n    const labelWords = labelWordSegments.filter((s) => s.isWordLike);\n    /** @type {Array<[number, number]|undefined>} */\n    const slices = queryWords.map((word) => {\n      const match = labelWords.find(\n        (labelWord) => baseMatcher.compare(labelWord.segment, word.segment) === 0,\n      );\n      if (match) {\n        return [match.index, match.index + match.segment.length];\n      }\n    });\n    // TODO: Do we need a deep equal de-duplication here?\n    const matchSlices = slices.filter((s) => s !== undefined).sort((a, b) => a[0] - b[0]);\n    const wordScoring = matchSlices.length / queryWords.length;\n    return {\n      ...rest,\n      label,\n      value,\n      score: wordScoring,\n      /** @type {'label'|'none'} */\n      matched: wordScoring ? \"label\" : \"none\",\n      matchSlices,\n    };\n  });\n\n  if (filterAndSort) {\n    matches = matches.filter((match) => match.score > 0);\n    matches.sort((a, b) => {\n      if (a.score === b.score) {\n        const val = a.label.localeCompare(b.label, undefined, {\n          sensitivity: \"base\",\n        });\n        return val === 0 ? a.value.localeCompare(b.value, undefined, { sensitivity: \"base\" }) : val;\n      }\n      return b.score - a.score;\n    });\n  }\n  return matches;\n}\n\n/**\n * @param {OptionMatch['matchSlices']} matchSlices\n * @param {string} text\n * @returns {VNode[]}\n */\nexport function matchSlicesToNodes(matchSlices, text) {\n  const nodes = /** @type {VNode[]} */ ([]);\n  let index = 0;\n  matchSlices.map((slice) => {\n    const [start, end] = slice;\n    if (index < start) {\n      nodes.push(<span key={`${index}-${start}`}>{text.slice(index, start)}</span>);\n    }\n    nodes.push(<u key={`${start}-${end}`}>{text.slice(start, end)}</u>);\n    index = end;\n  });\n  if (index < text.length) {\n    nodes.push(<span key={`${index}-${text.length}`}>{text.slice(index)}</span>);\n  }\n  return nodes;\n}\n"],
  "mappings": "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",
  "names": ["useCallback", "useMemo", "useRef", "useState", "querySegments", "matches", "jsx", "useState", "useRef", "useCallback", "useMemo"]
}
